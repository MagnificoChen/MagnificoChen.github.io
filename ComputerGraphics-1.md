<head>
    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async>
</script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [["$", "$"], ["\\(", "\\)"]],
            displayMath: [["$$", "$$"], ["\\[", "\\]"]],
            }
        });
    </script>
</head>

- [第一章 简介](#第一章-简介)
  - [1.1 图形学的领域](#11-图形学的领域)
  - [1.2 主要应用场景](#12-主要应用场景)
  - [1.3 一些图形 API](#13-一些图形-api)
  - [1.4 图形流水线](#14-图形流水线)
  - [1.5 数值问题](#15-数值问题)
  - [1.6 代码效率](#16-代码效率)
  - [1.7 设计和编写图形程序](#17-设计和编写图形程序)
    - [1.7.1 类型设计](#171-类型设计)
    - [1.7.2 单精度与双精度浮点型](#172-单精度与双精度浮点型)
    - [1.7.3 对图形程序进行 Debug](#173-对图形程序进行-debug)
  - [后记](#后记)
- [第二章 数学知识补充](#第二章-数学知识补充)
  - [2.1 集合与映射](#21-集合与映射)
    - [2.1.1 反射](#211-反射)
    - [2.1.2 区间](#212-区间)
    - [2.1.3 对数运算](#213-对数运算)
  - [2.2 解二次方程](#22-解二次方程)
  - [2.3 三角函数学](#23-三角函数学)
    - [2.3.1 角度与弧度](#231-角度与弧度)
    - [2.3.2 有用的三角函数公式](#232-有用的三角函数公式)
  - [2.4 向量](#24-向量)
    - [2.4.4 向量叉积](#244-向量叉积)
    - [2.4.5 规范正交基和坐标系](#245-规范正交基和坐标系)
    - [2.4.6 通过单个向量来生成基坐标](#246-通过单个向量来生成基坐标)
    - [2.4.7 通过两个向量构造基向量](#247-通过两个向量构造基向量)
    - [2.4.8 重新生成基向量](#248-重新生成基向量)
  - [2.5 曲线和曲面](#25-曲线和曲面)
    - [2.5.1 二维隐式曲线](#251-二维隐式曲线)
    - [2.5.2 2D 梯度](#252-2d-梯度)
      - [二维空间直线的隐式表示](#二维空间直线的隐式表示)
      - [隐式二次曲线\_](#隐式二次曲线_)
    - [2.5.3 三维隐式曲面](#253-三维隐式曲面)
    - [2.5.4 隐式曲面的表面法线](#254-隐式曲面的表面法线)
    - [2.5.5 隐式平面](#255-隐式平面)
      - [三维二次曲面](#三维二次曲面)
      - [从隐式曲面相交而成的三维曲线](#从隐式曲面相交而成的三维曲线)
    - [2.5.6 二维参数化曲线](#256-二维参数化曲线)
      - [二维参数直线](#二维参数直线)
      - [二维参数化圆](#二维参数化圆)
    - [2.5.7 三维参数化曲线](#257-三维参数化曲线)
      - [三维参数化直线](#三维参数化直线)
    - [2.5.8 三维参数化曲面](#258-三维参数化曲面)
    - [2.5.9 曲线和曲面的总结](#259-曲线和曲面的总结)
  - [2.6 线性插值](#26-线性插值)
  - [2.7 三角形](#27-三角形)
    - [2.7.1 二维三角形](#271-二维三角形)
    - [2.7.2 三维三角形](#272-三维三角形)
  - [常见问题](#常见问题)
- [第三章 光栅图像](#第三章-光栅图像)
  - [3.1 光栅设备](#31-光栅设备)
    - [3.1.1 显示技术](#311-显示技术)
    - [3.1.2 硬拷贝设备](#312-硬拷贝设备)
    - [3.1.3 输入设备](#313-输入设备)
  - [3.2 图像、像素和几何](#32-图像像素和几何)
    - [3.2.1 像素值](#321-像素值)
    - [3.2.2 显示器的显示强度 和 Gamma 值](#322-显示器的显示强度-和-gamma-值)
  - [3.3 RGB 色彩](#33-rgb-色彩)
  - [3.4 透明度合成](#34-透明度合成)
    - [3.4.1 图像存储](#341-图像存储)
  - [常见问题](#常见问题-1)
- [第四章 光线追踪](#第四章-光线追踪)
  - [4.1 基础光线追踪算法](#41-基础光线追踪算法)
  - [4.2 视角](#42-视角)
  - [4.3 计算观察光线](#43-计算观察光线)
    - [4.3.1 正交视图](#431-正交视图)
    - [4.3.2 透视视图](#432-透视视图)
  - [4.4 光线和物体的相交](#44-光线和物体的相交)
    - [4.4.1 光线和球体的相交](#441-光线和球体的相交)
    - [4.4.2 光线与三角形的相交](#442-光线与三角形的相交)
    - [4.4.3 射线与多边形相交](#443-射线与多边形相交)
    - [4.4.4 与一组对象相交](#444-与一组对象相交)
  - [4.5 着色（Shading）](#45-着色shading)
    - [4.5.1 兰伯特光照模型](#451-兰伯特光照模型)
    - [4.5.2 Blinn-Phong 着色模型](#452-blinn-phong-着色模型)
    - [4.5.3 环境光](#453-环境光)
    - [4.5.4 多点光源](#454-多点光源)
  - [4.6 简单的光线追踪程序](#46-简单的光线追踪程序)
    - [4.6.1 光线追踪程序的面向对象设计](#461-光线追踪程序的面向对象设计)
  - [4.7 阴影](#47-阴影)
  - [4.8 理想的镜面反射](#48-理想的镜面反射)
  - [4.9 历史上的光追](#49-历史上的光追)
  - [常见问题](#常见问题-2)
- [第五章 线性代数](#第五章-线性代数)
  - [5.1 行列式](#51-行列式)
  - [5.2 矩阵](#52-矩阵)
    - [5.2.1 矩阵算术](#521-矩阵算术)
    - [5.2.2 矩阵的运算操作](#522-矩阵的运算操作)
    - [5.2.3 矩阵形式的向量运算](#523-矩阵形式的向量运算)
    - [5.2.4 特殊类型的矩阵](#524-特殊类型的矩阵)
  - [5.3 使用行列式和矩阵进行运算](#53-使用行列式和矩阵进行运算)
    - [5.3.1 计算逆矩阵](#531-计算逆矩阵)
    - [5.3.2 线性方程组](#532-线性方程组)
  - [5.4 特征值与矩阵的对角化](#54-特征值与矩阵的对角化)
    - [5.4.1 奇异值分解](#541-奇异值分解)
  - [常见问题](#常见问题-3)

# 第一章 简介

**术语*计算机图形学*描述的是使用计算机创作或进行修改图像的所有功能。这本书介绍了数学和算法工具，可用来创造各种图像——拟真视觉效果、包含大量信息的插图，亦或是好看的计算机动画。图形可以是二维或者是三维的；图片可以是完全合成的或者是对原有照片修改得出的。此书主要讲的是基础的算法和数学原理，主要涉及对三维的物体和场景进行渲染，得出图像。**
**实际上，研究计算机图形学会不可避免的需要一些关于硬件、文件格式、一两个图形 API 的知识储备。计算机图形学是一个快速发展的领域，所以这些领域的的专业知识一直处于发展之中。因此，本书中，我们将避免使用特定的一种硬件或 API 的造成的局限性。我们建议读者根据现有的软硬件技术来自行补充书中的知识。幸运的是，计算机图形学的发展史已经足够形成一套概念体系，本书中讨论的知识和概念将在大多数环境中都可用。**
**本章定义了一些基本的术语，提供了一些关于计算机图形学的信息源和发展的历史背景。**

## 1.1 图形学的领域

给一个领域强加应用场景是不合适的。但大多数从业者都会同意下面这几个方面是计算机图形学的主要应用领域：

---

- **_建模_** 建模提供了一种数学上的描述方法，让模型的形状和外观可以存储在计算机上。例如：对一个茶杯进行描述，可以描述成三维空间内一系列的点；一些用于连接这些点的插值算法；一个用来描述光线和茶杯交互的反射模型。

- **_渲染_** 渲染是一个来自于图画的术语，它主要负责处理和生成计算机的 3D 模型中的阴影图像。

- **_动画_** 动画是通过图片序列的播放来形成物体运动观感的技术。动画使用建模和渲染技术，然后加上了随着时间进行运动的关键技术。随时间进行运动的技术一般不是由建模和渲染进行处理的。

---

还有其他领域也包含了计算机图形学的相关技术。但计算机图形学是不是其关键技术还有待商榷。这些领域将如下所述：

---

- **_人机交互_** 人机交互主要用于设备和人之间的反馈，如鼠标、平板、应用程序、以及其他的可感知的反馈。一直以来，这个领域和图形密切相关，因为图形研究者在现在广泛应用的 I/O 设备上进行了提前的尝试。

- **_虚拟现实_** 虚拟现实尝试给用户描绘一个 3D 的虚拟世界。这实际上至少需要立体的图形界面和对脑袋运动的感知和反应。要实现真正的虚拟现实，声音和力学反馈也必不可少。由于这块领域需要高级的 3D 图形和高级显示技术，它和图形学关系密切。

- **_可视化_** 可视化尝试通过屏幕显示来给予用户获取复杂信息的能力。可视化问题中常有图形学的身影。

- **_图像处理_** 图像处理可以对 2D 的图片进行修改和操作，这主要是图形学和视觉的领域。

- **_3D 扫描_** 3D 扫描使用距离探测来创建三维模型。这些模型可以用于创建丰富的视觉图像，对这些模型进行处理用得到图形学的算法。

- **_计算摄影_** 计算摄影是计算机图形学、计算机视觉、图像处理的综合应用，创造了一种对事物、场景、环境的新照相技术。

  ***

## 1.2 主要应用场景

**几乎所有地方或多或少都可以用到计算机图形学，但计算机图形学的真正客户还是以下的工业场景：**

---

- **_游戏_** 现在的游戏使用越来越复杂的 3D 模型和渲染算法。

- **_动画片_** 动画片经常通过三维模型直接渲染。许多传统的 2D 动画背景是使用 3D 模型渲染的，这样可以减少创作时间，允许持续的画面移动。

- **_视觉特效_** 视觉特效使用几乎所有的图形学技术。几乎所有的现代电影都使用数字合成技术来将前景和背景进行融合。很多电影同样使用 3D 模型和动画来创建合成的环境、物体、甚至角色，而大部分观众看不出来它是假的。
- **_CAD/CAM_** CAD 指计算机辅助设计，CAM 指计算机辅助制造。这些领域使用计算机技术来设计和创造部件，然后将计算机上的虚拟设计用于指导生产。例如，很多机械部件是先在电脑里设计模型，然后通过数控机床进行自动化生产加工而成。

- **_模拟_** 可以将模拟看成是更精确化的电子游戏。比如，飞行模拟器使用复杂的 3D 图形来模拟真实驾驶飞机的体验。这些模拟器在驾驶等对安全要求很高的场景进行模拟训练，极为有用；也可以用于火灾演习等过于危险不能实现的场景下进行训练。

- **_医学影像_** 医学影像可以建立扫描后的病人影像。例如 CT，是由大型 3D 密度矩阵组成的图像。计算机图形学用于创建阴影图像，来帮助医生从这些数据中提取最突出的特征。

- **_信息可视化_** 信息可视化将原本没有图形信息的数据创建成相应的图像。例如：对 10 组不同的股票进行短时间内的涨跌幅绘制，这种生成图像的方法能帮助人们更好的看出数据的趋势。

---

## 1.3 一些图形 API

使用图形库的关键是会使用图形 API。API 是一个用来完成相应功能的基础函数集，而图形 API 则指的是一些关于图形基本操作的函数集合，如渲染图像和 3D 表面到屏幕上的操作。

所有图形界面的程序都需要用到两个相关的 API：用于视觉效果输出的图形 API 和用于获取用户输入的 UI-API。首先，人们进行了集成的探索，如 Java，图形和 UI 工具是集成在 Java 中是它的一部分，且可移植、被完全支持。第二次探索以 Direct3D 和 OpenGL 为代表，渲染指令和 C++一样，是软件库的一部分，UI 界面则是另一个独立的实体，不同系统可能显示的不一样。在后者的探索中，编写可移植的代码较为困难，尽管编写小程序可以使用可移植库层来封装特定的系统 UI。

不管您选择什么 API，基本的图形调用指令大多都是一样的，这些正是本书讲述的内容。

## 1.4 图形流水线

现在所有的 PC 都有一个强劲的 3D 图形流水线。图形流水线是一个特殊的软硬件子系统，用来绘制 3D 图元。通常来说这些系统对处理有共点的三角形有特殊优化。流水线的基本操作内容是：将 3D 的顶点映射到 2D 平面，然后将三角形加上阴影，这样他们就能看上去和真的一样，并且处在正确的前后关系中。

虽然将三角形绘制出正确的前后关系曾经是计算机图形学的最主要研究方向，现在这个问题一般使用 z-buffer 算法解决。z-buffer 算法通过使用一个特殊的缓冲区来进行暴力计算。

事实证明在图形流水线中进行的几何运算也基本可以在 4D 空间内通过 3D 坐标加上一个相同的坐标来表示，以此帮助透视投影。这些 4D 坐标空间由 4x4 矩阵和 4 维向量组成。因此，图形流水线配备了大量的处理这些矩阵和向量的硬件结构。这套 4D 坐标系统是计算机科学中最漂亮的结构之一，也是学习计算机图形学时需要越过的最大难关。每本图形学书籍的第一个部分都是在讲解这个部分。

图片的生成速度取决于有多少个三角形需要绘制。因为在多数程序中，互动性远比视觉质量重要，所以需要将每个模型的所需三角形尽可能的降到最低。并且，如果这个模型比较远，那么就不需要那么多的三角形来描述它。使用 LOD（多级细节描述）来描述一个模型是很有用的。

## 1.5 数值问题

很多图形程序仅仅只是由处理 3D 数值的代码构成的。数值问题是这些程序中起决定性作用的一环。在以前，由于机器表示数据的方式不同，将该问题解决得既可移植又稳定简直是天方夜谭。更糟糕的是机器处理异常的方式不一样且不相互兼容。幸运的是，几乎所有计算机都遵循 IEEE 浮点数标准，这让程序员得以更方便的设定什么情况该对数值进行怎样的操作。

尽管 IEEE 浮点数在进行数值计算时很有用，我们在图形学研究时遇到的情况只有那么几个。第一、也是最重要的，是 IEEE 浮点数有三种特殊值：

1. 正无穷(∞) 这是有效数值中最大的数值。
2. 负无穷(−∞) 这是有效数值中最小的数值。
3. 非数值(NaN) 这不是数值。通常由于未定义的行为（如 0 除以 0）产生。

IEEE 浮点数的设计者做了一些定义，所以程序员用起来非常方便。其中大部分规定是上面三种数值进行运算的结果规定，某些时候这样做会产生异常，但很多时候这些错误是可以不管的。特殊地，我们制定了一个正实数 a，下面的规则对应了 a 除无穷的情况：

- +a/(+∞) = +0
- −a/(+∞) = −0
- +a/(−∞) = −0
- −a/(−∞) = +0

其他包括无穷值的运算和你想得差不多。还是以 a 为例：

- ∞ + ∞ = +∞
- ∞−∞ = NaN
- ∞×∞ = ∞
- ∞/∞ = NaN
- ∞/a = ∞
- ∞/0 = ∞
- 0/0 = NaN

下列判断也和你想的差不多：

- 所有正数都比+∞ 小
- 所有负数都比-∞ 大
- -∞ 比+∞ 小

包括 NaN 的表达式比较简单：

- 所有带有 NaN 的数学表达式结果都是 NaN
- 所有带有 NaN 的逻辑表达式都是否（False）

可能这里头最有用的就是除 0 如何定义了。同样以 a 举例，下面是相关规定：

- +a/ +0 = +∞
- −a/ +0 = −∞

很多计算在使用 IEEE 规则时会变得非常简单。比如：考虑以下算式：

$$a=\frac{1}{\frac{1}{b}+\frac{1}{c}}$$

这种算式会出现在电阻或透镜的计算中。如果程序因为除零错误崩溃了（以前不用 IEEE 浮点数的计算机就这样）,然后就需要两个 if 语句来检查 b 和 c 是否为无穷小或 0。而使用 IEEE 浮点数后，如果 b 或 c 是 0，那么 a 算出来就是 0。另外一个好用之处在检查 NaN 时不需要麻烦的步骤了：

$$
a=f(x)\\
\rm\textbf{if}\ (a>0)\ \textbf{then}\\
\rm{do\ something}
$$

上面这段程序的 if 条件并没有完全覆盖，因为 a 有可能是无穷或 NaN。但由于我们定义了那些情况，所以省去了额外的判断，这能让程序更健壮、效率更高。

## 1.6 代码效率

世界上没有能让代码更高效的免费午餐。代码效率需要通过谨慎的权衡来实现，而不同架构的权衡方法不一样。虽然但是，在将来一段时间内，尽管这和 20 年前所提倡的恰恰相反，程序员都应该将注意力放在访存效率而不是操作次数上。出现这个变化的原因是内存技术的发展没有跟上处理器的发展速度。自从出现了这个变化后，利用内存的局部性原理来进行内存访问的优化变得更重要了。

一种可行的提高代码速度的方法如下，您可以寻找需要的步骤来自行处理：

1. 尽量保持代码的简洁易懂。尽量在运算结束后就输出数据，而不是存在某个地方。
2. 在优化模式下编译。
3. 使用分析工具来找出代码的瓶颈。
4. 检查用到的数据结构来增加数据的局部性。如果可以的话，让数据大小和目标硬件上的 cache/page 大小一致。
5. 如果分析工具发现了数值计算方面的瓶颈，那么可以检查以下编译出来的汇编语言看那个地方有低效的环节，最后重写代码解决问题。

最重要的步骤是第一步。大多数所谓“优化”会让代码变得更难读，然后速度也变不了多快。而且，相比日后对难懂的代码进行 debug，将这些时间用于优化其他的地方显然更值。除此之外，小心那些已经过时的建议。以前优化的典中典操作是将实数类型改成整数类型，但现在的 CPU 算这俩已经一样快了。但不管怎样，优化后需要进行性能分析来确保你确实是在各种环境下都进行了优化。

## 1.7 设计和编写图形程序

编写图形程序时，有一些技巧可以通用。这一节我们为你提供了一些建议，可以在实现图形程序时对你有帮助。

### 1.7.1 类型设计

> “我认为 KISS（保持简单、保持愚蠢）的原则很有用。弄两个类型出来我觉得和它带来的复杂度相比不划算。 --小明

> 我喜欢将点和向量分开，这让代码更易读，也方便编译器找 bug。 --小红

设计图形程序的一个关键点就是：图形程序要有良好的类或架构设计提供给几何体，如向量和矩阵。这种设计也可以用于 RGB 颜色或图像上。设计的结构应尽可能的简单高效。一个广泛讨论的问题就是位置坐标和位移变换是否应该分由两个不同的类进行管理。如：一个位置变量自乘 1.5 倍是没有意义的，但位移就会有意义。这个话题很难达成共识，所以下面的例子将不会管这么多，我们会将两者视作统一。

所以，一些基本的类可以如下定义：

- **Vector2(二维向量)** 二维向量由 x 和 y 值组成。它通过一个 2 维数组来存储，所以二维向量支持索引。同时，向量的计算也应满足，有点积、叉积，加减法、标量乘除。
- **Vector3(三维向量)** 三维向量与二维向量相似。
- **hvector(齐次向量)** 是一个有四个元素组成的齐次向量。
- **rgb** 一个 RGB 颜色存储三个变量。同时需要包含 RGB 加减法、RGB 乘、RGB 标量乘除法。
- **transform(变换)** 这是一个用于表达变换信息的 4x4 矩阵。需要包含矩阵乘法和一些对位置、方向、表面法向向量进行处理的成员函数。_--见第 6 章_
- **image(图片)** 由 RGB 像素组成的一个二维数组，带有输出操作。

另外，你可能想要添加一些类，他们是**区间**、**正交基**、**坐标系框架**。

> 你可能会想要单独为单位向量开一个类，但我发现这样不值当。 --小明

### 1.7.2 单精度与双精度浮点型

对现代的设计体系来说，将内存使用率降低和保持内存连续性是保证代码高效率的关键，照这样说，应该建议使用单精度浮点型。然而，为了避免数值计算发生的问题，双精度浮点型又更加适合。这两者的权衡由具体程序而定，但在你的定义里指定一个默认情况会更好。

> 我的建议是在集合计算时使用双精度，在颜色计算时使用单精度。针对那些很占内存的东西，如三角网格，我建议使用单精度，但数据通过成员函数时应该转化为双精度。

### 1.7.3 对图形程序进行 Debug

如果你问身边的人，你就会发现越是大佬，他们就越少用传统的 debug 工具。其中一个原因是对于复杂程序来说，再用这种工具会比小程序麻烦的多，然后还有一个原因是最深藏不露的 bug 往往是由于某些概念被错误地实现了，然后你就会在找变量过值上浪费大量时间。我们找到了一些图形编程中挺不错的 debug 技巧。

**_科学的方法_**

在图形编程中，有一个相比与传统调试更有用的方法。只不过，当你是菜鸟时，别人会和你说不要这样做，所以你使用这个方法的时候有点理不直气不壮：我们创建一个图像，然后观察它出了什么问题。然后我们猜是不是由于某某原因造成，测试这个假设。比如，在一个光线追踪项目中，我们可能会发现有很多不知道为啥很暗的色块；这就是我们初学光线追踪经常遇到的问题，叫“shadow acne”。而在这个项目中，传统的调试方法不管用。与之相对，我们需要意识到阴影线射在暗处的表面，然后可能会注意到那些暗处的颜色就是环境色，所以做出判断：是直射光缺失了。而直射光是会在阴影部分被关闭的，所以可以做出这样的假设：那些地方被错误地设置为阴影，所以他们照不到光。为了验证这一假设，我们可以先关闭阴影选项重新进行编译，这样可以判断是否因为错误设置阴影导致的错误；然后继续探究问题。这个方法有时候非常管用的原因是：有时候我们不一定非要找到错值和错误概念，相反，我们可以通过试验来缩小范围。基本上试几次就能够找到原因，这样的 debug 过程是令人快乐的。

**_将图片作为 Debug 的输出_**

很多情况下，得到一个图形程序的调试信息的最简单方式就是输出图像它自身。如果你只需要一部分运算结果，但运算是针对整个图像，那么你可以将这个值直接放到输出图像上，然后跳过后续计算，直接输出原图像的剩余部分。打个比方：如果你怀疑是由于表面法线导致阴影计算出错，你就可以将正确的法向量直接放到图像上去，这样输出的结果就是用你正确的法向量计算出来的结果。或者，如果你怀疑某个特定值有时候超范围，那就可以通过往超范围的像素改成红色的办法找到错误位置。其他的好办法，如将应该不可见的地方涂上显眼的颜色标记、使用物体的 ID 标记图像、或是以不同的颜色区分像素计算的任务轻或重等。

**_使用调试器_**

真香。因为还有一些案例是上面两种方法都没法判别的。主要麻烦的地方是图形程序经常会运行很多次同样的代码（比如每个像素/每个三角形执行一次），这会让一步一步的调试方法变得不切实际，而且很多烦人的 bug 经常在复杂输入的情况下发生。

一个有用的方法是给 bug 设置一个“陷阱”。首先，保证你的程序是准确的-在单线程中运行，从固定种子中取数计算；然后，找到哪个三角形或像素有问题，然后在那个地方加上一些代码，让他在出错时才会执行。如，如果你发现位于（126，247）位置上的像素看起来有问题，那么你可以加这一句代码：

$$
\rm\textbf{if}\ (x=126\ and\ y=247)\ \textbf{then}\
\\
 \rm{print(blarg!)}
$$

如果你在 print 语句上设置一个断点，那么在你关心的那个像素计算时你就会进入调试模式。同时有些调试器可以不需要你添加代码也能达到同样效果，称作“条件断点”。

在程序崩溃的情况下，调试器还是很有用的。你可以回溯程序，使用断言，然后重新编译，来找到程序哪里出了问题。而这些断言可以留在程序里，以防你之后又写了什么一样的 bug 出来。这同样说明了传统调试模式的弊端，因为传统调试模式没法让你往程序里加新的有用的断言。

**_调试中的数据可视化_**

通常你是很难理解你写的程序究竟做了什么，因为它在报错之前已经计算了一大堆中间结果了。这种情况就和测量特别多数据的科学实验比较类似，所以也有一个相同的解决方案：将数据绘制成易懂的图形。比如，在光线追踪中，你可能会将光线束可视化，这样你就能看到有哪些通道构成了这个像素，或者在重新采样图像时，你可以将所有点绘制成一幅图，来显示通过输入进行采样的结果。你花在数据可视化上的时间会带来回报，可以使代码变得易读，优化时变得简单。

> 我喜欢格式化的 debug 输出，因为这样输出利于绘图，能帮助我调试程序。 --小红

## 后记

这里关于软件工程方面的讨论受到了《Effective C++》系列书籍、《Extreme Programming movement》以及《The Practice of Programming》的影响。这里讨论的这些调试经验是建立在跟 Steve Parker 的相关讨论的基础之上的。

每一年都有很多跟图形学相关的会议，这就包括了 ACM SIGGRAPH 以及 SIGGRAPH Asia，Graphics Interface，the Game Developers Conference（GDC），Eurographics，Pacific Graphics，High Performance Graphics，the Eurographics Symposium on Rendering，以及 IEEE VisWeek。你现在就可以通过这些会议的名字在网上找到它们的相关资料。

# 第二章 数学知识补充

**很多图形程序只是单纯的将数学知识翻译成代码。所以数学公式越简单，最终的代码就会越简单。所以本书致力于用正确的数学公式完成图形任务。这一章介绍了从高中数学到大学数学的各种数学工具，且排版偏向于供参考而不是供学习。这属实有点像大杂烩。每个知识点都和数学课程上学的知识点不太一样，因为这里的数学是为图形学服务的，同时为了你能看得懂书中的数学标记，这章也会讲到一些平时数学课被跳过的内容，如三角形的重心坐标。这章不打算提供大量的证明素材，而是通过几何图形来进行直观的展示和讲解。对线性代数的讲解会推迟到第五章处，因为第五章才开始讨论图形的变换。我们鼓励读者先通过本章内容熟悉概念，然后在后面遇到问题的时候可以回过头来参考。章节的课后习题可以帮助你规划复习进度。**

## 2.1 集合与映射

**_映射_** ，又称 **_函数_**，是编程和数学领域的基础知识。就和编程中的函数相似，一个映射接受一种*类型*的参数，并把它对应成一种类型的另一个对象。在编程领域我们一般说“类型”，这话翻译到数学领域就是 **集合** 。如果一个对象是一个集合中的一员，我们用 $\in$ 符号表示。如：
$$a\in S,$$
读作 a 属于 S 这个集合。若有 A、B 两个不同集合，我们可以通过笛卡尔积的方式算出第三个集合，用 $A\times B$ 表示。这个 $A\times B$ 集合由所有（a，b）的组合构成，其中 $a\in A$ ， $b\in B$ 。我们同时可以使用 $A^2$ 来表示 $A\times A$ 。同样的，我们可以将此操作推广到任意维度，如三个集合，四个集合等等。

我们通常使用的集合包括：

- $\mathbb{R}$ - 实数集
- $\mathbb{R}^+$ - 非负实数集
- $\mathbb{R}^2$ - 2D 实平面的有序实数对
- $\mathbb{R}^n$ - n 维笛卡尔空间的点坐标
- $\mathbb{Z}$ - 整数
- $\mathbb{S}^2$ - 单位球面上三维点的集合

注意 $\mathbb{S}^2$ 虽然是由三维空间的点组成的，但是他们是在球面上，可以转化成由两个参数表示，所以可以看作是二维集合。映射的标记使用一个箭头符号和一个冒号，如下：
$$f:\mathbb{R}\to\mathbb{Z},$$
可以读作：函数 f 接受实数输入，并把他映射成整数输出。在这里，箭头左边的集合称作**定义域**，右边的集合称作**值域**。程序员可能对下面这种说法更熟悉：函数 f 接收一个实数参数，返回一个整数。所以，下面两种描述是等价的：

$$\rm {integer}\  f(\rm{real}) \gets \rm{eq.} \to f:\mathbb{R}\to\mathbb{Z}.$$

所以这种冒号箭头的表达方式可以看作一种编程语法。就这么简单。

点 f(a)称为 a 的 **_像_** ，而一个集合 A（也就是定义域的子集）的“像”就是函数值域的一个子集。所有定义域构成的像就是值域。

### 2.1.1 反射

如果我们有一个函数 $f:A\to B$ ,那么就可能存在一个反函数 $f^{-1}:B\to A$ ，仅在所有的 $b\in B$ 都是值域下的一个点，而且此点唯一（也就是每个 a 只对应一个 b），才能进行取反操作。这样的映射称作 **_双射_** 。一个双射中，每一个 a 都对应一个唯一的 b，而且对于每一个 b 都有一个 a 与之对应。不是双射的映射就没有反向映射。

一个双射的例子就是： $f:\mathbb{R}\to\mathbb{R}$ ，其中 $f(x)=x^3$ 。那么它的反函数就是 $f^{-1}(x)=\sqrt[3]{x}$ 。这种表述方式不太好，因为有两个 x，所以将其中一个换成 y，可以得到 $y=f(x)$ 和 $x=f^{-1}(y)$ ,更直观的可以写成 $y=x^3$ 和 $x=\sqrt[3]{x}$ 。而另外一个没有反射的是 $f:\mathbb{R}\to\mathbb{R}$ ，其中 $f(x)=x^2$ 。有两个原因：第一， $x^2={(-x)}^2$ ，第二，没有定义域内的 x 对应值域的负数区域。但我们可以将定义域限制在 $f:\mathbb{R}^+$ ，这样 $\sqrt{x}$ 就是一个正确的反函数。

### 2.1.2 区间

我们大多数情况会希望一个函数的定义域限制在某些值之间，由此引入 **_区间_** 的概念。区间有开闭，开区间不包括边界值，闭区间包括边界值。开闭可以在两头混用。只要我们使用了 $[a,b]$ 这样的区间，我们默认 b 比 a 大。最后，可以使用区间表示笛卡尔积产生的坐标。如 $x$ 是三维单位立方体中的一个点，我们可以写作 $x \in[0,1]^3$ 。

区间在集合运算中显得尤为重要。区间运算有 _交、并、差_ 等。由于此为高中内容，本书不再赘述。

### 2.1.3 对数运算

此为初中内容，本书不再赘述；对数和指数的求导属于高中内容，同样不再赘述。

## 2.2 解二次方程

略

## 2.3 三角函数学

### 2.3.1 角度与弧度

略

### 2.3.2 有用的三角函数公式

倍角公式、和差角公式：

$\tan:$

$$\tan(\alpha\pm\beta)=\cfrac{\tan\alpha\pm\tan\beta}{1\mp\tan\alpha\tan\beta}$$

$$\tan2\alpha=\cfrac{2\tan\alpha}{1-\tan^2\alpha}$$

$\sin:$

$$\sin(\alpha\pm\beta)=\sin\alpha\cos\beta\pm\cos\alpha\sin\beta$$

$$\sin2\alpha=2\sin\alpha\cos\alpha$$

$$\sin2\alpha=\cfrac{2\tan\alpha}{1+\tan^2\alpha}$$

$\cos:$

$$\cos(\alpha\pm\beta)=\cos\alpha\cos\beta\mp\sin\alpha\sin\beta$$

$$\cos2\alpha=\cos^2\alpha-\sin^2\alpha=2\cos^2\alpha-1=1-2\sin^2\alpha$$

三角形面积公式：

$$S=\frac{1}{4}\sqrt{(a+b+c)(-a+b+c)(a-b+c)(a+b-c)}$$

## 2.4 向量

### 2.4.4 向量叉积

向量叉积一般只用于三维向量。我们使用右手定则确定方向，向量的长度和夹角有关：

$$\parallel\textbf{a}\times\textbf{b}\parallel=\parallel\textbf{a}\parallel\parallel\textbf{b}\parallel\sin\phi.$$

### 2.4.5 规范正交基和坐标系

所有图形程序中，坐标系统都是其核心。坐标系统的核心则是正交基。要想作为正交基，两个二维向量必须垂直且都是单位长度。即：

$$\parallel u\parallel=\parallel v \parallel =1,$$

$$u\cdot v=0.$$

在三维空间，需要满足

$$\parallel u\parallel=\parallel v \parallel =\parallel w \parallel =1,$$

$$u\cdot v=v\cdot w=w\cdot u=0.$$

同时，这个坐标系采用右手系：

$$w=u\times v,$$

请注意，笛卡尔直角坐标系只是很多很多坐标系中的一种。它的特殊之处在于图形程序中的低级（默认）表示都是用该坐标系表示的。因此，基向量 x,y,z 和原点 o 都不是显式存储的，是默认就规定的。全局模型通常存储在规范坐标系中，所以我们又将这个坐标系称为**全局坐标系统**。然而，如果我们想要将原点换成 p 点，正交基换成 u,v,w，那么我们就需要显式地存储这些向量和点。这样的坐标系统叫**参考系**。举个例子：在飞行模拟器中，我们可能就会需要既有一个在原点在机头、顺着飞机方向建立基向量的坐标系，同时又需要一个主要坐标系，主要坐标系一般围绕一个不是飞机的特定物体建立，一般称作**本地坐标系**。

在底层，本地坐标系一般依据规范坐标建立，比如，假设 $a$ 有在 u-v-w 坐标系下有坐标 $(x_a,y_a,z_a)$ ，那么它在规范坐标系下的表示就是：

$$\rm{\textbf{u}}=x_a\rm{\textbf{u}}+y_a\rm{\textbf{v}}+z_a\rm{\textbf{w}}$$

### 2.4.6 通过单个向量来生成基坐标

我们建立坐标系的限制条件有时只有一个。比如，限定 z 轴正方向是飞机的飞行方向。所以通过单个向量生成基坐标的步骤如下：

首先取限定向量 w 的单位向量做方向：
$$\rm\textbf{w} = \frac{\textbf{a}}{\parallel\textbf{a}\parallel}.$$

然后找一个任意不共线的向量 $\rm\textbf{w}$，将他们叉乘取出另外一个轴方向。

$$\rm \textbf{u} = \frac{\textbf{t}\times \textbf{w}}{\parallel\textbf{t}\times \textbf{w}\parallel}.$$

如果 t 和 w 共线，那么叉乘向量就是零向量，如果近乎共线，那么坐标轴就会缺少精度。解决这个问题的一种好办法就是，先构造两个相同向量，如 $w=(1/\sqrt{2},-1/\sqrt{2},0)$ ，然后将 0 改成 1，即 $t=(1/\sqrt{2},-1/\sqrt{2},1)$ 。

在表面阴影的生成时，这样的办法比较好用，因为此时需要一个带有表面法向量方向的坐标系，但其他条件并不重要。

### 2.4.7 通过两个向量构造基向量

通过叉乘解决，略。注意两个向量不能平行。

### 2.4.8 重新生成基向量

有些时候你会发现你算出来的规范正交基是有问题的：由于计算机会进行舍入操作或者存储时精度过低，这造成了所谓的规范正交基既不规范（可能和 1 相差一点距离），也不正交（可能和 90° 相差一点角度）。

所以前一节的知识可以派上用场了：我们只需要将已存在的 $w$ 和 $v$ 这两个向量重新叉乘生成新的规范正交基即可。

这种方法非常实用，但是它的效果并不是最好的，尽管它能提供准确的正交向量，但它对三个基向量的侧重程度不同。它在 uvw 中对 w 的优先级最高，其次是 v，然后是 u。它在创建基向量是有明显的倾向性，同时也不能保证计算出来的正交基就是最标准的规范正交基。当然这有解决办法。在 5.4.1 节中，我们会讲到 SVD 方法（**奇异值分解**），它能找到和原来的基向量最接近的规范正交基。

## 2.5 曲线和曲面

**_曲线和曲面，尤其是对表面的几何分析，是计算机图形学的中心问题。现在我们来康康 2D 和 3D 中的曲线和曲面_**

### 2.5.1 二维隐式曲线

显而易见的，**_曲线_** 是一系列能够一笔画成的点。通常我们用 **_隐函数_** 来表示曲线。二维的隐函数是这样的：

$$f(x,y) = 0.$$

函数 $f(x,y)=0$ 返回一个实数。使得该函数值为 0 的所有点 $(x,y)$ 组成一条曲线。由于 f 对所有(x,y)都有值，所以可以通过曲线形成一一块区域。下面的式子：
$$f(x,y) = (x-x_c)^2+(y-y_c)^2-r^2=0$$
写成向量的形式则是：
$$(\rm\textbf{p}-\textbf{c})\cdot(\textbf{p}-\textbf{c}-r^2=0)$$
其中 $\rm\textbf{p}=(x,y)$ ,c 是某点 $(x_c,y_c)$ 。

更直观的，那俩平方其实就是距离：
$$\parallel {\rm\textbf{p}-\textbf{c}}\parallel^2-r^2 = 0$$

我们更建议你使用向量等式，因为它更符合几何定义，也更直观；另外你还可以在代码中引入向量，让代码更易读，同时产生更少的错误。学会使用向量，刚开始可能有点难，但之后会让你事半功倍。

### 2.5.2 2D 梯度

如果我们将函数 $f(x,y)$ 视作高度函数，即 $height = f(x,y)$ , 那么它的 **_梯度_** 就是只想最大向上斜率的一个向量（换句话说，就是朝着上坡方向）。梯度向量由以下公式给出：

$$\nabla f(x,y) = (\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}).$$

> 我们使用 $\nabla$ 表示梯度。

在隐式曲面的某一点上的梯度向量是垂直于 **切向量**的一个向量。这个垂直的向量我们一般叫做曲面的 **法向量**。而且，当梯度指向更高的地方，说明了在那块地方的函数值 $f(x,y)>0$ 。（存疑）

在 f 作为高度函数的内容中，偏导和梯度的几何意义更直观的可以看出。假设在 $(a,b)$ 点附近有一个平面 f(x,y)，（**_见图 2.24_**），这个平面有很特定的上坡下坡的方向。而从与该方向垂直的方向上看这个平面，平面是一条直线。平面 $f(x,y)$ 和线 $f(x,y)=0$ 之间的交点都将位于水平方向。那么为啥偏导数与此有关呢？让我们看看几何图像。我们学过，一维函数 $y=g(x)$ 的导数是：

$$\frac{dy}{dx} = \lim_{\Delta x \to 0}\frac{\Delta y}{\Delta x} = \lim_{\Delta x \to 0}\frac{g(x+\Delta x)-g(x)}{\Delta x}$$

这同时也是该曲线在 x 处的斜率。

偏导数是一维导数的推广。对于一个二维函数 $f(x,y)$ ，我们不能单纯的用上面的极限来定义二元导数，因为当 x 不变时，函数值也会发生变化。但是，我们可以引申除偏导这一概念，让 y 视为常数，就有下面的式子：

$$\frac{\partial f}{\partial x} = \lim_{\Delta x \to 0}\frac{f(x+\Delta x,y)-f(x,y)}{\Delta x}$$

为什么梯度向量的两个成员分别是 x 和 y 的偏导呢？同样，让我们看更直观的图像：在图 2.27 中，我们看到向量 $\rm a$ 的路径上 f 的值一直不变。由于 $\Delta x$ 意味着是在一个足够小的范围，所以该区域可以视为平面。在图上能看到，向量 ${\rm a}=(\Delta x,\Delta y).$ 同时由于上坡方向和向量 $\rm a$ 垂直，所以点积为 0：

$$(\nabla f)\cdot a \equiv (x_\nabla,y_\nabla)\cdot(x_a,y_a) = x_\nabla\Delta x+y_\nabla\Delta y = 0.$$

同时，上一段话提到沿着 $\rm a$ 方向上的变化率是 0，有：

$$\Delta f = \frac{\partial f}{\partial x}\Delta x+\frac{\partial f}{\partial y}\Delta y\equiv \frac{\partial f}{\partial x}x_a+\frac{\partial f}{\partial y} y_a = 0.$$

通过垂直向量点积为 0 的结论，结合上面的两个等式，我们有：

$$(x_a,y_a) = k(\frac{\partial f}{\partial y},-\frac{\partial f}{\partial x})$$
,同时有：
$$(x_\nabla,y_\nabla) = k'(\frac{\partial f}{\partial y},-\frac{\partial f}{\partial x})$$
,其中$k$和$k'$是非零常数。由于“上坡”意味着 $f$ 增大，所以我们可以让 $k'=1$ .

举个梯度的例子，比如圆的方程 $x^2+y^2-1=0$ ,容易算出梯度向量是 $(2x,2y)$ . 这说明了对于函数 $f(x,y) =x^2+y^2-1$ ,在该圆外面的区域是正区域。需要注意的是，带乘二系数的圆方程： $2x^2+2y^2-2=0$ 和先前的圆是同一个，但是梯度为 $(4x,4y)$ 。不同的方程样式可能会导致梯度向量的长度发生变化。而对于系数是负数的圆，在三维空间看 $f(x,y)$ ，圆内的形状是凸起的，所以可以统一地讲， **梯度的长度反应了坡度变化的快慢，梯度的方向指向上坡方向** 。

#### 二维空间直线的隐式表示

直线的表示方式是：
$$y = mx + b,$$
即
$$y − mx − b = 0.$$

其中 m 是斜率，b 是直线穿过 y 轴是的 y 轴坐标，称为 **_y 轴截距_** 。我们可以将他吧平面分成的两个部分称为上部和下部。
我们引入了 **一般式** ，为了防止像 x=0 这样的方程用截距式无法表示：
$$Ax+By+C=0$$
其中 A、B、C 均为实数。

如果说，我们知道直线的两个点 $(x_0,.y_0)$ , $(x_1,y_1)$ ,我们可以列出式子：
$$Ax_0+By_0+C=0$$
$$Ax_1+By_1+C=0$$
但这样会产生三个未知数和两个方程。我们可以将方程同除 C，得到：
$$Ax+By+1=0$$
同样这也有问题，而且是和截距式类似的问题，那就是没法表示 $x=y$ 这样的直线。

当我们遇到麻烦的代数问题时，我们可以尝试通过数形结合来直观的解决问题。我们在 2.5.2 节讲过，对于直线 $Ax+By+C=0$ ，它的梯度向量是 $(A,B)$ . 同时这个向量和直线垂直，指向直线上侧，也就是 $Ax+By+C>0$ 一侧。在直线上取两个点构成一个向量，显然这个向量的方向就是直线的方向，同时垂直与梯度向量。

我们将这两点设为 $(x_0,y_0)$， $(x_1,y_1)$ ，那么这条直线方程又可以写成：
$$(y_0-y_1)x+(x_1-x_0)y+C=0$$

那么我们只要把 C 解出来就好了。其实，只需要代入这条直线上的一个点即可，代入 $(x_0,y_0)$ ，可以得到：
$$(y_0-y_1)x+(x_1-x_0)y+x_0y_1-x_1y_0=0$$
这个方程就不会有之前那样的局限性了，而且可以很容易的转化成截距式：

$$y-\frac{y_1-y_0}{x_1-=x_0}x+\frac{x_1y_0-x_0y_1}{x_1-x_0}$$

使用一般式，我们也可以求点到直线的距离。若有一个点 $(a,b)$，直线 $$Ax+By+C=0$$,

$$距离=\frac{f(a,b)}{\sqrt{A^2+B^2}}$$

距离恒正。但计算结果可能为负，此时需要额外进行绝对值处理，或采用以下推导出来的公式：

$$f(x,y)=\frac{y_0-y_1}{\sqrt{(x_1-x_0)^2+(y_0-y_1)^2}}x+\frac{x_1-x_0}{\sqrt{(x_1-x_0)^2+(y_0-y_1)^2}}y+\frac{x_0y_1+x_1y_0}{\sqrt{(x_1-x_0)^2+(y_0-y_1)^2}}$$

> 该公式通过确保 $(A,B)$ 是单位向量来简化计算。
> 直接计算 $f(x,y)$ 的值就是点和线的恒正距离。

隐式直线对三角形光栅化会很有帮助(8.1.2 节)。在第 14 章，我们会讨论二维直线的其他表示形式。

#### 隐式二次曲线\_

上面介绍了线性函数 $f(x,y)$ 可以构造一个隐式直线 $f(x,y)=0$ 。但如果 $f$ 是一个二次函数，标准型如下：

$$Ax^2+Bxy+Cy^2+Dx+Ey+F=0$$

那么它生成的曲线叫二次曲线。二维的二次曲线包括椭圆和双曲线，在特殊情况下，会变成抛物线、圆、直线。二次曲线的例子有：圆心为 $(x_c,y_c)$ 的圆：
$$(x − x_c)^2 + (y − y_c)^2 − r^2 = 0,$$

轴对齐的椭圆：
$$\frac{(x-x_c)^2}{a^2}+\frac{(y-y_c)^2}{b^2}$$

> 轴对齐指椭圆的长轴短轴分别和坐标轴 x、y 对齐。

椭圆圆心为 $(x_c,y_c)$ ，长轴短轴分别是 a 和 b。

### 2.5.3 三维隐式曲面

正如隐式方程在二维空间中可以定义一条曲线，三维空间中它能定义一个曲面。就像在二维空间那样，隐式方程描述了在这个表面上的所有点的集合。我们也可以将该函数写成向量表示法： $\rm\textbf{p}=(x,y,z)$, $f(\rm\textbf{p})=0$ .

### 2.5.4 隐式曲面的表面法线

表面法线（用于光线计算和其他）是一个垂直于表面的向量。由于曲面是弯曲的，每个点都有可能会有不同的法向量。和二维一样，某点$P$的表面法线 **n** 通过梯度来表示：

$${\rm \textbf{n}} = \nabla f({\rm \textbf{p}}) = (\frac{\partial f({\rm \textbf{p}})}{\partial x},\frac{\partial f({\rm \textbf{p}})}{\partial y},\frac{\partial f({\rm \textbf{p}})}{\partial z})$$

这样表示的依据和二维例子一样。梯度指明了 $f$ 增长最快的方向，所以是垂直于平面上所有切线的，其中 f 保持不变。梯度向量始终指向 $f(p)>0$ 的方向。在几何上则是朝着曲面内/外的描述方法。如果 $f$ 算出来的梯度向内，而我们需要向外的梯度，那么曲面 $f(\rm \textbf{p})$ 和 $-f(\rm \textbf{p})$ 会有方向相反、大小相同的梯度。

### 2.5.5 隐式平面

举个例子，假设有一个无限大的平面，点 $\rm \textbf{a}$ 是平面上的一点，平面的法向量是 $\rm \textbf{n}$ ,那么这个平面就可以通过下式表示：

$$(\rm \textbf{p}- \rm \textbf{a})\ \cdot \rm \textbf{n}= 0$$

其中**a**和**n**已知，点**p**是平面上的任意点。在几何上，该式子的意思是：平面内任取两个点，该向量都和法向量垂直。推理可得，如果点**p**不在平面里，组成的向量也就不会和法向量垂直。

有时候我们会需要通过三个点 A、B、C 确定一个平面，然后寻找它的法向量。这很简单，只需要利用向量的叉乘即可：
$$\rm \textbf{n}=(\rm \textbf{b}- \rm \textbf{a})\times (\rm \textbf{c}- \rm \textbf{a})$$

所以隐式平面的方程也可以得出来：
$$(\rm \textbf{p}-\rm \textbf{a})\cdot(\rm \textbf{b}- \rm \textbf{a})\times (\rm \textbf{c}- \rm \textbf{a}) = 0$$

同样我们来解释一下上面式子的意思。根据**向量混合积**的定义，这个式子的意思是：由 $p-a$, $b-a$, $c-a$ 这三个向量定义的平行六面体的体积为 0。也就是说，他们共面。

> 可以使用行列式来表示上面的等式。行列式给出了完整的笛卡尔表示，5.3 节将对此进行详细讨论。

上面的两种表示方法（向量和行列式等式）都可以实现高效的代码。而如果你将 x、y、z 三个分量拆开，可能就会产生打字错误，导致臃肿的代码。

#### 三维二次曲面

就像二维里面定义的含有两个变量的二次多项式是表示一条曲线一样，在三维空间中，含有三个变量的多项式定义了空间内的**曲面**。比如，一个球体可以写成：

$$f(\rm \textbf{p})=(\rm \textbf{p}-\rm \textbf{c})^2-r^2= 0$$

同时，轴对齐的椭球可以写成：
$$f(\rm \textbf{p}) = \frac{(x-x_c)^2}{a^2}+\frac{(y-y_c)^2}{b^2}+\frac{(z-z_c)^2}{c^2}-1=0.$$

#### 从隐式曲面相交而成的三维曲线

我们可能会希望三维曲线是 $f(\rm \textbf{p}) =0$ 的形式。但是，在三维空间中，这些三维曲线实际上是三维曲面的退化，是在实际当中很少出现的。我们可以通过两个隐式方程的交点来给构造三维曲线：

$$f(\rm \textbf{p}) = 0$$

$$g(\rm \textbf{p}) = 0$$

比如，可以从两个隐式平面的交点形成三维曲线。一般来说，使用参数化的曲线更方便，后面章节会着重讨论这个问题。

### 2.5.6 二维参数化曲线

> 译者注：如果你上过高数/考研数学，就可以快速理解此章。

**_参数化曲线_** 指的是由单个参数 $t$ 控制的，由 $t$ 表示 $x$ 和 $y$ 使之平滑移动形成曲线的一种表示方式。如下：

$$
\left[\begin{matrix}
  x \\
  y
\end{matrix} \right] = \left[\begin{matrix}
  g(t) \\
  h(t)
\end{matrix} \right]
$$

这里 $(x,y)$ 是曲线上的一个点， $t$ 是影响曲线的参数。对于 $t$ ，函数 $g$ 和 $h$ 会生成一些点，使 $t$ 的变化对 $x$ 和 $y$ 产生连续变化，所以 t 不断变化时，将会绘制出一条曲线。我们通常可以将这样的参数曲线写成向量形式：

$\rm \textbf{p} = f(t)$,
其中 $f$ 时向量作为变量的函数，映射范围是 $f:\mathbb{R}\to\mathbb{R}$ 。这样的向量函数可以生成非常简洁清爽的代码，所以我们得尽可能用它。

我们可以将曲线的位置看作是一个时间的函数，这条曲线可以任意移动，可以循环、交叉，也可以吧这条曲线看成是在每一个点都有一个自己的速度，如函数 ${\rm \textbf{p}}(t)$ ，在 $t=-2$ 的时候速度较慢，在 $t=2$ 和 $t=3$ 之间时速度快。我们研究这类参数曲线问题时，为了方便，即使描述的不是动点，我们也可以用动点来描述它。

#### 二维参数直线

通过点 $p_0=(x_0,y_0)$ 和 $p_1=(x_1,y_1)$ 的点可以写成：

$$
\left[\begin{matrix}
  x \\
  y
\end{matrix} \right] = \left[\begin{matrix}
  x_0+t(x_1-x_0)\\
   y_0+t(y_1-y_0)
\end{matrix} \right]
$$

由于上式的 x 和 y 有相同的结构，我们可以简化为向量形式：

$${\rm \textbf{p}}(t) = {\rm \textbf{p}}_0+t({\rm \textbf{p}_1-{\rm \textbf{p}}_0}).$$

你可以将其几何形式理解为：从点 ${\rm \textbf{p}}_0$ 到 ${\rm \textbf{p}}_1$ 走了一段距离，距离由参数 $t$ 决定。写成这种形式的一个好处就是 ${\rm \textbf{p}}(0)={\rm \textbf{p}}_0$ ， ${\rm \textbf{p}}(1) = {\rm \textbf{p}}_1$ ，当这个点随着 $t$的变化而变化的时候， $t$的值就是两点之间距离的比值。 $t<0$ 说明了点在 ${\rm \textbf{p}}_0$ 的远侧，而 $t>0$ 说明点在 ${\rm \textbf{p}}_1$ 的远侧。

参数化的直线也可以写成如下的向量形式：

$${\rm \textbf{p}}(t) = {\rm \textbf{o}}+t({\rm \textbf{d}}).$$

当向量 ${\rm \textbf{d}}$ 是单位向量时，直线就是 **弧长参数化** 的，这表明 $t$就可以用来描述长度。任何参数曲线都可以被弧长参数化，用起来非常方便，但不是所有曲线都能成功解析转化。

#### 二维参数化圆

以 $(x_c,y_c)$ 为圆心， $r$ 为半径的圆的参数表示可以写成：

$$
\left[\begin{matrix}
  x \\
  y
\end{matrix} \right] = \left[\begin{matrix}
  x_c+r\cos\phi \\
  y_c+r\sin\phi
\end{matrix} \right]
$$

为了保证曲线上的每一个点都有一个唯一确定的参数 $\phi$ ，我们可以将 $phi$ 的定义域限制为 $\phi \in [0,2\pi)$ 或者是 $\phi \in (-\pi,\pi]$ ，或其他的范围是 $2\pi$ 的半开区间。

相似的，轴对齐的椭圆的参数化形式可以表示为：

$$
\left[\begin{matrix}
  x \\
  y
\end{matrix} \right] = \left[\begin{matrix}
  x_c+a\cos\phi \\
  y_c+b
  \sin\phi
\end{matrix} \right]
$$

### 2.5.7 三维参数化曲线

三维参数化曲线就和二维的参数化曲线很像：

$$x=f(t)$$

$$y=g(t)$$

$$z=h(t)$$

比如，绕着$z$轴的螺旋线（弹簧线）可以写成：

$$x=\cos t$$

$$y=\sin t$$

$$z= t $$

类比二维曲线，如果我们想要控制曲线的开始和结束点，函数 $f$, $g$, $h$都应定义域为 $D \in \mathbb{R}$ 。所以可以写出它的向量形式：

$$
\left[\begin{matrix}
  x \\
  y \\
  z
\end{matrix} \right] = {\rm \textbf{p}}(t)
$$

这章我们只详细讨论**三维参数直线**。更为广泛的**三维参数曲线**将在 15 章讨论。

#### 三维参数化直线

三维参数化直线可以直接看作二维参数化直线补充一个维度，如：

$$x=2+ 7t$$

$$y=1+2t$$

$$z=3-5t $$

这看起来又臭又长，而且不能转化成代码，我们换向量方法描述：

$${\rm \textbf{p}} = {\rm \textbf{o}}+t{\rm \textbf{d}}$$

我们取 ${\rm \textbf{o}}=(2,1,3)$ , ${\rm \textbf{d}}=(7,2,-5)$ 作为例子。

其实这和二维的情况非常相似，几何上，我前面只需要想象这条线穿过 ${\rm \textbf{o}}$ 并和 ${\rm \textbf{d}}$ 平行。对于任何 $t$ ，都会在线上得到一个点 ${\rm \textbf{p}}(t)$ 。比如当 $t=2$ 时，运算结果是 $(16,5,-7)$ 。主要思想是和二维一致的。

和二维一样，一条线段则可以表示为 $t \in [t_a,t_b]$ 的这样一个区间，这样，两点之间的线段就可以通过 ${\rm \textbf{p}}(t)={\rm \textbf{a}}+t({\rm \textbf{b}}-{\rm \textbf{a}})$来表示，此时 $t \in [0,1]$ ，类比可得， ${\rm \textbf{p}}(0) = {\rm \textbf{a}}$ , ${\rm \textbf{p}}(1) = {\rm \textbf{b}}$ 。

**射线**是具有半开区间的三维参数化直线。区间一般为： $[0,+ \infty)$ 。从此处开始，我们会将所有的直线、射线、线段统称为“光线”。虽然不太严谨，但考虑到本书的用途，以及为了让表述更简单，将做这样的规定。

### 2.5.8 三维参数化曲面

参数化的方法让我们很好的定义了三维空间的曲线，同样这种方法也可用于直线。但曲面的二位区域需要两个参数来描述，所以曲面写成了这样的形式：

$$x=f(u,v),$$
$$y=g(u,v),$$
$$z=h(u,v),$$

向量形式为：

$$
\left[\begin{matrix}
  x \\
  y\\
  z
\end{matrix} \right] = {\rm \textbf{p}}(u,v)
$$

**_举例_**：详见高数书本 / 考研数学 **参数坐标系** 中的 **球坐标系**。形式为：
$$x=r\cos\phi\sin\theta,$$

$$y=rsin\phi\sin\theta,$$

$$z=rcos\theta,$$

但按照我们的想法来说，我们希望它能通过向量表示。实际上这种表示方法不行。
对于给定的 $x$ , $y$ , $z$ ，我们希望能算出 $\phi$ 和 $\theta$ ，实际上通过特定函数可以算出来：

$$\theta = acos(\frac{z}{\sqrt{x^2+y^2+z^2}})$$

$$\phi = atan2(y,x)$$

> 译者注：由于 arctan 函数的特性，只会返回一个 $[-\frac{\pi}{2},\frac{\pi}{2}]$ 的值，也就是只存在一四象限的返回值，我们通常使用 atan2 函数。

> atan2 函数接收两个值 double (x,y)，用来描述已知点的坐标，角度返回值是该点射线与 x 的夹角。如（1，1）的返回值是 $\frac{\pi}{4}$，而（-1，-1）的返回值则是 $-\frac{3\pi}{4}$ .

对于隐式曲面，函数 $f$的导数给出了曲面的法线。而通过对曲面的参数化，对 $\rm \textbf{p}$ 的导数提供了该表面的几何信息。

考虑函数 ${\rm \textbf{q}}(t)={\rm \textbf{p}}(t,v_0)$ ，该函数定义了一条$u$为常数$v_0$的参数曲线。这样的线叫曲面上的 **_等参数曲线_**，简称 **_等参线_**。 $\rm \textbf{q}$ 的导数给出了曲线的切向量，由于曲线是在曲面上的，所以该切向量也是在曲面上的。由于上面我们将参数 $u$ 看成了一个常数，所以对 $\rm \textbf{p}$ 求导实际上就是对 $u$ 取偏导。将其记为 $\rm \textbf{p}_u$ 。类似的，另外一个偏导 $\rm \textbf{p}_v$ 给出了等参曲线在 $u$ 为常数的时候的切线，也就是曲面的第二条切向量。

由于我们已经得到了两条不同的切向量，可以通过向量叉乘来得出曲面的法线。法线指向的方向可以由右手法则确定。公式为：
$$\rm \textbf{n} = \rm \textbf{p}_u \times \rm \textbf{p}_v$$

我们使用指向曲面外部的法向量。

### 2.5.9 曲线和曲面的总结

隐式的**二维曲线** / **三维曲面**由 两个/三个 标量值函数确定： $f:\mathbb{R}^2\to\mathbb{R}$ 或 $f:\mathbb{R}^3\to\mathbb{R}$ ，而曲线/面由函数值为 0 的所有点组成：
$$S = \{ {\rm \textbf{p}}|f(\rm \textbf{p}) = 0 \}.$$

对于隐式曲线和隐式曲面，法向量由 $f$ 的导数（梯度）给出。然后，曲线的切向量 / 曲面的多个切向量 可以通过构造基向量从法向量导出。

对于参数化的曲线和曲面， $\rm \textbf{p}$ 的导数可以给出 曲线的切向量 / 曲面的多个切向量。，通过他们来构造基向量，可以导出法向量。

## 2.6 线性插值

图形运算中最常用的数学运算可能就是 **_线性插值_**。其实，我们在之前已经看到了一个插值的例子，就是在**二维和三维中构造线段。** 两个点 $\rm \textbf{a}$ 、 $\rm \textbf{b}$ 与参数 $t$ 关联，产生线 ${\rm \textbf{p}} = {(1-t)\rm \textbf{a}}+t({\rm \textbf{b}})$ 。这叫 **插值** 的原因在于 $\rm \textbf{p}$ 在 $t=0$ 和 $t=1$ 的时候刚好通过 $\rm \textbf{a}$ 和 $\rm \textbf{b}$ 两个点。这是 **线性** 的原因在于加权项 $t$ 和 $(1-t)$ 是关于 $t$ 的线性多项式。

另外一个常用的线性插值是：在一组 $x$ 轴的值 $x_1,x_2,...,x_n$ 中，对每个 $x_i$ 都有相应的 $y_i$ 与之对应，我们想要创造一个函数 $f(x)$，能让他对这些位置进行拟合，这样 $f$ 能经过每一个坐标 $(x_i,y_i)$ 。而对于**线性插值**，我们很自然的就可以用参数方程来解决。参数 $t$ 用于表示 $x_i$ 和 $x_{i+1}$ 之间的比例：

$$f(x) = y_i+ \frac{x-x_1}{x_{i+1}-x_i}(y_{i+1}-y_i)$$

由于加权函数是关于 $x$ 的线性函数，所以叫做线性插值。

上面两个例子都是线性插值的一般形式。

## 2.7 三角形

**二维和三维空间内的三角形都是很多图形程序中的基本初始模型。一般来说，颜色之类的信息会标记在三角形的顶点上，然后这些信息在整个三角形上进行插值。让这样的插值变得清晰易懂的坐标系叫做*重心坐标*。我们会从头开始开发这些工具。同时，我们会在这节讨论二维三角形和三维三角形，在学习渲染屏幕上的二维图像之前，必须先学习这些。**

### 2.7.1 二维三角形

如果我们有一个由二维坐标 $\rm \textbf{a}$ 、 $\rm \textbf{b}$ 、 $\rm \textbf{c}$ 定义的二维三角形，我们首先可以通过**行列式**确定它的面积：

$$
S_{\Delta} = \frac{1}{2}
\left|\begin{matrix}
  x_b-x_a  & x_c-x_a\\
  y_b-y_a & y_c-y_a
\end{matrix} \right|  = \frac{1}{2}(x_ay_b+ x_by_c + x_cy_a − x_ay_c − x_by_a − x_cy_b)
$$

该公式会在 5.3 节推导。如果点 $\rm \textbf{a}$ 、 $\rm \textbf{b}$ 、 $\rm \textbf{c}$ 由顺时针表示，那么面积就是正的，否则求出来的面积会有一个负号。

在图形学中，我们通常会希望一个属性（如颜色），从三角形的每个顶点平滑的进行插值过渡。有好多种方法可以做到，但最简单的是使用**重心坐标**。我们可以将重心坐标简单的看作一个非正交坐标系（引 2.4.2 节）。这样的坐标如图 2.36 所示。其中坐标系原点为 $\rm \textbf{a}$ , 基向量是 $\rm \textbf{b}-\rm \textbf{a}$ 、 $\rm \textbf{c}-\rm \textbf{a}$ 。
这样，所有的点 $\rm \textbf{p}$ 都可以写成:
$$\rm \textbf{p}=\rm \textbf{a}+\beta(\rm \textbf{b}-\rm \textbf{a})+\gamma(\rm \textbf{c}-\rm \textbf{a})$$
然后整理此式，得到：
$$\rm \textbf{p} = (1-\beta-\gamma)\rm \textbf{a}+\beta\rm \textbf{b}+\gamma\rm \textbf{c}$$
然后我们通常为了简洁，新定义一个 $\alpha$：
$$\alpha \equiv 1-\beta-\gamma$$
这样就会有下面简洁的式子：
$$\rm \textbf{p}(\alpha,\beta,\gamma) = \alpha\rm \textbf{a}+\beta\rm \textbf{b}+\gamma \rm \textbf{c},$$

$$\alpha+\beta+\gamma = 1.$$

我们刚开始看到重心坐标的时候，感觉重心坐标像是一个抽象、不太直观的构造，但后面我们就会发现，重心坐标很强大、很方便。这就像在一个有两组平行街道（但相互不成直角）的城市里，你会发现街道地址很有用。自然中的系统本身就是一种重心坐标，你会很快习惯它。重心坐标可以定义平面上的所有点。重心坐标一个很好用的特性就是它可以方便的判断一个点 $\rm \textbf{p}$ 是否在点 $\rm \textbf{a}$ 、 $\rm \textbf{b}$ 、 $\rm \textbf{c}$ 组成的三角形内部。若在内部，则一定有下面的式子，反之亦然：

$$0<\alpha<1$$
$$0<\beta<1$$
$$0<\gamma<1$$

同样的，如果 $\alpha$ 、 $\beta$ 、 $\gamma$ 中有两个 0，另外一个是 1，那么说明你在顶点上；如果有一个 0，两个在 $(0,1)$ 内，说明这个点在三角形的边上。另外一个很好的特性是重心坐标使用了上面那个加权方程，它能平滑的混合三个顶点的坐标，而这样的三个系数 $\alpha$ 、 $\beta$ 、 $\gamma$ 同样可以用来对颜色等属性进行平滑插值。我们在下一章就能见到了。

给定一个点 $\rm \textbf{p}$ ，我们如何计算它的重心坐标呢？一种方法是像上面所说的那样，写出 $\rm \textbf{p}$ 由 $\rm \textbf{a}$ 、 $\rm \textbf{b}$ 、 $\rm \textbf{c}$ 表示的式子，然后替换得到 $\alpha$ 、$\beta$ 、 $\gamma$ 。我们可以通过线性代数的方式写出公式：

$$
\left[\begin{matrix}
  x_b-x_a & x_c-x_a \\
  y_b-y_a & y_c-y_a
\end{matrix} \right]\left[\begin{matrix}
  \beta \\
  \gamma
\end{matrix} \right] = \left[\begin{matrix}
  x_p-x_a \\
  y_p-y_a
\end{matrix} \right]
$$

虽然可以很简单的计算出代数结果，但是计算一个几何解是大有裨益的：

重心坐标的一个几何特性是，它们代表了直线到三角形一侧的带符号的缩放间隔。如图 2.37 中的 $\beta$ 。我们回想一下 2.5.2 节（二维梯度）中的距离计算，可知将 $x,y$ 代入方程 $f(x,y)$ 可以获得点 $(x,y)$ 和直线 $f(x,y) = 0$ 之间的带符号缩放距离。同时，等式两边同乘一个非零 $k$ ，直线还是那条直线，但是改变了 k，距离的大小和正负也随之进行倍数变化。下面举个例子：$kf(x,y)=\beta$。如上图，由于只有 $\rm \textbf{b}$ 不在三角形上，所以 $\beta=1$ ,抑或是我们只知道直线穿过了 $\rm \textbf{a}$ 点和 $\rm \textbf{c}$ 点，那么可以通过计算得出 $\beta$ :

$$\beta = \frac{f_{ac}(x,y)}{f_{ac}(x_b,y_b)}$$

同样的，我们可以用这个方法计算出 $\alpha$ 和 $\gamma$ 。为了方便，由于三者加起来是 1，我们只需要计算出两个参数即可。

为了通过 $\rm \textbf{p}_0$ 和 $\rm \textbf{p}_1$ 找到这条线的*理想*形式，我们用 2.5.2 节（二维梯度）学习的知识来找出一些有帮助的隐式直线：**通过两点写出一般式**：

$$f_{ab} \equiv (y_a-y_b)x+(x_b-x_a)y+x_ay_b-x_by_a=0$$

由于 $f_{ab}(x_c,y_c)$ 是不为 1 的，所以它还能继续优化。两边同除，我们得到：
$$\gamma = \frac{(y_a-y_b)x+(x_b-x_a)y+x_ay_b-x_by_a}{(y_a-y_b)x_c+(x_b-x_a)y_c+x_ay_b-x_by_a}$$

除法的存在会让人担心除零错，但是由于面积不为 0 或者不接近于 0 的三角形，我们不需要担心。同理可得 $\beta$ 的值，然后相减即可：

$$\beta = \frac{(y_a-y_b)x+(x_b-x_a)y+x_ay_b-x_by_a}{(y_a-y_b)x_b+(x_b-x_a)y_b+x_ay_b-x_by_a}$$

$$\alpha = 1-\beta\gamma$$

其实还有另外一种方法计算重心坐标：如图 2.38 所示，我们可以计算小三角形 $A_1$、 $A_2$ 、$A_3$ 的面积，然后重心坐标遵循下面的规则，规范化重心坐标等于面积比值：

$$\alpha = \frac{A_a}{A}$$

$$\beta = \frac{A_b}{A}$$

$$\gamma = \frac{A_c}{A}$$

请注意，**如果点在外面，计算出的三角形面积应该是负数**。只要计算出正确的带符号面积，然后进行比值，就是正确的重心坐标结果。

### 2.7.2 三维三角形

_重心坐标让我们从二维到三维的转换变的如此自然。_

假设三维空间内的三角形由 $\rm \textbf{a}$ 、 $\rm \textbf{b}$ 、 $\rm \textbf{c}$ 三个点组成，我们还是可以使用之前的表达式：

$$\rm \textbf{p} = (1-\beta-\gamma)\rm \textbf{a}+\beta\rm \textbf{b}+\gamma\rm \textbf{c}$$

然后，当我们改变 $\beta$ 和 $\gamma$ 的时候，三角形会扫出一片平面。

三角形的法向量很简单，只需随便找到两个边向量进行叉乘即可：

$$\rm \textbf{n} = (\rm \textbf{b}-\rm \textbf{a})\times(\rm \textbf{c}-\rm \textbf{a})$$
请注意，该法向量算出来**不是**单位向量，同时符合使用的两个向量的右手定则。

叉乘同时具有几何意义：三角形面积是两条边向量叉乘结果的一半：

$$S_\Delta =\frac{1}{2}\parallel (\rm \textbf{b}-\rm \textbf{a})\times(\rm \textbf{c}-\rm \textbf{a})\parallel$$

由于这**不是带符号面积**，所以不能直接用于计算重心坐标。但是！我们可以观察这个三角形：我们以顺时针方向看得出的法向量和逆时针的法向量是符号相反的。

让我们回想以下向量的点乘：
$$\rm \textbf{a} \cdot \rm \textbf{b} = \parallel\rm \textbf{a}\parallel \ \parallel\rm \textbf{b}\parallel\cos\phi,$$

其中 $\phi$ 是两个向量之间的夹角。当向量 $\rm \textbf{a}$ 和 $\rm \textbf{b}$ 平行时， $\cos \phi=\pm1$ ，这让我们有办法判断向量是否同向/反向。

所以，这样做即可算出重心坐标：

首先，构造不同的法向向量 $\rm \textbf{n}_a$ 、 $\rm \textbf{n}_b$ 、 $\rm \textbf{n}_c$ 。如 $\rm \textbf{n}_a$ ，是由顶点 $\rm \textbf{b}$ 、 $\rm \textbf{c}$ 、 $\rm \textbf{p}$ 经过上面的求法向量叉乘方程计算得出的。具体如下：
$$\rm \textbf{n}_a = (\rm \textbf{c}-\rm \textbf{b})\times(\rm \textbf{p}-\rm \textbf{b})$$
$$\rm \textbf{n}_b = (\rm \textbf{a}-\rm \textbf{c})\times(\rm \textbf{p}-\rm \textbf{c})$$
$$\rm \textbf{n}_c = (\rm \textbf{b}-\rm \textbf{a})\times(\rm \textbf{p}-\rm \textbf{a})$$

然后通过求 $\cos \phi$ 的方式求出 $\alpha$, $\beta$, $\gamma$：

$$\alpha = \frac{\rm \textbf{n}\cdot\rm \textbf{n}_a}{\parallel\rm \textbf{n}\parallel^2}$$
$$\beta = \frac{\rm \textbf{n}\cdot\rm \textbf{n}_b}{\parallel\rm \textbf{n}\parallel^2}$$
$$\gamma = \frac{\rm \textbf{n}\cdot\rm \textbf{n}_c}{\parallel\rm \textbf{n}\parallel^2}$$

即可算出重心坐标。

## 常见问题

- **_为什么没有向量除法？_**

  事实证明，对于向量的除法没有很好的理论和几何意义，但是可以通过详细研究这些内容来引出**四元数**。

- **_对于三条边以上的多边形，有比重心坐标更简洁易用的工具吗？_**

  很可惜没有。就算是凸四边形也要复杂得多，这就是几何图元中三角形的重要性所在。

- **_三维直线是否有隐式形式？_**

  没有。但是，两个三维平面可以产生一个三维直线作为交线。所以三维直线可以用两个隐式三维方程联立来得到。

# 第三章 光栅图像

_大部分计算机图形图像以某种光栅显示方式呈现给用户。光栅显示将图片以像素组成的矩形阵列显示出来。_

> **像素（pixel）** 是图片元素（picture element）的缩写。

*一个常见的例子就是平板电脑显示器或电视，他们有一个由小型发光像素组成的矩形阵列，可以独立的设置颜色，显示任意的图像。不同的颜色通过混合红、绿、蓝三种颜色产生。其实，大部分打印机，如激光打印机和喷墨打印机，也可以算是光栅设备，因为他们是*基于扫描*的。虽然像素之间没有实际上的分隔，但是图像是通过在虚拟的网格中顺序的点上墨水形成的。*

_光栅在图像输入设备中也非常的普遍。数码相机有一个图像传感器，图像传感器是由一组感光像素网格组成，每个感光像素都能感受落在它上面的光的颜色和亮度。桌面扫描仪包含了一个线性的像素阵列，它可以扫过需要扫描的页面，每秒运行多次来生成一组像素网格。_

_但我们不想通过这种方法来显示图像。我们可能会需要改变图像的大小、方向、校正颜色，抑或是显示移动的三维空间中的投影图像。就算是电视，显示器的像素和显示的图像的像素也不是相同的。基于上面这些情况考虑，图片像素和显示像素并不能直接联系起来。我们最好将光栅图像视为一种**与设备独立**的图像的描述，而将显示设备的功能看作模拟显示目标图片的大致信息。_

_除了使用像素阵列，还有一种方法可以描述图像：**矢量图**。矢量图不参考像素网格，而是存储形状信息（直线或曲线包裹的颜色）来描述图像。从本质上说，这其实是存储了如何显示图像的指令，而不是显示图像的像素。矢量图的主要优点在于它**和分辨率无关**，可以在非常高分辨率的显示器上显示。矢量图一般用于文本、图标、工业制图，以及其他对精度要求高，但对图像计算和复杂阴影不怎么需要的应用场景。_

_这一章，我们会讨论光栅图像和显示的基础知识，同时特别关注标准显示的非线性。当我们在之后的章节讨论计算图像时，我们必须留意像素值和光照强度是如何联系在一起的。_

## 3.1 光栅设备

在抽象地讨论光栅图像之前，先看看使用光栅图像的设备吧家人们。一些常见的光栅设备可以简单的分为以下结构：

- 输出设备
  - 显示器
    - 透射式：液晶显示器（LCD）
    - 发射式：发光二极管显示器（LED）
  - 硬拷贝
    - 二进制：喷墨打印机
    - 连续色调：热升华打印机
- 输入设备
  - 二维阵列传感器：数码相机
  - 一维阵列传感器：平板扫描仪

### 3.1.1 显示技术

现在的显示器，包括电视和数字电影放映机，以及电脑的显示器，都是基于固定像素阵列的。他们可以分为自发光型和透光型显示器。自发光型显示器使用直接能够发射光线的不同颜色的光源制成，而透光型显示器需要在透光板后面有一个白色光源（**显示器背光/投影仪光源**），然后透光板可以改变透光的光量和颜色。

发光二极管（LED）显示屏是一种自发光型显示器的代表。每个像素都由一个或多个 LED 组成。LED 是基于有机/无机半导体的一种材料，它发光的强度取决于当前流过的电流大小。

彩色 LED 显示器的一个像素可以分为三个 **_子像素_** ：每个子像素由不同的材料构成，可以单独控制。人眼在远距离无法准确分辨三种子像素，所以它们组成的光是最后的显示效果。

液晶显示器（LCDs）是透光型显示器的代表。液晶是一种分子结构可以旋转的材料。它可以通过电压控制旋转，旋转后能改变它的透光性。一个液晶像素（图 3.3）的后面有一层偏振片，它会被偏振光照亮（在水平偏振光的条件下）。

偏振片的第二层偏振膜被定向为只传输垂直偏振光。如果电压设置为不改变偏振方向，那么光线会被一二层的偏振膜完全阻挡，也就是像素呈“关闭”状态。同样的，如果电压让二层偏振膜旋转了 90°，那么所有水平光都不会被阻挡，也就是“开启”状态，这时光强将达到最大。而中间值的电压会让液晶翻转一部分，这样就会部分透光。和 LED 显示器一样，彩色液晶的每个像素也可以分为红蓝绿三个子像素。

任何具有固定像素网格的显示器，（包括上面的显示技术，或是其他技术）都会有一个基于屏幕网格的固定分辨率。对于显示器和图像，**分辨率** 的意思就是像素网格的尺寸：如果一个桌面显示器有 1920x1200 的分辨率，那么它就一共有 2,304,000 个像素，横向有 1200 个行，纵向有 1920 个列。

而对于要显示的东西必须以 1920x1200 的分辨率填满整个屏幕，我们会使用第九章的方法来完成这一步骤。

### 3.1.2 硬拷贝设备

在纸上永久记录图像有很严的限制，和在屏幕上显示图像完全不一样。在印刷中，颜料分布在纸或者其他介质中，然后光照到它，反射不一样颜色的光，产生图像。打印机是类似于图像的光栅设备，但很多打印机只打印*二进制图像*，也就是要么没有墨水，要么有墨水，没有中间值（灰度）的选项。

喷墨打印机就是通过扫描来形成光栅图像的一个示例。一个喷墨打印机携带着可以化成小液滴喷在纸上的液态墨水。空白的地方当然就不喷墨水了。彩色打印就是使用多个不同颜色墨水组合而成的。很多喷墨打印机会有多个喷头，但决定行间距的并不是喷头，而是纸张行动的距离。

**_热转移印花_**是进行连续色调打印的一个例子，这意味着可以在纸上打印不同量的染料，而不是像喷墨打印机那样要么有要么无（图 3.6）。包含彩色染料的**供体色带** 被压在纸和**染料接收器**之间，然后一个带有加热元件的打印头会控制是否加热每一排中的像素。每一种颜色的染料都会重复这个过程一遍。可以通过温度的高低控制染料的转移程度，从而产生连续范围的颜色。打印头的提供了整个页面横向上的像素，但页面竖向上的像素由加热冷却速度与纸张速度之比决定。

和显示器不同，打印机的分辨率更多的使用 **像素密度** 进行描述。所以一个热转移打印机如果在 1 英寸的空间里有可以打印 300 个像素的打印头，那么我们可以简单的说这台打印机的分辨率是 300ppi。而一个每英寸内具有 1200 个网格的喷墨打印机，我们称它的分辨率是 1200dpi。因为喷墨打印机是**二进制设备**，它需要更高的打印分辨率来保证打印质量，这出于两个原因：一是由于打印边界是黑白边界，需要高分辨率来防止发生**阶梯状步进**、**走样**（见 8.3 节）。二是当用二进制来模拟打印连续色调图像时，也需要通过改变打印密度来调整颜色，这称作**半色调**。

> 注：dpi 现在广泛用于描述“每英寸像素”，但实际上应该使用 ppi 描述，而 dpi 专用于描述二进制设备的分辨率。

### 3.1.3 输入设备

光栅图像不是凭空生成的，而除了算法生成的图像外，任何图像都需要由 **光栅输入设备** 来捕捉。最常见的有照相机和扫描仪。就算是在渲染三维场景的时候，照片也常常用来做*纹理贴图*（见 11 章）。一个光栅输入设备必须能够测量每个像素的光线，所以通常是由传感器阵列组成的。

数码相机是二维阵列输入设备的代表。照相机里的图像传感器是一个由光敏像素网格构成的半导体。由两种常用类型：电荷耦合器件（CCDs）和互补金属氧化物半导体（CMOS）。照相机的镜头将要拍摄的物体映到传感器上，然后传感器的每个像素会测量落在上面的光强度，最终产生数据，构成输出图像。就像显示器由三种颜色的子像素构成一样，大部分彩色相机使用**滤色器阵列**或**马赛克**来让每个像素只能接收红、绿、蓝光，然后让图像处理软件填充缺失值（称为**去马赛克**）。如图 3.8。

其他相机使用三个独立的阵列或三个独立层来测量每个像素上独立的红、绿、蓝三种颜色，然后就能生成不需要进一步处理的可用图像。照相机的分辨率由阵列中的像素数量决定，通常用像素总量来描述：如果一个相机有 3000x2000 的像素阵列，就称作 6 百万像素（MP）照相机。要注意马赛克传感器的每个像素不能完整的记录所有的颜色信息，所以分辨率相同的情况下，采用独立像素的相机记录的图像信息更多。

平板扫描仪也于每一格像素单独测量红、绿、蓝的颜色值，但它类似于热转移打印机，只有一维阵列，通过一维阵列扫过需要扫描的页面，每秒进行多次扫描。横方向的分辨率由阵列所确定，所以是固定的，而纵方向的分辨率则由测量频率和移动速度之比决定。一个彩色扫描仪有一个 $3\times n_x $的像素序列，其中 $n_x$ 是整个页面的像素总数，3 则是由三行红、绿、蓝过滤器组成。通过测量三种颜色之间加入适当的延迟时间，可以做到对每一个点都进行三次不同颜色的测量。和连续色调打印机类似，扫描仪的分辨率由 ppi 表示。

> 扫描仪的分辨率有些时候称作 **光学分辨率**，因为大部分扫描仪可以通过内置的转换装置输出不同分辨率的图像。

有了这些神奇知识，接下来我们就能更详细、更抽象地探讨图像了，然后我们可以使用图像算法来调理它。

## 3.2 图像、像素和几何

我们知道，光栅图像时一个像素的巨大阵列，每一个像素都存储着在那一个网格里的颜色信息。我们已经了解了输出设备处理我们发给它的图像的过程，也了解了输入设备从自然世界的光线中获取图像的过程。但在计算机中，我们需要提取出一个与这些设备都不一样的抽象方法，用它来推理产生或转换存储在图像里的数值的方法。

当我们测量/再现图像的时候，它接收二维的光分布形式的数据：显示器发出的光是显示器表面位置的函数；落在相机传感器上的光是传感器平面上位置的函数；_反射比_，也就是反射回来光的比例（与吸收比相反），是关于一张纸上位置的函数。所以在现实世界中，**图像就是定义在二维区域（绝大部分是矩形）上的函数**。所以我们可以将图像抽象成一个函数：
$$I(x,y):R\rightarrow V,$$
这里面 $R\subset \mathbb{R}^2$ ，是一个矩形区域， $V$ 是一组像素点的集合。最简单的例子是*理想化的灰度图像*，矩形像素区域的每个点都只有一个亮度，但没有颜色，那么我们就可以说 $V=\mathbb{R}^+$ （也就是非负实数）。同样的，一个理想化的彩色图像，有 $V=(\mathbb{R}^+)^3$ 。我们将会在下一节着重讲解 $V$ 的取值问题。

那么光栅图像和连续图像，他们的抽象概念又有什么关联呢？让我们康康具体的例子：来自相机/扫描仪的单个像素，其实是测量了该像素对应的那块图像表面颜色的平均值。而一个显示用的像素（包括红、绿、蓝子像素）是这样设计的：该像素表面的平均颜色由对应的光栅图像中的像素值控制。上面两个例子里，像素值都是图像局部颜色的平均值，称为图像的*点样本*。换句话说，当我们拥有像素的值 $x$ 时，说明“在这个网格周围的像素值是 $x$ ”。这种思想称为图像作为函数的采样。我们将在第 9 章探讨这个问题。

有一个普信问题：**像素在二维空间里的位置如何表示？** 这其实只取决于个人的使用习惯，但是，建立一个一致的惯例非常重要！这本书里，我们将光栅图像的像素建立成 $(i,j)$ 这样的坐标形式，从**左下角**开始计数。如果图像有 $n_x$ 列和 $n_y$ 行像素，那么最左下角像素就是 $(0,0)$ ，最右上角则是 $(n_x-1,n_y-1)$。我们需要一个二维的真实屏幕坐标来表示像素的位置。我们将像素采样点放在整数坐标上，就像图 3.10 中，有一个 $4\times3$ 的坐标面。

上图的矩形域宽度是 $n_x$ ，长度是 $n_y$ ，同时像素是以整数坐标作为中心的，这就说明它在采样点之外还会有半个像素超出坐标轴。所以具体的矩形域是：
$$R=[-0.5,n_x-0.5]\times[-0.5,n_y-0.5]$$

再次说明，我们只是约定了这样的表达形式，但是以后实现摄像机和视图转换的时候，记住他们是很重要的。

### 3.2.1 像素值

至此为止，我们已经使用实数来描述了像素值，来代表图像中某一点的强度（可能分成三块，红、绿、蓝）。这说明图像应该是浮点数组成的阵列，每个点拥有一个（灰度图像）或者三个（彩色图像）32 位浮点值。在需要精度和范围的时候，有时我们会使用这种格式。但同时，图像有很多个像素，需要很多内存和带宽，通常情况下提供不了这么多。一张 1000 万像素的图片通过这种方法存储就要占据约 115MB 的内存。

> **问：为什么是 115MB 而不是 120MB？** 答：(((10000000×3×32)÷1024)÷1024)÷8=114.44MB

对于直接显示的图像，需要记录的光强范围就更小。虽然现实世界里光强度没有上限，但任何设备都有一个最大光强的限度。一般为了简单，范围使用 $[0,1]$ 。比如，对于一个 8-bit 图像，光强度可能的值有 $0,1/255,2/255,...,254/255,1.$ 使用浮点数存储的图像允许使用更大范围的值，通常与固定范围/低动态范围（**LDR**）分开比较，称为高动态范围（**HDR**）。在 21 章我们会深入讨论关于 HDR 图像的技术与应用。

下面是一些典型应用程序中的像素格式：

- 1 位灰度：文本或不要中间灰度值的图像（需要高分辨率）
- 8 位 RGB 固定范围颜色（共 24 位/像素）：网页或邮件应用、普通照片
- 8 位/10 位固定范围 RGB（24-30 位/像素）：计算机显示器的信号传输接口
- 12-14 位固定范围 RGB（36-42 位/像素）：专业照相使用的 RAW 格式原始照片
- 16 位固定范围 RGB（48 位/像素）：专业照相/专业打印；固定范围图像的处理过程中产生的中间图像
- 16 位固定范围灰度图像（16 位/像素）：影像学或医学图像
- 16 位“半精度”浮点 RGB：HDR 图像；实时渲染产生的中间图像
- 32 位浮点 RGB：用于软件渲染和 HDR 图像处理产生的中间图像

减少用于存储每个像素信息的比特位会导致两种不同种类的 **_伪影_**，或产生人工引入的照片瑕疵。首先，如果像素值比能显示的最大亮度还要亮，就会产生“**裁剪效应**”。比如，一张大太阳的照片，会有一些地方的太阳光反射比白色表面还要亮，但超出了显示范围（就算相机能捕捉到更大的信号），转化成固定范围照片也会产生裁剪效应，显示不出来。第二，编码精度有限的图像，在将像素进行四舍五入到最近精确值时，会产生 **_量化噪声_** 或 **_色带_**。在动画或视频中，视频变化不大的时候，色带可能不易察觉，但当画面来回移动时，色带会变得非常明显，影响观感。

> 此处的色带和上提及的色带不是一个东西，此处指色彩条带。

### 3.2.2 显示器的显示强度 和 Gamma 值

所有的现代显示器都接收数字输入的像素“值”，转化成显示的强度。真实情况下，显示器通电但关闭的情况下仍然会反射一些光出来。为了方便，我们将关闭的显示器视为黑色，完全打开的显示器视为白色，假设黑色是 0，白色是 1，白色和黑色中间的灰是 0.5。

> 此 0.5 指来自像素的物理光强，而不是外观，因为人类对光线的感知不是线性的，我们将在 20 章展开说说。

要在显示器上显示正确的图像，有两个关键问题必须明白：第一个是，显示器对输入做出的反应是非线性的，比如假设你给了显示器三个像素分别是 0，0.5，1 的值，但显示器显示的三个像素光强可能是 0，0.25，1。这种非线性的近似表征，我们一般通过 Gamma 值（ $\gamma$ ）来表述。 $\gamma$ 值表示公式中的自由度：

$$\rm displayed \ itensity=(maximum \ intensity)a^\gamma$$

其中 a 是在 0 到 1 之间的输入像素值。举个例子，假设一个显示器有 2.0 的 $\gamma$ 值，然后我们输入的 a 是 0.5，那么显示器的显示强度则是最大强度的 $\frac{1}{4}$ . 同时需要注意的是，如果 a 是 0 或 1，那么不管你输入的 $\gamma$ 值是多少，最终的强度都是最小强度/最大强度。使用 $\gamma$ 值来衡量显示器非线性只是一个近似值；但我们并不需要很准确的测量一个设备的 $\gamma$ 值。衡量非线性的一个很好的办法是：寻找在什么样的 a 的条件下，亮度值会在 0.5，即如下：

$$0.5 = a^\gamma$$

如果我们能得到 a 的值，那么 $\gamma$ 值也能推导出来。而 a 是可以通过一些手段得到的：我们可以通过显示一个只有黑白像素的棋盘图案，右边放一个随 a 改变灰度的灰色图像，然后要求观察者调整 a（比如用滑块调整之类）：当你离远了看，两者区分不出来的时候就能得到 a 的值，然后通过 $\gamma = \frac{\ln0.5}{\ln a}$ 来算出 $\gamma$ 值。

当我们知道了 $\gamma$ 值之后，就可以进行**_Gamma 校正_**，让该公式里的 a 为 0.5 的时候屏幕也显示 0.5 的光照强度，采用以下的公式完成：
$$a' = a^{\frac{1}{\gamma}}$$
将这个公式代回，我们就能得到：

$$\rm displayed \ indensity = (a')^\gamma = (a^\frac{1}{\gamma})^\gamma = a \ (maximum \ intensity)$$

真实世界里显示器的另外一个特性就是它们采用量化的输入值。因此虽然我们可以任意修改值为 $[0,1]$ 内的浮点数，但显示器的输入会将其转化并舍入为固定大小的整数。最常见的是 8 位存储，会被转化为 0-255 之间的整数。这就说明了 a 的可能值就已经不是所有 $[0,1]$ 里面的小数，而是 $\{\frac{0}{255},\frac{1}{255},\frac{2}{255},...\frac{254}{255},\frac{255}{255}\}.$

那么显示器的最大光强值就大约是 $\{M(\frac{0}{255})^\gamma,M(\frac{1}{255})^\gamma,M(\frac{2}{255})^\gamma...,M(\frac{254}{255})^\gamma,M(\frac{255}{255})^\gamma\}.$ , 此处**M**是最大光强，作为系数。在需要精确控制光强的应用场景，我们必须测量 256 种可能的强度，而且这些光强在屏幕上不同的像素点可能会不一样，尤其对于 CRT 显示器来说。它们也可能随视角而变化。幸运的是，很少有应用场景需要如此精确的校准。

## 3.3 RGB 色彩

大多数计算机图形的图像是在 RGB 色彩里定义的。RGB 色彩空间是一个可以让计算机屏幕直接转换控制信息的工具。在这一节中，我们将从用户的角度探讨 RGB 色彩，目标是能够顺利使用它们。对于颜色，更透彻的讲解会在第 19 章，但 RGB 颜色空间的机制已经能让我们编写绝大部分图形程序了。RGB 色彩空间的基本思想就是混合三种**_基色_**，红、绿、蓝，来组成各种颜色。三种基色以*叠加*的方式经常处理。

在 RGB 中叠加色彩，我们有图 3.12 上所示的的结果：

- 红 + 绿 = 黄
- 绿 + 蓝 = 青
- 蓝 + 红 = 洋红
- 红 + 蓝 + 绿 = 白

如果我们能将基色光的强度进行调整，让它从全关（即像素值 0）慢慢调整到全开（即像素值 1），我们就能调出 RGB 显示器上能显示的所有颜色。我们可以将红、绿、蓝三种像素创建一个**_RGB 立方体_**，图 3.13 展示了立方体的样子。立方体的各个角的坐标是：

$$黑色 = (0,0,0)$$
$$红色 = (1,0,0)$$
$$绿色 = (0,1,0)$$
$$蓝色 = (0,0,1)$$
$$黄色 = (1,1,0)$$
$$洋红 = (1,0,1)$$
$$青色 = (0,0,0)$$
$$白色 = (1,1,1)$$

实际上的 RGB 级别通常是以量化形式给出的，就类似 3.2.2 节提到的灰度一样，每个灰度级别都使用一个整数来表示，这些整数常用的是一个字节，也就是 8 位，所以每个 RGB 分量由 0-255 之间的整数组成，三个整数加起来占用 24 位的空间。所以一个具有“24 位色彩”的系统，对于每个颜色分量都有 256 种级别。RGB 分量同样适用与前文所讲的 **Gamma 校正** 的问题。

## 3.4 透明度合成

通常，我们对图像进行处理的时候会只想覆盖一部分区域的像素。一个很常见的例子就是 **合成图像** ，即我们有一张图做背景，想要在这章背景图的前面加上一张图。对于前景中不透明的像素，我们只需要替换掉它们即可，同样的，前景中全部透明的像素就不需要加以处理，而对于那些半透明的像素，我们就要加以小心了。前景对象有部分透明的情况有玻璃等。但是，我们遇到的最常见的前景和后景需要像素融合的情况反而不是这个，而是当前景仅覆盖单个像素的一部分时，比如前景的边界，或者前景物体有一个子像素洞，如树叶中间的孔。

将前景对象和背景对象进行混合的一个重要部分就算需要提供 **_像素覆盖率_** 。像素覆盖率能指明前景像素需要占的比例。我们将这个比率记为 $\alpha$ 。如果我们想要在背景色 ${\rm \textbf{c}}_b$ 上合成前景色 ${\rm \textbf{c}}_f$ ，比率为 $\alpha$ ，我们就可以使用公式：

$${\rm \textbf{c}} = \alpha {\rm \textbf{c}}_f+(1-\alpha){\rm \textbf{c}}_b$$

我们将不透明的前景层的合成解释为，前景对象覆盖了单个像素的 $\alpha$ 部分，然后背景对象覆盖了单个像素的剩下 $(1-\alpha)$ 部分。对于一个透明的层（如玻璃上有颜料或者半透明涂料），合成的解释是前景阻挡了背景 $(1-\alpha)$ 部分的光，然后自己 $\alpha$ 部分的光来将被阻挡的光进行补全。图 3.14 提供了使用公式的例子。

图像中所有像素对应的 $\alpha$ 值可能会存储在一个单独的灰度图像中，这个图像一般称之为**Alpha 蒙版** 或 **透明度蒙版**。或者，该信息会被看作是除了 RGB 外的第四个色彩通道，称为**Alpha 通道**，然后这图像就可以被称作**RGBA 图像**，每个通道 8 位，共 32 位。 32 位的存储在大多数计算机里是一个方便存储的**块（chunk）**。

尽管上面的透明度公式普遍适用，但是也有一些情况下 $\alpha$ 的使用方式不同 (Porter & Duff, 1984)

> 注：此处指 Porter-Duff 颜色混合模式，此混合模式较为复杂，有空将会详细讨论。

### 3.4.1 图像存储

大多数 RGB 图像格式使用每个颜色通道 8 比特进行存储。这导致了一张原始的百万像素图像的存储大小接近 3M。为了减少存储空间，大多数图像格式允许对图像进行某种方式的 压缩。压缩方式存在*有损压缩*和*无损压缩*，无损压缩不存在信息的丢失，但有损压缩的过程中必定会有信息在压缩后无法复现。比较流行的压缩方式有：

- JPEG 有损压缩。这种格式基于人眼的视觉系统进行压缩，适合自然图片。
- TIFF 无损压缩。这种压缩方式适合保存二进制图像或需要无损的 8/16 位 RGB 图像。
- PPM 无损压缩。这种压缩方式实际上压缩了但没完全压缩，可用于 8 位 RGB 图像。
- PNG 无损压缩。这是一种由良好的开源管理工具的图像格式。

由于压缩和格式转化，我们需要编写不同的输入/输出例程（Routines，可理解成服务）。幸运的是，我们可以使用*库例程*来读写标准文件格式。对于那些编写速度比运行效率更重要的应用程序，一个简单的选择是使用原始 PPM 文件，这种文件可以简单的讲内存中的图像通过数组转存到文件中，然后加上一个合适的头文件，就是原始 PPM 文件了。非常的简单。

## 常见问题

- **_为什么我们不把显示器弄成线性发光，而是要用 Gamma 值这种东西来脱裤子放屁呢？_**

  我们希望，显示器的 256 档光强应该是*看起来*均匀分布，而不是由光能量上均匀分布。因为人体对强度的感知是非线性的，取 1.5~3 之间的 Gamma 值会使我们看到的体感强度趋于均匀。因为这样，Gamma 是一个可以调节的特征，如果没有这个特征的化，显示器制造商会让显示器由光能量均匀分布，这不符合人机交互学。

# 第四章 光线追踪

***渲染*三维物体时计算机图形学的基本任务之一。渲染指的是：指定一个由多个几何体组成的场景或模型，从一个特定的观察角度看，产生的二维图像的生成过程。几个世纪以来，建筑师和工程师通过画图纸来分享他们的设计，设计图纸的理念和渲染是相同的。**

**从根本上来说，渲染 是将一个或一组对象作为输入，输出一组像素阵列的过程。不管咋样，渲染总在考虑每一个对象会对每个输出像素造成什么样的影响。我们可以将它归类成两种：在*对象顺序渲染*中，每个对象都会被依次考虑，然后为每一个被对象影响后生成的像素进行计算。你可以与循环嵌套的差异作为类比：在*图像顺序渲染*中，“每个像素”构成的循环在外部，而在对象顺序渲染中，“每个对象”的循环在外部。**

> 我们在本书中默认需要渲染的输出是光栅图像而不是矢量图。若是矢量图，那么输出就不会包含像素这个概念了。

**图像顺序渲染和对象顺序渲染的方法可以产生完全相同的图像，但是他们不同的特点让他们适合不同种类的计算任务，也具有不同的性能特征。在讨论玩这两种方法之后，我们会在第 8 章展开说说这些方法在应用上的优势所在。但是从一般性而言，图像顺序渲染更简单，更灵活，但通常（但不绝对）这种渲染方式生成图像需要更多的处理步骤。**

> 在光线追踪中，图像顺序渲染更容易生成阴影和反射，而在对象顺序渲染就比较困难了。

**光线追踪是一种用于渲染三维场景的图像顺序渲染算法。我们会先考虑它，因为我们可以在无需学习开发任何用于对象顺序渲染的数学机制的前提下，让光线追踪器工作。**

## 4.1 基础光线追踪算法

光线追踪器的原理是每次计算一个像素，对于每一个像素，主要任务是找到图像中该像素看到的对象。每个像素“**看**”的方向不同，而且每个像素所看到的任何物体都需要和**_观察光线_**相交。（观察光线是一束从**观察点**发出的、沿着像素的观察方向发出的线）我们需要的那个对象是离相机最近的、与观察光线相交的对象，因为它会挡住后面对象的视图。当找到这个对象之后，我们会使用 **着色计算** 来通过交点、表面法线和其他信息（取决于所需的渲染类型）算出该像素的颜色。如图 4.1 所示，其中光线和两个三角形相交，但是只有第一个三角形$T_2$符合要求，所以只有$T_2$被着色。

一个基础的光线追踪器由以下三部分组成：

1. **光线生成**， 它通过相机几何体计算每个像素观察光线的原点和方向。
2. **光线相交**， 它能找到与观察光线相交的最近的对象。
3. **着色**， 它能通过光线的相交结果计算像素的颜色。

基本的光线追踪的程序结构为：

```java
for each pixel do
  compute viewing ray
  find first object hit by ray and its surface normal n
  set pixel color to value computed from hit point,light,and n
```

本章介绍了光线生成，光线相交和着色的基本方法，他们对于实现一个简单的光线追踪器示例已经足够了。如果你想要实现一个完全可以使用的系统，则需要学习第 12 章的更高效计算光线相交的知识，以及第 10 章的更高级的着色方法，第 13 章的额外的渲染方法，它们能向你展示一个光线追踪器的真正能力。

## 4.2 视角

在还没出现电脑的几百年前，艺术家们就已经在研究如何在二维的画作上表现三维物体了。同样的，照片也是二维画面表示三维场景的一个例子。尽管由很多非传统的图像制作方法，从立体派绘画，到鱼眼镜头，再到外围照相机，这些艺术、摄影、包括现在的计算机图形学，都是用的一个基本手段，称为 **线性透视** ，也就是将三维的对象投影到二维的平面（_图像平面_）上，让场景中的直线变成图像里的直线。

最简单的投影叫做 **_平行投影_**。在平行投影中，三维的点通过让他们沿 *投影方向*移动，直到这些物体撞到平面，从而将三维的点映射到二维。生成的视图由
投影的方向和平面朝向有关。如果平面方向是和视图方向垂直，那么称为 **_正交投影_** ，否则，称为 _斜视投影_。

平行投影经常用于机械和建筑设计图中，因为它们能让原来的平行线继续平行，并保留平行于图像平面的那些物体的大小和形状。

平行投影的优点也是它的局限性所在。在我们日常生活中（尤其是照片），物体越远看上去越小。两条向远处延伸的平行线看上去也不是平行的。这是因为我们的眼睛/相机不是从单个的角度来接收光线的，而是通过一个固定的**视点**来收集光线。在文艺复兴时期的艺术家就已经知道了这一点，并通过 **_透视投影_** 来创作符合视觉的画作。我们不沿平行线投影，而是沿着一条穿过视点的线进行投影，这样远距离的对象看上去就很自然的变小了。透视视图由视点及成像平面的选择不同而不同，和投影方向无关。但有一点类似平行投影，就是透视投影也分倾斜和非倾斜透视投影，它们的区别在于图像中心点的投影方向不同。

你可能听说过画家口中的“三点透视”，那是一个用来构造视图的方法体系。但关于透视的一个有趣事实是，如果我们遵循透视下的所有数学规则，那么透视图直接就能画好，即所有物体直接投影到眼睛，并在眼睛前的视图上形成图像这样的规则会自然形成。

## 4.3 计算观察光线

上一节我们说到，光线生成的最基本工具就是使用**视点**（亦作平行视图的观察方向）和**图像平面**。相机几何体的细节实现可以使用很多方法，在本节我们就会讲述一种基于标准正交基的方法，该方法支持计算法线、倾斜平行视图和正交视图。

为了生成光线，我们首先需要对光线进行一种数学表示。一条光线，其实就是一个起始点和一个传播方向。而*回忆第二章知识*，我们可以知道 **三维参数化直线** 尤其适合表示这个。见 2.5.7 节，三维参数化直线，从起始点（眼睛）$\rm \textbf{e}$ 到图像平面上的点 $\rm \textbf{s}$ 的直线方程这样表示：

$${\rm \textbf{p}}(t)-{\rm \textbf{e}} + t(\rm \textbf{s}-\rm \textbf{e})$$

这个公式的解释是：我们从 $\rm \textbf{e}$ 点开始，沿着 $\rm \textbf{s}-\rm \textbf{e}$ 的方向前进一个分数 t 的距离来到达点 $\rm \textbf{p}$ 。所以对于一个给定的 ${t}$ ，我们可以确定点 $\rm \textbf{p}$ 。点 $\rm \textbf{e}$ 是光线的起始点， $\rm \textbf{s}-\rm \textbf{e}$ 是光线的方向。

注意， $\rm \textbf{p}(0) =  \rm \textbf{e}$ , $\rm \textbf{p}(1)=\rm \textbf{s}$ 。更一般地，如果 $0 < t_1 < t_2$ ，那么 $\rm \textbf{p}_1$ 比 $\rm \textbf{p}_2$ 更接近视点。同理，如果 $t<0$ ，那么 $\rm \textbf{p}(t)$ 在视点的后面。这种方法可以让我们方便快捷的找到在视点前且最近的对象。

为了计算一束视角光线，我们需要知道 $\rm \textbf{e}$ （起始点）的位置和 $\rm \textbf{s}$ （图像点）。可能寻找图像上的点 $\rm \textbf{s}$ 略有困难，但当我们选择了合适的坐标系，寻找 $\rm \textbf{s}$ 就变得比较简单直接了。

我们所有的光线生成方法都是从一个叫做 **_相机帧_** 的标准正交坐标系开始的。 在这个坐标系中，我们用 $\rm \textbf{e}$ 表示视点（观察点），然后用 $\rm \textbf{u}$ 、 $\rm \textbf{v}$ 、 $\rm \textbf{w}$ 表示三个基向量。从相机的视图来看, $\rm \textbf{u}$ 指向相机朝向的右边， $\rm \textbf{v}$ 指向相机的上方， $\rm \textbf{w}$ 指向后方（视角方向的反方向）。由此可见， $\rm \{ \textbf{u,v,w}\}$ 是一个右手系。构造相机帧的最简单方法是**从**视点（也就是 $\rm \textbf{e}$）、视图方向（也就是 $\rm \textbf{-w}$）以及向上的向量（用于构造另外两个正交基）**开始**， 使用 2.4.7 节中构造正交基的过程构造坐标系。

> 由于 $\rm \textbf{v}$ 和 $\rm \textbf{w}$ 必须垂直（见第二章的校正正交），所以向上的向量和和 $\rm \textbf{v}$ 通常不相同。但是将向上的向量在场景中设置为相机的“上方”有助于我们定向相机的视角。

### 4.3.1 正交视图

对于正交视图，所有的光线都指向一个方向： $\rm \textbf{-w}$ 。虽然平行视图本身没有视点，但我们仍然可以使用相机帧的原点来定义光线开始的平面，以便对象能出现在相机的后面。

> 正交视图的观察光线在无限远开始，这样设定听起来似乎很合理——但是如果这样设定，你就无法生成房屋内部的观察视角。

光线从被 $\rm \textbf{e}$ 以及向量 $\rm \textbf{u}$ 、 $\rm \textbf{v}$ 定义的平面发射。剩下我们需要得到的就是图像应该在平面的*什么位置*。我们通过四个值来定义图像尺寸，用于图像的四条边： $l$ ， $r$ 是图像的左右边缘的位置（也就是从 $\rm \textbf{e}$ 点向 $\rm \textbf{u}$ 轴方向进行测量）；同理， $b$ ， $t$ 是图像的上下边缘的位置（也就是 $\rm \textbf{e}$ 点向 $\rm \textbf{v}$ 轴方向进行测量）。一般来说， $l < 0 < r$ ， $b < 0 < t$ 。也就是 **上/右为正**，见图 4.9。

在 3.2 节中我们讨论过图像中的像素坐标。为了将 $n_x \times n_y$ 像素的图像塞到大小为 $(r-l)\times(t-b)$ 的矩形中，像素在水平方向上的间隔是 $\frac{(r-l)}{n_x}$ ，垂直方向的间隔是 $\frac{(t-b)}{n_y}$ ，而且边缘周围会有半个像素的空间，以便于像素网格在图像矩形里居中。这意味着光栅图像位置 $(i,j)$ 的像素是：

$$u=l+\frac{(r-l)(i+0.5)}{n_x}$$
$$v=b+\frac{(t-b)(j+0.5)}{n_y}$$

这个坐标 $(u,v)$ 表示的是相对于原点 $\rm \textbf{e}$ 和基向量 $\rm \textbf{u}$、 $\rm \textbf{v}$ 的坐标值。

> 很多坐标系统会让 $l=-r$ , $b=-t$ ，这样宽度和高度都能刚好足够。

在正交视图中，我们可以简单的使用像素的图像平面位置作为光线的发射点，而且我们也知道光线的发射方向就是视图方向。所以生成光线的步骤是：

```c++
compute u and v using(4.1)
ray.direction = -W
ray.orign = e +u*U+v*V
```

进行斜向的平行投影也很简单：只需要将上述的图像平面的法向量 $\rm \textbf{w}$ 和视角方向 $\rm \textbf{d}$ 分开指定，其他的步骤和上述完全相同（即用 $\rm \textbf{d}$ 代替 $\rm \textbf{-w}$ ），当然， $\rm \textbf{u}$ 和 $\rm \textbf{v}$ 的构造仍然使用 $\rm \textbf{w}$ 向量。

### 4.3.2 透视视图

对于透视视图，所有的光线都有一个相同的发射点，也就是视点。每个像素朝着的方向都不一样。同时，图像平面也不再位于 $\rm \textbf{e}$ 处，而是在 $\rm \textbf{e}$ 前面的一段距离 $d$ 的地方。这段距离 $d$ 就是**图像平面距离**，一般也叫做**焦距**。每条光线的方向都由视点和图像平面上像素的位置共同决定。示例图在图 4.9，所得程序如下所示，和正交投影程序类似：

```c++
compute u and v using(4.1)
ray.direction = -d*W+u*U+v*V
ray.orign = e
```

和平行投影一样，可以通过指定图像平面法线与投影方向不同，以及将 $d\rm \textbf{w}$ 替换为 $d\rm \textbf{d}$ 来实现斜透视视图。

## 4.4 光线和物体的相交

当我们生成了一条光线： ${\rm \textbf{e}}+t \rm \textbf{d}$ 后，我们下一步就需要找到在 $t>0$ 条件下第一个和视线相交的物体。在现实操作中，则是实现一个更一般的问题：找到 $t$ 在 $[t_0,t_1]$ 区间内的、光线和表面第一次相交的点。最基础的光线相交的情况是 $t_0 = 0$ , $t_1 = +\infty$。我们需要解决球面和三角形情况下的这个问题。下一节中会讲到多个不同的物体。

### 4.4.1 光线和球体的相交

给定一条射线： ${\rm \textbf{p}}(t) = {\rm \textbf{e}}+t\rm \textbf{d}$ ，以及一个隐式曲面 $f(\rm \textbf{p}) = 0$ （详见 2.5.3 节），我们需要知道他们在什么地方会相交。在相交时会满足下面的方程，所以我们能从中解出 $t$ 。即：

$$f({\rm \textbf{p}}(t)) = 0 \ \ {\rm or }\ \ f({\rm \textbf{e}}+t{\rm \textbf{d}}) = 0.$$

圆心为 ${\rm\textbf{c}} = (x_c,y_c,z_c)$ ，半径为 $R$ 的球体的隐式方程可以如下表示：

$$(x-x_c)^2+(y-y_c)^2+(z-z_c)^2 -R^2 = 0$$

转化为向量表示法即是:

$$({\rm \textbf{p}}-{\rm \textbf{c}})\cdot({\rm \textbf{p}}-{\rm \textbf{c}})-R^2 = 0$$

任何满足这个方程的点都在球面上。如果我们将光线方程 ${\rm \textbf{p}}(t)=f({\rm \textbf{e}}+t{\rm \textbf{d}})$ 代入这个等式，就能得到一个代表着球面交点的关于 $t$ 的参数方程：

$$({\rm \textbf{e}}+t{\rm \textbf{d}}-{\rm \textbf{c}})\cdot({\rm \textbf{e}}+t{\rm \textbf{d}}-{\rm \textbf{c}})-R^2 = 0$$

整理，得：

$$({\rm \textbf{d}}\cdot{\rm \textbf{d}})t^2+2{\rm \textbf{d}}({\rm \textbf{e}}-{\rm \textbf{c}})t+({\rm \textbf{e}}-{\rm \textbf{c}})\cdot({\rm \textbf{e}}-{\rm \textbf{c}})-R^2 = 0$$

这时，除了 $t$ 之外的所有参数均已知，所以这是一个经典的一元二次方程：
$$At^2+Bt+C = 0$$

小学生都学过怎么解这个方程。而判别式 $B^2-4AC$ 的正负意义在于判断是否有交点。假设有交点，那么求解得：

$$t = \frac{-{\rm \textbf{d}}\cdot({\rm \textbf{e}}-{\rm \textbf{c}})\pm \sqrt{({\rm \textbf{d}}({\rm \textbf{e}}-{\rm \textbf{c}}))^2-({\rm \textbf{d}}\cdot{\rm \textbf{d}})(({\rm \textbf{e}}-{\rm \textbf{c}})\cdot({\rm \textbf{e}}-{\rm \textbf{c}})-R^2})}{({\rm \textbf{d}}\cdot {\rm \textbf{d}})}$$

在实际的实现中，你首先应该检查判别式，然后再计算其他项。如果球体只是用于包裹更复杂的物体，当做边界使用，那么我们只需要判断是否和球体有相交，也就是只检查判别式就够了。

我们在 2.5.4 节讨论过，在任意点 ${\rm \textbf{p}}$ 的法向量可以通过梯度 ${\rm \textbf{n}} = 2({\rm \textbf{p}}-{\rm \textbf{c}})$ 得出，而单位向量就是 $\frac{{\rm \textbf{p}}-{\rm \textbf{c}}}{R}$ 。

### 4.4.2 光线与三角形的相交

计算光线和三角形的相交有好多种算法。我们会介绍使用**重心坐标**的使用参数化平面的形式。因为他除了三角形的顶点之外，不需要为其他东西进行长期存储。（Synder&Barr, 1987）

为了让参数化表面和光线相交，我们联立了以下方程组：

$$
\begin{equation}
\left.
\begin{array}{c}
    x_{e}+tx_{d}=f(u,v) \\
    y_{e}+tx_{d}=g(u,v) \\
    y_{e}+ty_{d}=h(u,v) \\
     \nonumber
\end{array}\
\right .
\end{equation} \ \ {\rm{or,}} \ \ \ \ {\rm \textbf{e}}+t{\rm \textbf{d}} = {\rm \textbf{f}}(u,v)
$$

在这里，我们有三个未知数（ $t$ , $u$ 和 $v$ ），有三个方程，使用我们能得到它们的数值解。如果我们幸运的话，我们还可以得到它们的*解析解*。

> 译者注：可以这样来理解数值解和解析解的区别，解析解是一个求解公式，它适用于所有这类方程的求解，而数值解是某个特定方程的具体的解。

在这个例子中，参数表面是平面，那么参数方程就可以写成我们在 2.7.2 节讨论过的这种写法。如果三角形的顶点分别是 ${\rm \textbf{a}}$ ， ${\rm \textbf{b}}$ ， ${\rm \textbf{c}}$ ，那么交点方程在某些 $t$ , $\beta$, $\gamma$ 的情况下就会成立：

$${\rm \textbf{e}}+t{\rm \textbf{d}} = {\rm \textbf{a}}+\beta({\rm \textbf{b}}-{\rm \textbf{a}})+\gamma({\rm \textbf{c}}-{\rm \textbf{a}})$$

如图 4.10 所示，交点 ${\rm \textbf{p}}$ 位于 ${\rm \textbf{e}}+t{\rm \textbf{d}}$ 处。同时从 2.7.2 节内容我们可以得知，仅当 $\beta>0$, $\gamma>0$ , $\gamma+\beta<1$ 时，光线和三角形的内部有交点。否则的话，光线实际上是和三角形的外部平面相交，也就是不与三角形相交。如果上面的方程无解，说明要么三角形退化成平行线，要么光线和三角形所在平面平行。

为了求解上面方程中的未知数 $t$, $\beta$, $\gamma$，我们将其从向量形式展开成三个坐标的三个方程：

$$x_e+tx_d = x_a+\beta (x_b-x_a)+\gamma(x_c-x_a),$$
$$y_e+ty_d = y_a+\beta (y_b-y_a)+\gamma(y_c-y_a),$$
$$z_e+tz_d = z_a+\beta (z_b-z_a)+\gamma(z_c-z_a),$$

也就可以写成下面的矩阵：

$$
\left[\begin{matrix}
  x_a-x_b & x_a-x_c & x_d \\
  y_a-y_b & y_a-y_c & y_d \\
  z_a-z_b & z_a-z_c & z_d
\end{matrix} \right]\left[\begin{matrix}
  \beta \\
  \gamma \\
  t
\end{matrix} \right] = \left[\begin{matrix}
  x_a-x_e \\
  y_a-y_e \\
  z_a-z_e
\end{matrix} \right]
$$

最快的求解方法是使用*克拉默法则*。这样我们能得到结果：

$$
\beta = \frac{\left\vert\begin{matrix}
  x_a-x_e & x_a-x_c & x_d \\
  y_a-y_e & y_a-y_c & y_d \\
  z_a-z_e & z_a-z_c & z_d
\end{matrix} \right\vert}{\vert \rm\textbf{A} \vert}
$$

$$
\gamma = \frac{\left\vert\begin{matrix}
  x_a-x_b & x_a-x_e & x_d \\
  y_a-y_b & y_a-y_e & y_d \\
  z_a-z_b & z_a-z_e & z_d
\end{matrix} \right\vert}{\vert \rm\textbf{A} \vert}
$$

$$
t = \frac{\left\vert\begin{matrix}
  x_a-x_b & x_a-x_c & x_a-x_e \\
  y_a-y_b & y_a-y_c & y_a-y_e \\
  z_a-z_b & z_a-z_c & z_a-z_e
\end{matrix} \right\vert}{\vert \rm\textbf{A} \vert}
$$

我们需要线性解的光线与三角形相交的算法需要在一些时候进行提前结束。因此，函数伪代码如下：

```c++
boolean raytri(ray r, vector3 a, vector3 b, vector3 c,interval[t0,t1])
compute t
if (t < t0)or(t > t1) then
  return false
compute γ
if (γ < 0) or (γ > 1) then
  return false
compute β
if (β < 0) or (β > 1 − γ) then
  return false
return true
```

### 4.4.3 射线与多边形相交

我们给定一个平面多边形，它有 $m$ 个顶点，是 $\rm\textbf{p}_1,\cdots\textbf{p}_m$ ，以及表面法向量 $\rm\textbf{n}$ 。我们首先将计算光线 ${\rm\textbf{e}}+t{\rm\textbf{d}}$ 和多边形的交点，通过隐式方程求解：

$$({\rm\textbf{p}}-{\rm\textbf{p}}_1) \cdot{\rm\textbf{n}} = 0$$

我们代入 ${\rm\textbf{p}} = {\rm\textbf{e}}+t{\rm\textbf{d}}$ ，然后化简解出 $t$ ，得

$$t = \frac{({\rm\textbf{p}}_1-{\rm\textbf{e}})\cdot{\rm\textbf{n}}}{{\rm\textbf{d}}\cdot {\rm\textbf{n}}}$$

这样我们就也能把 ${\rm\textbf{p}}$ 求出来。如果 ${\rm\textbf{p}}$ 点在多边形内部，那么光线就能与之相交，反之，光线不相交。

对于判断光线的交点是否在多边形的内部的这个问题，我们可以通过将点和多边形的顶点投影到 xy 平面来进行判断。最简单的方法是任意取一条从 ${\rm\textbf{p}}$ 点发射的射线，然后计算这条射线和多边形的边相交了几次。如果是基数词，说明在多边形的内部，反之在外部。（参考：Sutherland, Sproull, & Schumacker, 1974; Glassner, 1989）因为进入的光线必须离开，从而创建一对交点。为了简便，我们可以设定二维射线是沿着 x 轴方向传播的：

$$
\left[\begin{matrix}
  x \\
  y \\
\end{matrix} \right] = \left[\begin{matrix}
  x_p \\
  y_p \\
\end{matrix} \right]+s\left[\begin{matrix}
  1 \\
  0 \\
\end{matrix} \right]
$$

对于 $s \in(0,\infty)$ 计算这条射线与边（边的表示方法为 $(x_1,y_1,x_2,y_2)$ ）的交点是很直接简单的。

但是，对于在 xy 平面中投影是一条直线的多边形，这个方法就不适用了。为了解决这个问题，我们可以从 xy, yz,zx 平面中选择最合适的平面。如果我们的点在计算机中支持索引操作（如： ${\rm\textbf{p}}(0)=x_p$ ），那么选择平面的操作可以用以下的伪代码表示：

```c++
if(abs(zn)>abs(xn)) and (abs(zn)>abs(yn)) then{
  index0 = 0;
  index1 = 1;
}
else if(abs(yn)>abs(xn)) then{
  index0 = 0;
  index1 = 2;
}
else{
  index0 = 1;
  index1 = 2;
}
```

这样，所有的计算就可以通过 ${\rm\textbf{p}}(index0)$ 而不是 $x_p$ 实现，以此类推。

除上述方法，实践中我们经常使用另外一种多边形方法：使用几个三角形替换多边形。

### 4.4.4 与一组对象相交

当然，大多数有趣的场景都由不止一个对象组成。当光线和场景相交时，我们必须找出离相机最近的交点。一个简单实现是把这一组对象看成是一个新对象。要使光线和这组对象相交，只需要简单的将光线和组内的对象相交，然后返回最小的 $t$ 值。下面的伪代码判断了在区间 $t \in [t_0,t_1]$ 中的相交：

```c
hit = false
for each object o in the group{
  if(o is hit at ray parameter t and t is in[t0,t1]){
    hit = true;
    hitobject = o;
    t1 = t;
  }
}
return t
```

## 4.5 着色（Shading）

当像素的 _可见表面_ 已知后，我们可以通过计算着色模型来计算像素值。实现方法取决于应用程序——使用的方法从简单的*启发式算法*到精细的数值计算都是可以的。在这一节，我们会描述两种建立着色模型的基本方法。更高级的方法将在第 10 章提及。

在图形学领域，着色一般指对某个物体施加某种 **材质** 。

> 译者注：_可见表面_ 指上一节推断出来的能被相机“看到”的表面。

> 加注： _计算机科学的两大基础目标，就是发现可证明其执行效率良好且可得最佳解或次佳解的算法。而启发式算法则试图一次提供一或全部目标。 例如它常能发现很不错的解，但也没办法证明它不会得到较坏的解；它通常可在合理时间解出答案，但也没办法知道它是否每次都可以这样的速度求解。_ 启发式算法通过 **优化** 得出可以接受误差、花费代价较少的最优解。现阶段，启发式算法以仿自然体算法为主，主要有蚁群算法、模拟退火法、神经网络等。

大多数的着色模型，不管用啥方式，都是在设计如何捕捉光的反射的过程。即表面被光源照射，反射部分光回到相机中。简单的着色模型是根据点光源的照明度来定义的。在光的反射中，重要的变量有：光的方向 ${\rm\textbf{l}}$ ，它是一个 **指向光源** 的单位向量；视图方向 ${\rm\textbf{v}}$ ，他是一个 **指向相机** 的单位向量；表面法向量 ${\rm\textbf{n}}$ ，它是一个在垂直于该发生反射的点所在平面的单位向量。其他的表面属性，如颜色、光泽度之类，取决于特定的着色模型。

> shading 和 shadow 不是一个东西。在我们考虑着色时，我们不考虑其他物体挡住光的情形。

### 4.5.1 兰伯特光照模型

最简单的着色模型是基于 18 世纪兰伯特（Lambert）的观察：落在表面上的光能取决于光的照射角度。直接朝向光源的表面会获得最大的光照强度，而与灯光方向相切或背向灯光的表面不会受到照明。在这两者之间的情况下，照明度和法线与光源之间的夹角 $\theta$ 成正比。兰伯特光照模型的公式（**兰伯特余弦定律**）如下：
$$L = k_dImax(0,  {\rm\textbf{n}}\cdot{\rm\textbf{l}} )$$
其中 $L$ 是像素颜色， $k_d$ 是**漫反射系数**（也称表面颜色）， $I$ 是光源的强度。因为 ${\rm\textbf{n}}$ 和 ${\rm\textbf{l}}$ 是单位向量，所以 ${\rm\textbf{n}}\cdot {\rm\textbf{l}}$ 可以直接用来简洁的表示 $\cos \theta$。这个方程（以及本节的其他着色方程）分别使用于三个颜色通道。所以像素值的红色分量是红色漫反射分量、红色光照强度、以及向量点乘积的组合结果。蓝色和绿色通道亦然。

需要注意的是，光强一般来说和距离成反比。也就是：

$$I' = \frac{I}{r^2}$$

> 译者注：**反射系数** 指光（入射光）投向物体时，其表面反射光的强度与入射光的强度之比值（有多少入射光能够被反射出去，其值介于 0~1 之间），受入射光的投射角度、强度、波长、物体表面材料的性质以及反射光的测量角度等因素影响。一般来讲，黑色的反射系数较小，为 0.03，白色的反射系数较大，为 0.8。

> 注：实际上，光照强度是和距离平方成反比的，但这样处理既复杂又不划算，不如一个简单的渲染器来的好。

向量 ${\rm\textbf{l}}$ 通过光源位置与光线-表面交点的两个点相减得到。别忘了 ${\rm\textbf{v}}$ 、 ${\rm\textbf{l}}$ 、 ${\rm\textbf{n}}$ 都必须是单位向量。没有单位化这些向量产生的着色错误非常常见。

> 当出现问题时，将光源设定为中性光，每个颜色通道分量相同是一个好办法。

### 4.5.2 Blinn-Phong 着色模型

> 读作 _布林-冯着色模型_。

兰伯特光照模型 _与视图无关_ ：表面的颜色和你从哪个方向看没有关系。在真实情况下，很多曲面有一些光泽度，它提供了高光（也叫镜面反射），高光会随着视角的变化而产生移动。兰伯特着色不会产生任何高光，所以它的外观是粗糙无光泽的。很多着色模型会向兰伯特着色中添加一种 _高光反射组件_ ；兰伯特着色组件作为 _漫反射组件_ 而存在。

一种简单且广泛应用的高光着色模型由 Phong(Phong, 1975)提出，之后由 Blinn(J.F.Blinn,1976)进行了改进，变成了我们现在使用的模型。该模型的主要思想是：当光照到物体发生镜面反射，反射光恰好就是 _视图光线_ 时，光强最大（也就是 ${\rm\textbf{v}}$ 和 ${\rm\textbf{l}}$ 恰好对称，发生镜面反射）。当反射光和视图光线夹角慢慢变大，反射光慢慢减少。

我们可以通过比较半程向量 ${\rm\textbf{h}}$ 和表面法向量来判断视图光线是否趋近于反射光（见图 4.16）。如果它们相近，那么高光组件应显示明亮的视觉效果；反之应该暗淡。我们可以通过 ${\rm\textbf{h}}$ 和 ${\rm\textbf{n}}$ 的点乘积判断（别忘了它们都是单位向量，若它们在同一条线上。说明它们的点乘积最大，也就是 1），我们可以通过对该结果进行乘方，来控制光面的大小。乘方 $p$ 应大于 1， $p$ 也被称作是 **Phong 指数** 。半程向量很好算，因为 ${\rm\textbf{v}}$ 和 ${\rm\textbf{l}}$ 都是单位向量，所以只需要将两个向量相加，然后进行标准化就可以得到半程向量 ${\rm\textbf{h}}$ 了。

> **半程向量 h**是通过对向量 l 和向量 v 取平均然后归一化得到的一个新向量。这样可以简化计算。

综上所述，Blinn-Phong 光照模型如下所示：

$${\rm\textbf{h}}=\frac{{\rm\textbf{v}}+{\rm\textbf{l}}}{\parallel {\rm\textbf{v}} +{\rm\textbf{l}}\parallel}$$

$$L = k_dImax(0,{\rm\textbf{n}}\cdot{\rm\textbf{l}})+k_sImax(0,{\rm\textbf{n}}\cdot{\rm\textbf{h}})^p$$

其中， $k_s$ 指的是 **高光反射系数** ，或者说是表面高光颜色。和前面的光照模型一致， $I$ 其实是 $I/r^2$ ，距离越远，光强越弱。

> Phong 指数有一些典型值：
>
> - 10：蛋壳
> - 100：略微光滑(常用)
> - 1000：富有光泽
> - 10000：近乎镜面

> 同上节，如果出现了问题，让高光反射系数（表面高光颜色）变灰，三个色彩通道相同，有助于解决问题。

### 4.5.3 环境光

完全不受光照的表面会被渲染成纯黑，但是这不是我们想要的结果。一个简单粗暴的解决办法是向着色模型添加一个*定值组件*，该组件对像素颜色的影响仅仅取决于是否与对象相交，而与表面几何无关。这就是所谓的**环境光处理**——就像表面被来自各处的环境光所照亮一样。为了方便调整参数，环境光照一般用表面颜色和环境光颜色的乘积表示。因此，既可以针对某一个特定表面调整环境光，也可以对所有物体进行同步调整。与 Blinn-Phong 光照模型的部分结合，环境光照模型实现了一个简单有用的着色模型的完全体：

$$L = k_aI_a+k_dImax(0,{\rm\textbf{n}}\cdot{\rm\textbf{l}})+k_sImax(0,{\rm\textbf{n}}\cdot{\rm\textbf{h}})^n$$

其中 $k_a$ 表示**环境光系数**（也称作环境光颜色）， $I_a$ 表示环境光强。

> 同样的，当出现问题时，将环境光颜色（系数）设置成与漫反射颜色（系数）相同会有助于解决问题。

### 4.5.4 多点光源

光的另一个有用的特性是光可以进行 **叠加** 。多个光源产生的效果就是简单的多个光源影响的总和。因此，我们打造的着色模型可以简单的扩展成能处理 $N$ 个光源的公式：

$$L = k_aI_A+ \sum_{i=1}^n [k_dIimax({\rm\textbf{n}}\cdot{\rm\textbf{l}}_i)+k_sI_imax({\rm\textbf{n}}\cdot{\rm\textbf{h}}_i)^p],$$

其中 $Ii$ ，${\rm\textbf{l}}_i$ 和 ${\rm\textbf{h}}_i$ 分别是光强、光的方向向量，以及第**i**个光源的半程向量。

## 4.6 简单的光线追踪程序

现在我们已经知道了对于一个给定的像素如何生成观察光线，如何找到光线和物体最近的交点，以及如何对该交点进行着色。一个光线追踪程序所需的基本部分已经阐述完毕，下面的伪代码展示了如何生成着色图像并且移除隐藏表面。

```c
for each pixel{
  compute viewing ray
  if(ray hits an object with t in [0, ∞]){
    Compute n;
    Evaluate shading model and set pixel to that color;
  }
  else{
    set pixel color to background color;
  }
}
```

这里的“ **ray hits an object with t in [0, ∞]** ”这句代码可以使用 4.4.4 节的算法代替。

在实际的实现中，曲面相交的例程需要以某种方式返回相交对象的**引用**，或者至少也该返回个该对象的法向量和与着色相关的属性。通常这是通过传递一份记录/结构体来实现。在面向对象的开发实现中，一个好办法是我们去创建一个*surface*类，然后包含子类*triangle, sphere, group*等类。那么光线能相交的所有对象都会是这个类的实例，然后光线追踪程序只需要对整个模型的“表面”进行一次引用，而且新种类的物体也可以很方便的进行添加操作。

### 4.6.1 光线追踪程序的面向对象设计

之前说过，光线追踪器中的关键类层次结构是构成模型的几何对象。这些几何对象应该是几何对象类的子类，同时它们都支持 hit 函数 (Kirk&Avro, 1988) 。同时，为了防止滥用“**对象**”这个词引起的歧义，我们通常使用*surface*作为父类的名字。有了这个父类，我们就可以创建一个具有一个通用接口的光线追踪器，该光线追踪器不关心模型的初始化，且只是用球体进行 Debug。一个重要的地方在于，只要是能与光线相交的物体，都应该是这个类层次结构的一部分（如，一组曲面也应看作是表面类的**子类**）。这里面也包含了效率数据结构，如*层次包围盒*，由于它会与光线相交，所以它也是子类。

举个例子，“抽象类”或“基类”会将所谓的“相交函数”（碰撞判断函数）规定为与后面所说的*边界框*函数所需要的样子：

```c++
class surface{
  virtual bool hit(ray e+td, real t0, real t1,hit-record rec);
  virtual box bounding-box();
}
```

这里的 $(t_0,t_1)$ 是光线相交之后返回的值的区间； $rec$ 是一个传递引用的记录值（见曲面相交例程，4.6 节），它包含了光线确定相交后的相交时数据：如 $t$ 等数据。 $box$ 类型是一种三维包围盒，它包含的数据是**空间中的两个点**，表示这两个点沿着**坐标轴方向**构成的**将曲面包裹住的**立方体。比如，对于一个球体，那么这个抽象函数的具体实现就是这样的：

```c++
box sphere::bounding-box(){
  vector3 min = center − vector3(radius,radius,radius)
  vector3 max = center + vector3(radius,radius,radius)
  return box(min, max)
}
```

除了*surface*类，另外一个有用的类是材质类（_material class_），它能够让你抽象出材质的功能和行为，然后你可以无所顾忌的添加材料了。将材质和物体联系起来的一个简单方法是：在*surface*类中添加一个指向材质（_material_）的指针，尽管这样需要更多的代码量。不过，还有一个大问题：_如何处理纹理，纹理是属于材质类还是处于材料类之外？_ 这将会在第 11 章进行详细讨论。

## 4.7 阴影

当你有了一个基本的光线追踪程序之后，添加阴影就会变得非常简单。我们回想以下 4.5 节学了甚么。在那一节 _[4.5 着色]_ 中，光线从一个固定方向 ${\rm\textbf{l}}$ 照射过来。如果我们想象自己在点 ${\rm\textbf{p}}$ 处，看向光源 ${\rm\textbf{l}}$ ，发现看到了一个物体，那就说明我们站的点在阴影中。反之，如果没有物体遮挡，光线也就不会被遮挡。

这如图 4.17 所示，当光线 ${\rm\textbf{p}} + t{\rm\textbf{l}}$ 不与任何物体相交，那么它就不处于阴影下。向量 ${\rm\textbf{l}}$ 对于这两个不同的点（一个在阴影中，一个不在），是一样的，因为我们设定光源是无限远，所以两束光平行。判断点是否在阴影中所使用的这些光线称作 **阴影光线** ，它需要和 **视角光线** 区别开。

为了得到阴影算法，我们添加了一个 _if_ 语句来判断这个点是否在阴影中。在简单实现中，阴影光线会检查 $t$ 是否在 $[0,\infty]$ 区间内，但由于浮点精度的误差，0 的端点可能会导致产生一个与平面本身的交点，这不符合我们的定义。所以一般的解决办法是将区间改成 $[\epsilon,\infty]$ ，其中 $\epsilon$ 是一个足够小的常量。

如果我们在 **Phong 光照模型公式** 中继续加入阴影光线，那么就会有下面的伪代码：

```c++
function raycolor( ray e + td, real t0, real t1 )
hit-record rec, srec;
if (scene → hit(e + td, t0, t1, rec)){
  p = e +(rec.t)·d
  color c = rec.ka*Ia
  if (not scene → hit(p + sl, epsilon, ∞, srec)){
    vector3 h = normalized(normalized(l) + normalized(−d))
    c = c + rec.kd*I*max(0, rec.n · l)+(rec.ks)*I*(rec.n · h)^rec.p
  }
  return c
}
else
  return background-color
```

请注意，不管 ${\rm\textbf{p}}$ 是否在阴影中，环境光都必须添加。如果有多个光源，那么我们可以在评估多个光源的着色模型之前发送每个光源的阴影光线。上述代码假设了 ${\rm\textbf{d}}$ 和 ${\rm\textbf{l}}$ 不一定必须是单位向量，尤其是 ${\rm\textbf{d}}$ 不一定是单位向量，这对于我们以后进行*实例化*至关重要。_[13.2 节]_

## 4.8 理想的镜面反射

添加一个 _理想高光反射（镜面反射）_ 到光线追踪程序中非常简单。主要示意图如图 4.19，观察者从地点 ${\rm\textbf{e}}$ 进行观察，可以看到 ${\rm\textbf{r}}$ 方向上的物体。向量 ${\rm\textbf{r}}$ 是使用 _Phong 光照反射方程[第 10 章]_ 的一种变体得到的，在方程前面有一个负号，那是因为在本例中，向量 ${\rm\textbf{d}}$ 是朝着镜面的。方程为：

$$ {\rm\textbf{r}} = {\rm\textbf{p}}-2( {\rm\textbf{d}}\cdot {\rm\textbf{n}} ) {\rm\textbf{n}}$$

在真实世界里，光线反射后会损失一部分能量，不同的色光损失的能量可能不一样。比如，黄金能更有效地反射黄色，因此它会改变反射光的颜色。这个特性可能通过在 _raycolor_ 函数中添加一个递归实现：

$$color \  c = c+k_mraycolor({\rm\textbf{p}}+s{\rm\textbf{r}},\epsilon,\infty) $$

其中， $k_m$ （m 代表镜面反射）是镜面反射的 RGB 颜色。同样的，我们需要保证 $s$ 的取值在 $[\epsilon,\infty)$ ，因为我们不想光线一发射就被判断为与自己表面相交。

另外一个问题在于上面的递归可能永远都不会达成终止条件。比如，如果一条光线生成与房间中进行镜面反射，它永远都不会停下来。这个问题可以通过设置一个最大递归深度来解决。如果仅当 $k_m$ 不为 0 （黑色）时才生成反射光，代码则可以变得更高效。

> 译者注：为了确保递归程序正确工作，递归至少需要两个条件：基本情况（bottom cases）与递推关系（recurrentce relation）。

## 4.9 历史上的光追

光线追踪在计算机图形学的早期就已经发展起来 (Appel, 1968) ，但当时没有发展起来，因为当时的电脑性能实在是不太够用。 (Kay&Greenberg, 1980)

光线追踪的 _渐进时间复杂度_ 低于 _基本对象顺序渲染_ 。尽管它传统上被认为是一种*离线算法*。实时光追正变得越来越普遍。

> 译者注：**在线算法**是指它可以以序列化的方式处理输入，也就是说在开始时并不需要已经知道所有的输入。相对的，对于**离线算法**，在开始就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。例如，*选择排序*在排序前就需要知道所有待排序元素，然而*插入排序*就不必。

## 常见问题

- **_为什么在光线追踪中没有透视矩阵？_**

  在*z-buffer 方法*中存在透视矩阵，因为透视矩阵能将透视投影转换成平行投影。在光线追踪中不需要这个功能，因为从眼睛发出光线，很容易就可以进行透视投影。

- **_光线追踪可以进行交互吗？_**

  对于足够小的图像和模型，现在计算机的性能已经足以实现交互式的光线追踪。在现实中，全屏实现光线追踪需要多个共享*帧缓冲区*的 CPU。现在计算机性能的提升远比屏幕分辨率的提升快，而传统 PC 能对复杂场景进行光线追踪也只是时间问题。

- **_光线追踪在硬件图形程序中有用吗？_**

  光线追踪通常用于 **_选取_** 。当用户在三维图形程序中点击鼠标时，程序需要判断在那个像素点位置到底哪个物体是可见的。光线追踪正是解决这个问题的最好选择。

# 第五章 线性代数

**在图形程序中，最常用且通用的应该是 _矩阵_ 了。矩阵可以改变或转换点和向量。下一章，我们会看到如何使用单列的矩阵表示一个向量，以及一个向量如何与一个方阵相乘，得到不同的 _基向量_ 。我们同时也会展示如何运用这样的矩阵乘法来完成对向量的各种操作：缩放、旋转和平移等。而在这一章，我们从几何的角度回顾线性代数的知识，并着重于直观地解释在二维和三维空间内的可用算法。**

**如果你线性代数基础不错，你可以跳过本章。然而，本章也有一些好康的东西，比如行列式的发展史、关于奇异值的讨论、以及特征值分解等。**

> 译者注：我默认你以及接受过高等教育并学过线性代数，下面仅做知识点脉络梳理。

## 5.1 行列式

我们常常认为行列式产生于对线性方程的求解，但是，在本书中，我们视为向量的相乘。对于二维向量 ${\rm\textbf{a}}$ 和 ${\rm\textbf{b}}$ ，行列式 $\vert{\rm\textbf{a}}{\rm\textbf{b}}\vert$ 是由两个向量构成的平行四边形的面积。这是一个有符号面积。当 ${\rm\textbf{a}}$ 和 ${\rm\textbf{b}}$ 符合右手螺旋定则时，行列式为正。同样的，若它们是三维向量 ${\rm\textbf{a}}$ ， ${\rm\textbf{b}}$ ， ${\rm\textbf{c}}$，行列式 $\vert{\rm\textbf{a}}{\rm\textbf{b}}{\rm\textbf{c}}\vert$
指的是这三个向量构成的平行六面体的体积。由此我们引出以下定律：

1. 行列式的行数乘：视为平行四边形的对侧边数乘
   $$\vert(k{\rm\textbf{a}}){\rm\textbf{b}}\vert = \vert{\rm\textbf{a}}(k{\rm\textbf{b}}) = k\vert{\rm\textbf{a}}{\rm\textbf{b}}\vert$$
2. 行列式的“高斯消元”：视为对平行四边形的剪切（类似于高相同进行切变）：
   $$\vert({\rm\textbf{a}}+k{\rm\textbf{b}}){\rm\textbf{b}}\vert = \vert{\rm\textbf{a}}({\rm\textbf{b}}+k{\rm\textbf{a}})\vert = \vert{\rm\textbf{a}}{\rm\textbf{b}}\vert$$
3. 行列式的某行拆分：
   $$\vert{\rm\textbf{a}}({\rm\textbf{b}}+{\rm\textbf{c}})\vert = \vert{\rm\textbf{a}}{\rm\textbf{b}}\vert+\vert{\rm\textbf{a}}{\rm\textbf{c}}\vert$$

## 5.2 矩阵

矩阵在计算机图形学中有多种用处，其中就包括表示空间变换。在我们的讨论中，我们假设矩阵的元素都是实数。本章会介绍矩阵运算的原理以及方阵所对应的行列式。

### 5.2.1 矩阵算术

1. 矩阵不含交换律：
   $${\rm\textbf{A}}{\rm\textbf{B}}\neq {\rm\textbf{BA}}$$
2. 矩阵具有结合律：
   $${\rm\textbf{(AB)C}} = {\rm\textbf{A(BC)}}$$
3. 矩阵具有分配律：
   $${\rm\textbf{A(B+C) = AB+AC}}$$

### 5.2.2 矩阵的运算操作

1. 矩阵的逆：
   $${\rm\textbf{AA}}^{-1}={\rm\textbf{I}}$$
2. 复合矩阵的逆：
   $$({\rm\textbf{AB}})^{-1} = {\rm\textbf{B}}^{-1}{\rm\textbf{A}}^{-1}$$
3. 矩阵的转置：对矩阵的元素而言，有：
   $$a_{ij} = a'_{ji}$$
4. 复合矩阵的转置：
   $$({\rm\textbf{AB}^T}) = {\rm\textbf{B}^T}{\rm\textbf{A}^T}$$
5. 复合/变换矩阵的行列式性质：
   $$\vert{\rm\textbf{AB}}\vert = \vert{\rm\textbf{A}}\vert\vert{\rm\textbf{B}}\vert$$
   $$\vert{\rm\textbf{A}^{-1}}\vert = \frac{1}{\vert{\rm\textbf{A}}\vert}$$
   $$\vert{\rm\textbf{A}^T}\vert=\vert{\rm\textbf{A}}\vert$$

### 5.2.3 矩阵形式的向量运算

1. 向量的左侧 _预乘_ (考研书上为：左行右列):

$$
\left [\begin{matrix}
0 & -1 \\
1 & 0
\end{matrix} \right] \left[\begin{matrix}
x \\
y
\end{matrix} \right] = \left[\begin{matrix}
-y \\
x
\end{matrix} \right]
$$

2. 将矩阵乘法视为向量乘法：

   例如，矩阵向量乘法 $y=Ax$ 的结果 $y$ 可以理解为一个向量，其中的元素就是 $x$ 与 $A$ 的点积。我们可以把矩阵 $A$ 分成三个行向量：

$$
\left[\begin{matrix} \vert\\\\ y\\\\ \vert \end{matrix} \right] = \left[\begin{matrix} - & r_1 & -\\\\ - & r_2 & -\\\\ - & r_3 & - \end{matrix} \right]  \left[\begin{matrix} \vert\\\\ X\\\\ \vert \end{matrix} \right]
$$

也就是

$$y_i = r_i\cdot X$$

### 5.2.4 特殊类型的矩阵

1. 单位矩阵

   单位矩阵是**对角矩阵**，也是**对称矩阵**，还是**正交矩阵**。

   > **正交矩阵**的性质：行向量/列向量彼此正交，且所有的正交矩阵的行列式都为 1 或-1。其中有一个很有用的性质是： ${\rm\textbf{R}^T}{\rm\textbf{R}} = I = {\rm\textbf{R}{\rm\textbf{R}^T}} \ (for\ orthongal \ {\rm\textbf{R}})$

## 5.3 使用行列式和矩阵进行运算

### 5.3.1 计算逆矩阵

行列式给予了我们计算逆矩阵的工具。对于大型矩阵，用行列式来计算逆矩阵是一种非常低效的方法，但在图形学中的矩阵通常很小。这种方法被开发出来是因为如果一个矩阵有两行完全相同或成比例，那么它所对应的行列式就为零。可以使用平行六面体的体积帮助理解。

计算逆矩阵使用的公式为：

$${\rm\textbf{A}^{-1}} = \frac{1}{\vert{\rm\textbf{A}}\vert}{\rm\textbf{A}^*}$$

> 译者注： ${\rm\textbf{A}^*}$ 指伴随矩阵。伴随矩阵的定义为：将该矩阵元素 $a_{ij}$ 所在行列划去，组成的矩阵称为余子式，将余子式乘 $(-1)^{i+j}$ ，称为代数余子式，记为 $A_{ij}$ ，将原矩阵的 $a_{ij}$ 用 $A_{ij}$ 替换，然后转置，即为伴随矩阵。别忘了，余子式是行列式，所以伴随矩阵和原矩阵具有相同的大小。

### 5.3.2 线性方程组

略。

## 5.4 特征值与矩阵的对角化

只有方阵才有特征值和对应的特征向量。一个非零向量与矩阵相乘，如果结果向量的方向不改变，就称其为特征向量，即：

$${\rm\textbf{Aa}} = \lambda{a}$$

如何求特征向量呢？ 我们可以通过上面的定义，将等式两边同乘单位阵：

$${\rm\textbf{Aa}} = {\lambda I a}$$

移项后，有：

$${\rm\textbf{Aa}}-{\lambda I a} = 0$$

即

$$({\rm\textbf{A}}-{\lambda I })a = 0$$

由于这可以看成一个齐次方程 ${\rm\textbf{A}}x=0$ ，所以当且仅当该方阵 **不满秩** 时（我们将行列式为 0 的矩阵称为*奇异矩阵*），该齐次方程组有非零解，也就是 **a** 。据此我们可以通过行列式为 0 解出特征值。

我们假设 ${\rm\textbf{A}}$ 是一个 $2\times2$ 的矩阵，那么我们可以通过下面的式子解出特征值：

$$
\left \vert\begin{matrix}
  a_{11}-\lambda & a_{12} \\
  a_{21} & a_{22}-\lambda
  \end{matrix} \right \vert  = \lambda^2-(a_{11}+a_{22})\lambda+(a_{11}a_{22}-a_{12}a_{21}) = 0
$$

这是一个二次方程，解可能相同可能不同，甚至可能不是实数。对 $n\times n$ 大小的矩阵，我们会得到一个 $\lambda$ 的 n 次多项式， $n > 4$ 时我们通常找不到解析解，只能寻找数值解。

特征值和特征向量在一个特例里会变得非常简单，那就是对称矩阵。（ ${\rm\textbf{A}}={\rm\textbf{A}^T}$ ）。 **实对称矩阵的特征值是实数** ，且 **实对称矩阵的不同特征值对应的特征向量相互正交** 。而且，这样的不同特征值的矩阵可以进行**对角化**：

$$ {\rm\textbf{A}} = {\rm\textbf{Q}}{\rm\textbf{D}}{\rm\textbf{Q}^T}$$

其中 ${\rm\textbf{Q}}$ 是正交矩阵， ${\rm\textbf{D}}$ 是对角矩阵。 ${\rm\textbf{Q}}$ 的列是 ${\rm\textbf{A}}$ 的特征向量。这样的操作也被称为 _特征值分解_ 。

### 5.4.1 奇异值分解

上一节我们看到了所有的对称矩阵都能进行对角化，或者分解为易于使用的正交矩阵和对角矩阵的乘积形式。但是，图形学中我们遇到的矩阵大多数都是不对称的，这会导致特征值分解很不方便且难以解决，同时也可能会包含复数特征值和特征向量。

> 注：我们建议你按这个顺序学习：特征值/特征向量，奇异值/奇异向量，然后再是非对称矩阵的特征值，因为它比较需要技巧。

我们将对称矩阵的特征值分解进行了一个推广，推广到了非对称（甚至可以不是方阵）：称作 **奇异值分解** 。这两种分解方式的区别在于，在奇异值分解中，左侧和右侧的正交矩阵不需要相同：

$${\rm\textbf{A}} = {\rm\textbf{U}}{\rm\textbf{S}}{\rm\textbf{V}^T}$$

上面的 ${\rm\textbf{U}}$ 和 ${\rm\textbf{V}}$ 是两个可能会不相同的正交矩阵。 ${\rm\textbf{U}}$ 和 ${\rm\textbf{V}}$ 的列向量分别是 _左奇异向量_ 和 _右奇异向量_ 。 ${\rm\textbf{S}}$ 是一个对角阵，元素是 ${\rm\textbf{A}}$ 的奇异值。当 ${\rm\textbf{A}}$ 对称，且所有特征值都非负，奇异值分解就是特征值分解。

这两者还有另外一种联系，可以用来计算奇异值分解（虽然达不到工业级的精度要求）。首先，我们定义 ${\rm\textbf{M}} =  {\rm\textbf{A}} {\rm\textbf{A}^T}$ ，然后我们可以假设对于矩阵 ${\rm\textbf{M}}$ ，可以进行奇异值分解：

$${\rm\textbf{M}}={\rm\textbf{A}}{\rm\textbf{A}^T} = ({\rm\textbf{U}}{\rm\textbf{S}}{\rm\textbf{V}^T})({\rm\textbf{U}}{\rm\textbf{S}}{\rm\textbf{V}^T}) = {\rm\textbf{U}}{\rm\textbf{S}}({\rm\textbf{V}^T}{\rm\textbf{V}}){\rm\textbf{S}}{\rm\textbf{U}^T} = {\rm\textbf{U}}{\rm\textbf{S}^2}{\rm\textbf{U}^T}$$

这个运算用到了穿脱法则，以及**正交矩阵的转置是其逆矩阵**。由于我们制造了矩阵 ${\rm\textbf{M}}$ ，它是一个对称矩阵，所以 ${\rm\textbf{U}}{\rm\textbf{S}^2}{\rm\textbf{U}^T}$ 是进行特征值分解的结果， ${\rm\textbf{S}^2}$ 包含了所有非负的特征值。因此，该矩阵的奇异值就是 ${\rm\textbf{A}}{\rm\textbf{A}^T}$ 的特征值的平方根，左奇异向量就是该乘积的特征向量，相应的右奇异向量需要从 ${\rm\textbf{A}^T}{\rm\textbf{A}}$ 中获得。

## 常见问题

- **_为什么矩阵乘法不是简单的同位置的元素相乘？_**

  虽然用同位置元素相乘来定义矩阵乘法非常好，但是在实践中不是很有用处。大多数矩阵是用来对列向量进行变换的，比如你在三维空间中，可能看到这样的式子：

  $${\rm\textbf{b}} = {\rm\textbf{M}}{\rm\textbf{a}}$$

  其中 ${\rm\textbf{M}}$ 是一个 $3\times 3$ 的矩阵， ${\rm\textbf{a}}$ 和 ${\rm\textbf{b}}$ 是向量。为了完成类似旋转等的几何操作， ${\rm\textbf{a}}$ 的三个元素必须都能通过某种运算最后放入 ${\rm\textbf{b}}$ 的三个值中。这就要求我们需要将 ${\rm\textbf{a}}$ 通过 ${\rm\textbf{M}}$ 进行行变换或列变换。将这样的变换矩阵组合起来，就可以使用一个复合矩阵 ${\rm\textbf{C}}$ 来进行变换：

  $${\rm\textbf{M}}_2({\rm\textbf{M}}_1{\rm\textbf{a}}) = ({\rm\textbf{M}}_2{\rm\textbf{M}}_1){\rm\textbf{a}} = {\rm\textbf{Ca}}$$

  同时，有些时候我们需要同时转换很多向量，这时矩阵的乘法就派上了用场。总之，矩阵乘法之所以这样设计，是因为有相应的需求在。

- **_有些时候我听说特征值和奇异值是一个东西，但有些时候奇异值又是特征值的开方，到底哪个是对的呢？_**

  如果实矩阵 ${\rm\textbf{A}}$ 是对称的，而且它的特征值是非负的，那么特征值就是奇异值。如果 ${\rm\textbf{A}}$ 不对称，那么 ${\rm\textbf{M}} = {\rm\textbf{AA}^T}$ 是对称的，且具有非负的特征值。这个时候 ${\rm\textbf{A}}$ 和 ${\rm\textbf{A}^T}$ 的奇异值相同，且它的奇异值就是 ${\rm\textbf{M}}$ 的奇异值（ ${\rm\textbf{M}}$ 对称，所以也叫特征值）的开方。所以，当我们谈到平方根时，做的是人为制造了一个对称矩阵 ${\rm\textbf{M}}$ ，便于求奇异值。
