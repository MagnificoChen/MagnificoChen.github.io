# 第六章 变换矩阵

**线性代数的原理可以用来在三维场景中排列对象、使用相机查看对象，并且能让对象显示在屏幕上。像旋转、平移、缩放、投影这样的 _几何变换_ 可以使用矩阵乘法解决，而这章的主题就是实现这些操作用到的 _变换矩阵_ 。**

**我们会展示对于 “以原点出发的向量” 这样的方式来表示的一组点该如何进行变换，然后我们会使用图 6.1 所示的时钟图片来向你直观的进行展示。你只需要把这章时钟的图想象成由一组点组成即可，这些点是向量的终点，原点是向量的起点。我们同样也会讨论以下的这些变换对位置（点）、位移向量、以及表面法向量会产生什么样的作用。**

## 6.1 二维线性变换

我们可以使用 $2\times2$ 的矩阵来对一个二维向量进行变换

$$
\left [\begin{matrix}
  a_{11} & a_{12} \\
  a_{21} & a_{22}
\end{matrix} \right]\left[\begin{matrix}
  x \\
  y
\end{matrix} \right] = \left[\begin{matrix}
  a_{11}x+a_{12}y \\
  a_{21}x+a_{22}y
\end{matrix} \right]
$$

这种变换接收一个二维向量作为输入，通过简单的矩阵乘法生成另外一个二维向量输出，称为 **线性变换** 。

这是一个简单的公式，通过这个操作我们可以实现各种各样的转换，这取决于我们在矩阵里面输入什么内容。目前来说，我们要康康如何沿着 $x$ 和 $y$ 轴进行移动。

### 6.1.1 缩放

最简单的变换是沿坐标轴 **缩放** 。这种变换可以改变长度，有时也会改变方向：

$$
scale \ (s_x,s_y) =  \left [ \begin{matrix}
    s_x & 0 \\
    0 & s_y\\
    \end{matrix} \right]
$$

此矩阵有对笛卡尔分量的 $(x,y)$ 作用：

$$
\left [ \begin{matrix}
    s_x & 0 \\
    0 & s_y\\
    \end{matrix} \right]  \left[\begin{matrix}
    x \\
    y\\
    \end{matrix} \right]   = \left[\begin{matrix}
    s_xx \\
    s_yy \\
    \end{matrix} \right]
$$

所以，从上述公式里我们可以得知两个缩放系数。 $s_x$ 是对 x 轴的缩放系数， $s_y$ 是对 y 轴的缩放系数。所以，下面的矩阵能将原图片等比缩小成原来的四分之一：

$$
scale \ (0.5,0.5) =  \left [ \begin{matrix}
    0.5 & 0 \\
    0 & 0.5\\
    \end{matrix} \right]
$$

### 6.1.2 切变

切变是一种把东西推到一边的变换。它能产生的效果就像用手推一副扑克牌，让他变得倾斜。水平和垂直方向的切变如下所示：

$$
shear \ x(s) =  \left [ \begin{matrix}
    1 & s \\
    0 & 1\\
    \end{matrix} \right] , shear \ y(s) =  \left [ \begin{matrix}
    1 & 0    \\
    s & 1\\
    \end{matrix} \right]
$$

另一种理解切变的方法是只旋转水平/垂直轴。切变将 $y$ 轴顺时针旋转 $\phi$ 度的变换矩阵是：

$$
\left [ \begin{matrix}
    1 & \tan\phi \\
    0 & 1\\
    \end{matrix} \right]
$$

相似的，将 $x$ 轴 _逆时针_ 旋转 $\phi$ 度的变换矩阵是：

$$
\left [ \begin{matrix}
    1 & 0 \\
    \tan\phi & 1\\
    \end{matrix} \right]
$$

### 6.1.3 旋转

假设我们想将一个向量 $\rm\textbf{a}$ _逆时针_ 旋转 $\phi$ 度，得到向量 $\rm\textbf{b}$ ，假设向量 $\rm\textbf{a}$ 与 $x$ 轴成 $\alpha$ 度角，长度是 $r=\sqrt{x_a^2+y_a^2}$ 那么我们可以得到极坐标形式：

$$x_a = r\cos\alpha$$
$$y_a = r\sin\alpha$$

由于 $\rm\textbf{b}$ 仅是 $\rm\textbf{a}$ 旋转，所以长度也是 $r$ ，由于是旋转了 $\phi$ 度，所以使用三角函数的加法，能得到：

$$x_b = r\cos(\alpha+\phi) = r\cos\alpha\cos\phi-r\sin\alpha\sin\phi$$
$$y_b = r\sin(\alpha+\phi) = r\sin\alpha\cos\phi+r\cos\alpha\sin\phi$$

使用 $\rm\textbf{a}$ 的两个分量做替换，有：

$$x_b = x_a\cos\phi-y_a\sin\phi$$
$$y_b = y_a\cos\phi+x_a\sin\phi$$

则我们可以使用矩阵形式来表达，即

$$
rotate \ (\phi) =  \left [ \begin{matrix}
    \cos\phi & -\sin\phi \\
    \sin\phi & \cos\phi\\
    \end{matrix} \right]
$$

请注意， $\phi$ 指的是 **逆时针** 旋转的角度，若需要顺时针旋转，需要添加一个负号。

另外，由于三角函数具有 $\sin^2\phi+\cos^2\phi = 1$ 的特性，而且在这个矩阵中，每行每列都是**正交**的，所以我们能得到，这个变换矩阵是 **正交矩阵** ：这个矩阵的两列分别是对标准正交基向量 $(1,0)$ 和 $(0,1)$ 的变换，同时，两行则是*发送到*标准正交基向量的变换。

### 6.1.4 反射

我们可以通过设置一个负值的缩放系数来完成对坐标轴的反射变换（对称变换），见图 6.8，图 6.9：

$$
reflect \ -x =  \left [ \begin{matrix}
    1 & 0 \\
    0 & -1\\
    \end{matrix} \right], \ reflect \ -y =  \left [ \begin{matrix}
    -1 & 0 \\
    0 & 1\\
    \end{matrix} \right]
$$

有些人可能会认为，将矩阵对角线上的所有元素添一个负值也是一个反射变换，但其实它只是一个 $\pi$ 角度的 **旋转变换**。

> 有时上面这种变换也称作：关于原点进行反射变换。

### 6.1.5 变换的组合和分解

图像程序通常都有需要将一个物体进行多次变换。比如，我们可能先对向量 $\rm\textbf{v}_1$ 进行一个缩放变换 $\rm\textbf{S}$ ，然后进行一个旋转变换 $\rm\textbf{R}$ 。这就需要两部来完成:

$$\rm\textbf{v}_2 = \rm\textbf{Sv}_1, \ \rm\textbf{v}_3 = \rm\textbf{Rv}_2$$

也就是

$$\rm\textbf{v}_3 = \rm\textbf{RSv}_1$$

根据结合律，我们可以让 $\rm\textbf{R}$ 和 $\rm\textbf{S}$ 先乘。但请记住，越靠近 $\rm\textbf{v}_1$ 的矩阵越先被施加效果。

实际中，用旋转和缩放来进行变换已经可以覆盖所有的 _线性变换_ 。这一点很重要，下一节我们会着重讨论。

### 6.1.6 变换的分解

有时，有必要“撤消”转换的组合，将转换分解为更简单的部分。比如，在向用户展示变换的过程时，对单独的旋转和缩放系数进行操作是很有好处的，但往往一整个变换过程被简单的整合在了一个矩阵的内部，旋转变换和缩放变换被混合在一起，会变得不好理解。如果可以通过计算将变换矩阵分解为所需的部分，调整此部分，然后将调整后的片段再次相乘来重新组装成矩阵，就可以实现这样的操作。

​ 事实证明，无论矩阵中的元素是什么，这种分解（或者说因式分解）都是可能被实现的。它提供了一种有用的方式来思考变换，以及变换对几何体的影响。

#### 对称特征值分解

我们首先来看对称矩阵。回忆 5.4 节所学内容，所有的实对称矩阵都可以通过特征值分解进行对角化。如下例：

$${\rm\textbf{A}} =  \rm\textbf{RSR}^T$$

其中 $\rm\textbf{R}$ 是正交矩阵， $\rm\textbf{S}$ 是对角矩阵，我们将使用 $\rm\textbf{v}_1$ 和 $\rm\textbf{v}_2$ 来表示 $\rm\textbf{R}$ 的列向量（特征向量），用 $\rm\lambda_1$ 和 $\rm\lambda_2$ 来表示特征值（对角矩阵的对角线值）。

让我们以几何方面来重新审视以下上面的矩阵乘法：现在我们可以将 $\rm\textbf{R}$ 视为旋转， $\rm\textbf{S}$ 视为缩放，把整个式子看成是组合的变换（图 6.13）：

1. 将 ${\rm\textbf{v}}_1$ 和 ${\rm\textbf{v}}_2$ 旋转到 x 轴和 y 轴（ ${\rm\textbf{R}^T}$ 的效果）
2. 使用 $(\lambda_1,\lambda_2)$ 来缩放 x 和 y。（ ${\rm\textbf{S}}$ 的效果）
3. 将 x 轴和 y 轴转回 ${\rm\textbf{v}}_1$ 和 ${\rm\textbf{v}}_2$ 处。（ ${\rm\textbf{R}}$ 的效果）

我们观察这三种变换叠加在一起的效果，能发现它们具有沿着一个对称轴进行不均匀缩放的效果。和沿着坐标轴近似下缩放类似，图形的对称轴是垂直的，但它们并不是 x y 轴，而是矩阵 ${\rm\textbf{A}}$ 的特征向量。这就告诉了我们：对称矩阵只是进行了一个缩放操作，尽管这个缩放不是均匀的，也不关于坐标轴对称。

让我们看下面的例子：将下面的矩阵进行特征值分解：

$$
\left [ \begin{matrix}
    2 & 1 \\
    1 & 1\\
    \end{matrix} \right] = {\rm\textbf{R}}\left [ \begin{matrix}
    \lambda_1 & 0 \\
    0 & \lambda_2 \\
    \end{matrix} \right]{\rm\textbf{R}^T}
$$

$$
= \left [ \begin{matrix}
    0.8507 & -0.5257 \\
    0.5257 & 0.8507 \\
    \end{matrix} \right] \left [ \begin{matrix}
    2.618 & 0 \\
    0 & 0.382\\
    \end{matrix} \right]\left [ \begin{matrix}
    0.8507 & 0.5257 \\
    -0.5257 & 0.8507 \\
    \end{matrix} \right]
$$

$$ = \rm rotate(31.7\degree) \ scale(2.618,0.382) \ rotate(-31.7\degree)$$

我们应该记住，这是一个对称矩阵，因为我们是采用对称特征值分解来构造解决这个问题的。

#### 奇异值分解

我们在 5.4.1 节也讲过，奇异值分解（SVD）主要用于非对称矩阵的分解，区别在于中间的对角阵两边的矩阵不再是一样的：

$${\rm\textbf{A}} = {\rm\textbf{U}}{\rm\textbf{S}}{\rm\textbf{V}^T}$$

替换掉 ${\rm\textbf{R}}$ 的两个正交矩阵分别是 ${\rm\textbf{U}}$ 和 ${\rm\textbf{V}}$ ，我们将它们的列向量分别称作 ${\rm\textbf{u}_i}$ 和 ${\rm\textbf{v}_i}$ 。在这种情况下， ${\rm\textbf{S}}$ 的对角线元素被称作 **奇异值** 而不是特征值。它的几何描述和对称特征值分解很相似：

1. 将 ${\rm\textbf{v}}_1$ 和 ${\rm\textbf{v}}_2$ 旋转到 x 轴和 y 轴（ ${\rm\textbf{V}^T}$ 的效果）
2. 使用 $(\sigma_1,\sigma_2)$ 来缩放 x 和 y。（ ${\rm\textbf{S}}$ 的效果）
3. 将 x 轴和 y 轴转回 ${\rm\textbf{u}}_1$ 和 ${\rm\textbf{u}}_2$ 处。（ ${\rm\textbf{U}}$ 的效果）

区别在于两个正交矩阵以及旋转过程中。由于奇异值分解会得到两边不同的奇异向量，我们就没有必要得到 _负奇异值_ ，只需要将出现负号的奇异值改正号，然后 **将对应的奇异向量反转方向** 即可。正因为此，奇异值分解总能产生一个正项的对角阵。但矩阵 ${\rm\textbf{U}}$ 和 ${\rm\textbf{V}}$ 并不一定是旋转变换——它可能包含了反射变换。在图形学的几何应用程序中，这一点是一个小问题，不太方便：我们可以通过行列式来区分旋转和反射变换，如果行列式是 +1 ，说明这个变换是一个旋转变换，但如果是反射变换，行列式值是 -1 。如果同时需要旋转，其中一个奇异值可以取反，从而产生旋转-缩放-旋转的效果，此时反射是隐藏在缩放变换中，而不是在旋转变换中。

奇异值分解存在的好处是，我们所看到的**所有**二维变换矩阵**都可以由旋转矩阵和缩放矩阵构成**。切变矩阵是很方便，但组合变换时它不是必需的。

总之，每个矩阵都可以通过 **SVD** 分解为 一个 **旋转矩阵** 乘一个 **缩放矩阵** 再乘另一个 **旋转矩阵** 。只有对称矩阵可以通过特征值对角化分解为 **旋转矩阵** 乘以 **缩放矩阵** ，再乘以 **逆旋转矩阵** ，并且是可以在任意方向上的进行的简单缩放。而对于不对称矩阵的奇异值分解，将通过稍微复杂一点的代数操作，产生与特征值分解相同的三个矩阵的乘积形式。

#### 旋转矩阵的 Paeth 分解

还存在另外一种分解方式：它的作用是即将旋转操作分解为三个切变操作（Paeth，1990），操作如下：

$$
\left [ \begin{matrix}
    \cos\phi & -\sin\phi \\
    \sin\phi & \cos\phi\\
    \end{matrix} \right ] = \left [ \begin{matrix}
    1 & \frac{\cos\phi - 1}{\sin\phi} \\
    0 & -1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & 0 \\
    \sin\phi & -1 \\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & \frac{\cos\phi-1}{\sin\phi} \\
    0 & -1\\
    \end{matrix} \right ]
$$

这样的变换对 _光栅旋转_ 很有用。因为切变是一种效率非常高的图像光栅操作，它虽然会造成一些锯齿，但不会留下孔洞。一个很好的例子是：如果光栅位置是 $(i,j)$ ，我们施加一个水平的切变，就能得到：

$$
\left [ \begin{matrix}
    1 & s \\
    0 & 1\\
    \end{matrix} \right] \left [ \begin{matrix}
    i \\
    j \\
    \end{matrix} \right] = \left [ \begin{matrix}
    i+sj \\
    j \\
    \end{matrix} \right]
$$

如果我们将 $sj$ 舍入到最近的整数，这就相当于将图像的每一行进行横向移动，但行与行的移动量不同。但行内移动量是相同的，这就让我们能够对图像进行无缝旋转。同样的，垂直的切变也是如此，所以通过切变我们可以轻松实现简单光栅旋转。

## 6.2 三维线性变换

三维线性变换就是二维变换的拓展。例如，笛卡尔坐标系中沿轴缩放为：

$$
scale(a_x,a_y,a_z) = \left [ \begin{matrix}
    s_x & 0 & 0 \\
    0 & s_y & 0 \\
    0 & 0 & s_z \\
    \end{matrix} \right]
$$

但旋转就比二维要复杂多了。这里，我们希望简单的沿着 $z$ 轴旋转，所以只改变 $x$ 和 $y$ 的坐标，我们就可以用二维旋转矩阵：

$$
\rm rotate_z(\phi) = \left [ \begin{matrix}
    \cos\phi & -\sin\phi & 0 \\
    \sin\phi & \cos\phi & 0 \\
    0 & 0 & 1 \\
    \end{matrix} \right]
$$

同样我们可以很容易得到沿着 $x$ 轴和 $y$ 轴的旋转矩阵：

$$
\rm rotate_x(\phi) = \left [ \begin{matrix}
    1 & 0 & 0 \\
    0 & \cos\phi & -\sin\phi \\
    0 & \sin\phi & \cos\phi \\
    \end{matrix} \right]
$$

$$
\rm rotate_y(\phi) = \left [ \begin{matrix}
    \cos\phi & 0 &  \sin\phi\\
    0 & 1 & 0 \\
    -\sin\phi & 0 & \cos\phi \\
    \end{matrix} \right]
$$

为什么 $y$ 轴的旋转矩阵看上去好像反了？我们下一节将会讨论，同时讨论对任意轴的旋转。

和二维一样，我们可以对特定的轴进行切变：

$$
\rm shear_x(d_y,d_z) = \left [ \begin{matrix}
    1 & d_y &  d_z\\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
    \end{matrix} \right]
$$

同样的，和二维一样，所有三维的变换矩阵都可以使用奇异值分解来分解成旋转-缩放-旋转的组合。所有对称的三维矩阵都可以使用特征值分解来分解成旋转-缩放-转回的组合，最后，旋转矩阵同样可以表示成三维切变矩阵的乘积。

### 6.2.1 任意三维旋转

和二维一样，三维旋转矩阵也是 **正交矩阵** 。在几何上来说，这意味着矩阵的三个行向量是三个正交单位向量，列向量是三个可能不同的正交单位向量，让我们写下如下的矩阵：

$$
{\rm\textbf{R}}_{uvw} = \left [ \begin{matrix}
    x_u & y_u & z_u\\
    x_v & y_v & z_v \\
    x_w & y_w & z_w \\
    \end{matrix} \right ]
$$

在这里， ${\rm\textbf{u}} = x_u{\rm\textbf{x}}+y_u{\rm\textbf{y}}+z_u{\rm\textbf{z}}$， ${\rm\textbf{v}}$ 和 ${\rm\textbf{w}}$ 也是如此。由于这些向量是正交单位化的，所以：

$${\rm\textbf{u}}\cdot {\rm\textbf{u}} = {\rm\textbf{v}}\cdot {\rm\textbf{v}} = {\rm\textbf{w}}\cdot {\rm\textbf{w}} = 1$$

$${\rm\textbf{u}}\cdot {\rm\textbf{v}} = {\rm\textbf{v}}\cdot {\rm\textbf{w}} = {\rm\textbf{w}}\cdot {\rm\textbf{u}} = 0$$

通过将旋转矩阵作用于 ${\rm\textbf{u}}$ , ${\rm\textbf{v}}$ , ${\rm\textbf{w}}$ ，我们可以推断出矩阵的行为，例如：

$$
{\rm\textbf{R}}_{uvw}{\rm\textbf{u}} = \left [ \begin{matrix}
    x_u & y_u & z_u \\
    x_v & y_v & z_v \\
    x_w & y_w & z_w \\
    \end{matrix} \right ] \left [ \begin{matrix}
    x_u \\
    y_u \\
    z_u \\
    \end{matrix} \right ]  = \left [ \begin{matrix}
    x_ux_u+ y_uy_u +z_uz_u\\
    x_vx_u+y_vy_u+z_vz_u \\
    x_wx_u+y_wy_u+z_wz_u \\
    \end{matrix} \right]
$$

注意 ${\rm\textbf{R}}_{uvw} {\rm\textbf{u}}$ 的三行都是点乘积，所以我们得到：

$$
{\rm\textbf{R}}_{uvw}{\rm\textbf{u}} = \left [ \begin{matrix}
    {\rm\textbf{u}}\cdot {\rm\textbf{u}}\\
    {\rm\textbf{v}}\cdot {\rm\textbf{u}} \\
    {\rm\textbf{w}}\cdot {\rm\textbf{u}} \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    1 \\
    0\\
    0 \\
    \end{matrix} \right] = {\rm\textbf{x}}
$$

类似的，可以算出 ${\rm\textbf{R}}\{uvw\}{\textbf{v}}={\textbf{y}} , {\textbf{R}}\{uvw\}{\textbf{w}}={\textbf{z}}.$ 所以我们可以通过在向量左边乘上 ${\rm\textbf{R}}\{uvw\}$ 这个矩阵， ${\rm\textbf{R}}\{uvw\}$ 通过这个矩阵提供的旋转变换将 $u, v, w$ 旋转到对应的 $x, y, z$ 坐标轴上。

如果 ${{\rm\textbf{R}}\{uvw\}}$ 是一个有正交行向量的旋转矩阵，那么 ${\rm\textbf{R}}^T\{uvw\}$ 就是带有正交列向量的旋转矩阵，其实这个矩阵就是原矩阵的逆矩阵（正交矩阵的性质）。重要的一点是，对于变换矩阵来说，对于矩阵取逆（代数逆）就是对于图形的变化取逆过程（几何逆）。也就是说，如果 ${\rm\textbf{R}}\{uvw\}$ 将 ${\rm\textbf{u}}$ 转向了 $\rm x$ ，那么 ${\rm\textbf{R}}^T\{uvw\}$ 就会将 $\rm x$ 转回 ${\rm\textbf{u}}$ 。对于 ${\rm\textbf{v}}$ 和 $\rm y$ 也一样。所以 **我们总是可以通过正交基来创建旋转矩阵。**

如果我们想要绕着一个任意向量 ${\rm\textbf{a}}$ 旋转，我们可以构建一个 ${\rm\textbf{w}}={\rm\textbf{a}}$ 的正交基 ，然后将这个正交基通过旋转变换到标准基坐标 ${\rm\textbf{xyz}}$ 下（也就是下面右乘的矩阵），然后绕 ${\rm\textbf{z}}$ 轴旋转（中间的矩阵），最后转回 ${\rm\textbf{uvw}}$ 坐标下（左边的矩阵）。用矩阵的形式表示，沿着 ${\rm\textbf{w}}$ 轴旋转 $\phi$ 角度的复合变换矩阵如下所示：

$$
\left [ \begin{matrix}
    x_u & x_v & x_w\\
    y_u & y_v & x_w\\
    z_u & z_v & x_w\\
    \end{matrix} \right ] \left [ \begin{matrix}
    \cos\phi & -\sin\phi & 0\\
    \sin\phi & \cos\phi & 0 \\
    0 & 0 & 1\\
    \end{matrix} \right ]  \left [ \begin{matrix}
    x_u & y_u & z_u\\
    x_v & y_v & z_v\\
    x_w & y_w & z_w\\
    \end{matrix} \right ]
$$

在这里我们给出了单位向量 ${\rm\textbf{w}}$ ，它是一个向着 ${\rm\textbf{a}}$ 方向的单位向量，那么 ${\rm\textbf{u}}$ 和 ${\rm\textbf{v}}$ 是什么呢？计算它们的方法已经在 2.4.6 节给出。

如果我们有一个旋转矩阵，然后希望由轴角的形式来进行旋转，我们可以计算一个实特征值（应该是 $\lambda = 1$ ），然后对应的特征向量就是旋转轴。这是一条不会因为旋转改变的轴。

除了旋转矩阵。还有一些表示旋转的常用方法，详见 16 章。

### 6.2.2 变换法向量

虽然大多数的三维向量我们用它用来表示位置（离原点的偏移）或表示方向，比如表示光的来源，但有些向量是用来表示表面法线的。表面法向量垂直于表面某点切平面。当变换曲面时，这些法向量并不会按照变换曲面的方式进行变换。比如，如果曲面上的所有点都被变换矩阵 ${\rm\textbf{M}}$ 进行了变换，那么与曲面相切的向量 ${\rm\textbf{t}}$ 在被 ${\rm\textbf{M}}$ 乘后就会与变换后的曲面相切。然而，法向量 ${\rm\textbf{n}}$ 被 ${\rm\textbf{M}}$ 乘后，不一定会垂直于变换后曲面的切平面，如图 6.17 所示。

我们可以计算一个变换矩阵 ${\rm\textbf{N}}$ ，这个矩阵将法向量 ${\rm\textbf{n}}$ 变为另外一个向量，而新向量将垂直于转换后的表面。那么怎么计算呢？ 一个方法是：注意到表面法向量和表面切向量是垂直的，因此它们的点积为 0：

$${\rm\textbf{n}^T}{\rm\textbf{t}} = 0$$

如果我们将转换后的向量记为 ${\rm\textbf{t}}_M =  {\rm\textbf{Mt}}$ ， ${\rm\textbf{n}}_N =  {\rm\textbf{Nn}}$ ，那么我们的目标是找到矩阵 ${\rm\textbf{N}}$ ，让 ${\rm\textbf{n}}_N^T {\rm\textbf{t}}_M = 0$ 。通过这个方程，我们可以用一些代数方面的小技巧来求解。首先，我们通过 ${\rm\textbf{I}}$ 的妙用，将上面的式子插入一个单位矩阵：

$${\rm\textbf{n}^T}{\rm\textbf{t}} = {\rm\textbf{n}^T}{\rm\textbf{It}}={\rm\textbf{n}^T}{\rm\textbf{M}^{-1}}{\rm\textbf{Mt}} = 0$$

然后，通过结合律：

$$({\rm\textbf{n}^T}{\rm\textbf{M}^{-1}})({\rm\textbf{Mt}}) = ({\rm\textbf{n}^T}{\rm\textbf{M}^{-1}}){\rm\textbf{t}}_M = 0$$

这意味着垂直于 ${\rm\textbf{t}}_M$ 的行向量正是上面括号内乘出来的向量。这个表达式适用于切平面中的任意切向量。由于在空间中只有一个向量（及其相反方向的向量）垂直于切平面，所以左边乘出来的那个行向量一定是 ${\rm\textbf{n}_N}$ ，也就是 ${\rm\textbf{n}_N^T}$ 。这就有了一个办法来推导 ${\rm\textbf{N}}$ ：

$${\rm\textbf{n}^T}_N = {\rm\textbf{n}^T}{\rm\textbf{M}^{-1},}$$

然后我们将其转置，得到：
$${\rm\textbf{n}_N} = ({\rm\textbf{n}^T}{\rm\textbf{M}^{-1}})^T = ({\rm\textbf{M}^{-1}})^T{\rm\textbf{n}}$$

因此，我们看到能够正确地变换法向量，让它变换后依然是法向量的矩阵是 ${\rm\textbf{N}} = ({\rm\textbf{M}^{-1})^T}$ ，也就是原矩阵取逆的转置。因为这个矩阵可能会改变 ${\rm\textbf{n}}$ 的长度，我们可以将该向量乘一个任意数，这样它能始终指向正确的方向。矩阵的逆是余子式矩阵的转置再除以该矩阵的行列式 _[5.3，行列式和矩阵]_ 。由于我们不关心法向量的长度，所以我们可以跳过矩阵的除法，最后得到，对于一个 $3\times 3$ 矩阵，

$$
{\rm\textbf{N}} = \left [ \begin{matrix}
    m^c_{11} & m^c_{12} & m^c_{13} \\
    m^c_{21} & m^c_{22} & m^c_{23} \\
    m^c_{31} & m^c_{32} & m^c_{33} \\
    \end{matrix} \right ]
$$

这里我们假设了 $m_{ij}$ 是矩阵 ${\rm\textbf{M}}$ 的第 $i$ 行第 $j$ 列的元素。最终我们得到 ${\rm\textbf{N}}$ 的完整表达式是：

$$
{\rm\textbf{N}} = \left [ \begin{matrix}
    m_{22}m_{33}-m_{23}m_{32} & m_{23}m_{31}-m_{21}m_{33} & m_{21}m_{32}-m_{22}m_{31} \\
    m_{13}m_{32}-m_{12}m_{33} & m_{1}m_{33}-m_{13}m_{31} & m_{12}m_{31}-m_{11}m_{32} \\
    m_{12}m_{23}-m_{13}m_{22} & m_{13}m_{21}-m_{11}m_{23} & m_{11}m_{22}-m_{12}m_{21} \\
    \end{matrix} \right ]
$$

## 6.3 平移和仿射变换

我们一直在研究如何使用矩阵 ${\rm\textbf{M}}$ 来给变换向量。在二维空间中，这些变换的形式为：

$$x' = m_{11}x+m_{12}y $$
$$y' = m*{21}x+m*{22}y $$

但我们不能使用这样的变换来 _移动_ 物体。只能进行缩放和旋转。尤其是原点 $(0,0)$ 在线性变换中永远保持不变。想要移动或平移（Translate）一个物体，使其所有的点都移动相同的量，我们需要下面这样的变换形式：

$$x' = x+x_t $$
$$y' = x+y_t $$

而通过将 $(x,y)$ 左乘一个 $2\times2$ 矩阵并不能实现这样的效果。将平移加到我们的线性变换系统的一个简单方法是将一个平移向量与每个变换矩阵 **关联** _(参见非线性方程组)_ ，让矩阵接管旋转缩放，向量来控制平移。这完全可行，但是使用这种方法的后续管理工作很麻烦，而且进行 **组合变换** 时，它们将不再变得清晰明了。

作为替代，我们可以使用一点小技巧，让一个单独的矩阵乘法能同时包含上述两种操作：将点坐标 $(x,y)$ 重新表示为一个三维向量 $[x,y,1]^T$ ，然后使用下面所示的 $3\times3$ 矩阵：

$$
\left [ \begin{matrix}
    m_{11} & m_{12} & x_t \\
    m_{21} & m_{22} & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ]
$$

第三行是固定的，用于将 1 固定到转换后向量的最后一个元素处。而该向量的前两个元素值分别就是关于原向量 $x, y$ 的线性组合：

$$
{\rm\textbf{N}} = \left [ \begin{matrix}
    x' \\
    y' \\
    1  \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    m_{11} & m_{12} & x_t \\
    m_{21} & m_{22} & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    x \\
    y \\
    1  \\
    \end{matrix} \right ]  = {\rm\textbf{N}} = \left [ \begin{matrix}
    m_{11}x+m_{12}y+x_t \\
    m_{21}x+m_{22}y+y_t \\
    1  \\
    \end{matrix} \right ]
$$

我们用单个矩阵就囊括了线性变换！这样的变换我们称作 **仿射变换** 。而这种通过增加一个维度来实现仿射变换的方法称作 **齐次坐标法（Roberts，1965；Riesenfield，1981；Penna&Patterson，1986）** 。齐次坐标不仅仅让实现变换的代码变得清晰明了，而且它让两个变换组合而成的组合变换变得清晰易懂。

但这种新方式也带来了一个问题：当我们需要变换一个不表示位置，只表示 **方向** 或偏移量的向量时，这个向量不应该被改变。而这时，解决办法就是将该向量的第三元素设置为 0：

$$
\left [ \begin{matrix}
    1 & 0 & x_t \\
    0 & 1 & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    x \\
    y \\
    0 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    x \\
    y \\
    0 \\
    \end{matrix} \right ]
$$

这样，我们对该向量做缩放/旋转变换，矩阵左上角的 $2\times 2$ 部分会作用于向量，但后面的平移将相乘得到 0 。此外，向量的第三元素在变换后仍然为 0 ，所以方向向量在变换后仍然为方向向量。

这正是我们想要的结果，所以平移变换可以通过这种方式完美融入该系统：指定额外元素是 0 或是 1 ，取决于我们想要对位置还是方向进行编码。我们需要这样的其次坐标来将位置向量和其他向量分开。如：

$$
\left [ \begin{matrix}
    3 \\
    2 \\
    1 \\
    \end{matrix} \right ] \ is \ a \ location \ , \ \left [ \begin{matrix}
    3 \\
    2 \\
    0 \\
    \end{matrix} \right ] is \ a \ displacement \ or \ direction
$$

过会儿我们讨论透视投影的时候，我们将会发现当该齐次坐标不采用 0 和 1 的时候用处会更大。

在图形系统中，齐次坐标几乎无处不在。而且，齐次坐标是图形硬件中设计和操作渲染器的基础。我们将在 _[第 7 章]_ 看到，齐次坐标使构建透视场景变得更容易。这也是它如此流行的原因。

齐次坐标可以当作一个存储平移变换的好方法。但对于几何方面的解释，有一种不同的说法。主要是，当我们在三维进行基于 z 轴的 _切变_ 时，也是下面这个形式：

$$
\left [ \begin{matrix}
    1 & 0 & x_t \\
    0 & 1 & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    x \\
    y \\
    z \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    x+x_tz \\
    y+y_tz \\
    z \\
    \end{matrix} \right ]
$$

这个样子和二维的平移变换就相差那么一丢丢。只不过这个切变多了一个 z ，z 在二维中没有意义。所以我们通过指定 $z=1$ ，就可以将平移变换用矩阵的形式使用了。比如：首先，在二维平面中移动 $(x_t,y_t)$ 的距离，然后旋转角度 $\phi$ ，就可以用下面的矩阵表示：

$$
{\rm\textbf{M}} = \left [ \begin{matrix}
    \cos\phi & -\sin\phi & 0 \\
    \sin\phi & \cos\phi & 0 \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & 0 & x_t \\
    0 & 1 & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ]
$$

别忘了，现在的二维旋转矩阵是 $3\times 3$ 了，而且在表示平移的那一列是 0 。通过这种矩阵规范，我们可以将任意数量的二维 **切变、旋转、平移** 组合到一个三维的矩阵中。这个三维矩阵的最后一行永远都是 $(0,0,1)$ ，因此我们其实没啥必要存储它，毕竟这样还能省点空间。只需要在进行计算的时候，我们把最后一行加上即可。

在三维空间中，这样的技巧同样适用，只需要添加第四维度即可，对于方向向量也一样，将第四个坐标设置为 0 就能让它不受平移的影响了。

### 重要例子

在图形学中，我们经常会需要构建变换矩阵。而且图像不一定在原点。如：构建一个变换矩阵，让这两个点 $[x_l,x_h]\times[y_l,y_h]$ 构成的矩形变换到 $[x_l',x_h']\times[y_l',y_h']$ 。此时，我们通过下面的步骤解决问题会更加直观：

1. 将 $(x_l,y_l)$ 移动到原点
2. 将矩形缩放到目标矩形的尺寸
3. 将原点移回到 $(x_l',y_l')$

别忘了右边的矩阵先产生作用。这样我们有：

$${\rm Windows} = {\rm translate}(x_l',y_l') \ {\rm scale}(\frac{x_h'-x_l'}{x_h-x_l},\frac{y_h'-y_l'}{y_h-y_l}) \ {\rm translate}(-x_l,-y_l)$$

$$
= \left [ \begin{matrix}
    1 & 0 & x_l' \\
    0 & 1 & y_l' \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    \frac{x_h'-x_l'}{x_h-x_l} & 0 & 0 \\
    0 & \frac{y_h'-y_l'}{y_h-y_l} & 0 \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & 0 & -x_l \\
    0 & 1 & -y_l \\
    0 & 0 & 1\\
    \end{matrix} \right ]
$$

$$
= \left [ \begin{matrix}
    \frac{x_h'-x_l'}{x_h-x_l} & 0 & \frac{x_l'x_h-x_h'x_l}{x_h-x_l} \\
    0 & \frac{y_h'-y_l'}{y_h-y_l} & \frac{y_l'y_h-y_h'y_l}{y_h-y_l} \\
    0 & 0 & 1\\
    \end{matrix} \right ]
$$

有一个重要的变换，可以构成一个类，叫 _刚体变换_ 。这种变换只由平移和旋转组成，因此它们不会对物体进行拉伸或收缩。

## 6.4 变换矩阵的逆

对于一个可逆矩阵，我们可以通过代数方法去求它的逆，同时，如果我们知道了几何逆干了甚么，我们也可以使用几何方法求逆。比如，缩放 $(s_x,s_y,s_z)$ 的逆是 $(1/s_x,1/s_y,1/s_z)$ 。而旋转 $\phi$ 角度的几何逆是旋转 $-\phi$ 角度，平移的逆过程是向相反方向平移。如果我们有一个复合变换矩阵 $\rm\textbf{M} = \rm\textbf{M}_1\textbf{M}_2\cdots\textbf{M}_n$ ，那么它的逆就是

$$\rm\textbf{M}^{-1} = \rm\textbf{M}_n^{-1}\textbf{M}_{n-1}^{-1}\cdots\textbf{M}_1^{-1}$$

同样的，对于确定类型的变换矩阵，求逆很容易。我们已经提到过缩放矩阵，它是对角阵，第二个重要的例子是旋转矩阵，它是正交矩阵。我们在 _[5.2.4 节]_ 说过，正交矩阵的逆矩阵就是它的转置。这个性质让它能很轻松的得到旋转的逆和刚体变换的逆。除此之外，如果一个矩阵的底部有 $[0 \ 0 \ 0 \ 1]$ ，那么这个矩阵的逆的底部也有 $[0 \ 0 \ 0 \ 1]$ 。

有趣的是，我们可以使用奇异值分解来对一个矩阵取逆。因为我们知道，所有的矩阵都可以被分解为旋转乘缩放再乘旋转，所以将它们取逆是很简单的。比如：在三维空间中，有：

$${\rm\textbf{M}} = {\rm\textbf{R}_1}\cdot {\rm scale}(\sigma_1,\sigma_2,\sigma_3)\cdot{\rm\textbf{R}_2}$$

根据穿脱法则，有：

$${\rm\textbf{M}^{-1}} = {\rm\textbf{R}_2^T \cdot{\rm scale}(\frac{1}{\sigma_1},\frac{1}{\sigma_2},\frac{1}{\sigma_3})}\cdot{\rm\textbf{R}_1^T}$$

只需要算出各个部分即可求逆。

## 6.5 坐标转换

前面讨论的所有内容都是在讲怎么通过变换矩阵来移动点。但我们也可以讲这个操作视为 **改变这个点所在的坐标系** 。例如，在 _[图 6.19]_ 中，我们看到了描述运动的两种方法。在不同的情况下，这两者中的其中一种会更适用。

比如，一个赛车游戏可能会有一个城市的模型和一个车辆的模型。如果游戏向玩家展示的是挡风玻璃外面的视角，那么车内的物体会始终绘制在屏幕的固定位置，同时当玩家开始驾驶时，街景和建筑物开始向后移动。每一帧上我们都会对窗外的事物进行一次变换，让他们相比于上一帧更远。实现这种效果的一种方法是简单地讲建筑物向后移动；另外一种方法则是建筑物不动，但改变我们生成视图的坐标系，让坐标系动起来。后面这种方法所作的变换是在改变城市几何体的坐标，并将城市几何体的坐标表示为车内的坐标。两种方法加在车辆外部几何体的变换矩阵在最后都是完全相同的。

如果这个游戏同样支持俯瞰视角，来让玩家看见车辆在城市中的位置的话，那么建筑和街景就需要在固定位置生成，车辆则需要一帧一帧的移动。正如上面所说的，也有两种方法可以使用。我们可以想象将汽车从世界坐标系的原位置移动到目标位置，或者可以想象这个过程是对车辆的几何体坐标的转换（这个坐标附着在车辆几何上），而不是让固定在城市的坐标系移动。这两种转换坐标的 **转换矩阵** 清楚的说明了两种模式（车相对于城市、城市相对于车）执行的变换 **互为逆矩阵** 。

改变坐标系的思想和编程中的 _类型转换_ 很相似。在我们能够让浮点数和整数相加之前，我们首先需要将整数转换为浮点数，让类型能够匹配。所以当我们一起生成汽车和城市之前，我们需要将车辆坐标转换为城市坐标，或者取决于我们的需要反着来，这样坐标才能匹配。

在管理多个坐标系的时候，会很容易混淆，最后让对象坐标错误，导致对象在不该出现的地方出现。但我们通过系统地思考坐标系之间的转换，我们可以得到准确的转换。

几何上来说，一个坐标系统（坐标框架）由一个 _原点_ 和一个 _基_ （三个向量组成的集合）构成。正交基非常方便，所以我们说到坐标系，如果没有另外说明，就假设它们是正交的。在一个原点为 ${\rm\textbf{p}}$ ，基是 $\{ {\rm\textbf{u,v,w}} \}$ 的坐标框架中，坐标 $(u,v,w)$ 这样表示：

$${\rm\textbf{p}}+u{\rm\textbf{u}}+v{\rm\textbf{v}}+w{\rm\textbf{w}}.$$

当我们在计算机中存储这些向量时，它们需要采用某种坐标系来进行表示。开始之前，我们要设计一些标准坐标系，通常称为 **全局坐标/世界坐标** ，用于表示和区分其他的坐标系。比如在我们上面说的这个城市里，我们可能会采用 _街道网格_ ，按照惯例将 $x$ 轴设定在主街道， $y$ 轴指向上方， $z$ 轴沿着中央大道。然后我们就能清晰的指定车辆坐标系的原点和基。

在二维平面，我们通常使用 ${\rm\textbf{o}}$ 作为原点， ${\rm\textbf{x}}$ 和 ${\rm\textbf{y}}$ 作为右手基向量。

> 注：在二维平面，“右手”是指从 ${\rm\textbf{x}}$ 开始逆时针到 ${\rm\textbf{y}}$ 。

但与此同时，可能会有另外一个坐标，使用 ${\rm\textbf{e}}$ 作为原点， ${\rm\textbf{u}}$ 和 ${\rm\textbf{v}}$ 作为基，这时请注意，标准坐标系不会被显式存储，因为它们作为别的坐标系的参考系。在该坐标系中， ${\rm\textbf{p}}$ 的位置就会被记为有序数对作为简写：

$${\rm\textbf{p}} = (x_p,y_p) = {\rm\textbf{o}}+x_p{\rm\textbf{x}}+y_p{\rm\textbf{y}}$$

下面来看 _[图 6.20]_ 的例子：在这里， $(x_p,y_p) = (2.5,0.9)$ ，注意这个坐标已经假定了坐标原点 ${\rm\textbf{o}}$ 。相似地，我们可以用另一个方程表示 ${\rm\textbf{p}}$ ：

$${\rm\textbf{p}} = (x_p,y_p) = {\rm\textbf{e}}+u_p{\rm\textbf{u}}+v_p{\rm\textbf{v}}$$

而在图中另外一个坐标系，这个点的坐标是 $(u_p,v_p) = (0.5,-0.7)$ 。同样，其他信息被省略了。

我们也可以用矩阵来表示同样的关系：

$$
\left [ \begin{matrix}
    x_p \\
    y_p \\
    1\\
    \end{matrix} \right ] = \left [ \begin{matrix}
    1 & 0 & x_e \\
    0 & 1 & y_e \\
    0 & 0 & 1 \\
    \end{matrix} \right ] \left [ \begin{matrix}
    x_u & x_v & 0 \\
    y_u & y_v & 0 \\
    0 & 0 & 1 \\
    \end{matrix} \right ]\left [ \begin{matrix}
    u_p \\
    v_p \\
    1\\
    \end{matrix} \right ]  = \left [ \begin{matrix}
    x_u & x_v & x_e \\
    y_u & y_v & y_e \\
    0 & 0 & 1 \\
    \end{matrix} \right ] \left [ \begin{matrix}
    u_p \\
    v_p \\
    1\\
    \end{matrix} \right ]
$$

值得注意的是，这里假设了我们将点 ${\rm\textbf{e}}$ 和向量 ${\rm\textbf{u}}$ 、 ${\rm\textbf{v}}$ 存储在了标准坐标系下，而该等式的第一项是默认了 $(x,y)$ 标准坐标系。根据我们在这一张讨论的变换基本类型，这是一个 **旋转变换** （涉及 ${\rm\textbf{u，v}}$ ），然后进行了一个 **平移变换** （涉及 ${\rm\textbf{e}}$ ）。让我们同时看旋转和平移矩阵，你会发现写下它们很容易：我们只需要将 ${\rm\textbf{u，v，e}}$ 放在这个矩阵的第 1，2，3 列，然后加上最后一行 $[0 \ 0 \ 1]$ 即可。如下：

$$
{\rm\textbf{p}}_{xy} = \left [ \begin{matrix}
    {\rm\textbf{u}} & {\rm\textbf{v}} & {\rm\textbf{e}} \\
    0 & 0 & 1 \\
    \end{matrix} \right ] {\rm\textbf{p}}_{uv}
$$

我们将这个矩阵称为 **_坐标框架-标准坐标矩阵_** 。它接收框架坐标 $(u,v)$ ，然后将它转换为标准坐标系下的坐标。

反过来，我们有：

$$
\left [ \begin{matrix}
    u_p \\
    v_p \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    x_u & y_u & 0 \\
    x_v & y_v & 0 \\
    0 & 0 & 1 \\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & 0 & -x_e \\
    0 & 1 & -y_e \\
    0 & 0 & 1 \\
    \end{matrix} \right ]\left [ \begin{matrix}
    x_p \\
    y_p \\
    1\\
    \end{matrix} \right ]
$$

这是一个先平移，后旋转的变换：也就是之前那个（先旋转再平移）的逆变换。当这两个变换矩阵相乘组合后，产生的矩阵正是上面那个矩阵（从坐标框架到标准坐标）的 **逆矩阵** 。也就是 **_标准坐标-坐标框架矩阵_** ：

$$
{\rm\textbf{p}}_{uv} = \left [ \begin{matrix}
    {\rm\textbf{u}} & {\rm\textbf{v}} & {\rm\textbf{e}} \\
    0 & 0 & 1 \\
    \end{matrix} \right ] ^{-1} {\rm\textbf{p}}_{xy}
$$

同样的，标准坐标-坐标框架矩阵接收一个标准坐标系的点，并将它转换为 $(u,v)$ 坐标系中的点。我们把这个矩阵简单的标了个逆，是因为它不能使用 ${\rm\textbf{e,u,v}}$ 的标准坐标立即写出来。但请记住，所有坐标系都是等效的，使用 $x$ 和 $y$ 来存储坐标只是我们的习惯，让它看上去不对等。标准坐标-坐标框架矩阵可以简单的表示为 ${\rm\textbf{o,x,y}}$ 的坐标：

$$
{\rm\textbf{p}}_{uv} = \left [ \begin{matrix}
    {\rm\textbf{x}}_{uv} & {\rm\textbf{y}}_{uv} & {\rm\textbf{o}}_{uv} \\
    0 & 0 & 1 \\
    \end{matrix} \right ]  {\rm\textbf{p}}_{xy}
$$

**以上的所有结论再三维空间均可用。**

## 常见问题

- **_我难道不能直接摁算摁编程，而不采用这种矩阵形式吗？_**

  当然可以。但实际上，这样做更难推导，更难 debug，效率也不高。而且，当下所有的图形 API 都采用了矩阵形式，你要是用图形库，就必须理解它。

- **_矩阵的底部永远是_** $[0 \ 0 \ 0 \ 1]$ ，**_那么我还要存储它吗？_**

  除非包含了**透视变换** _[第 7 章]_ ，否则不需要存储。

# 第七章 视图变换

**在上一章，我们见识了怎么使用矩阵工具来对二维或三维物体进行变换。几何变换的第二个重要内容是如何将物体在三维空间中移动，同时在二维视角中呈现这一内容。这种从三维到二维的变换称之为 _视图变换_ ，在以对象为顺序的渲染中起着重要作用。在这个过程中，我们需要快速的找到每个物体的图像-空间位置。**

**当我们在第四章学习光线追踪时，我们就介绍了不同种类的透视和正交视图；以及介绍了如何在任意视角生成视角光线。这一章的内容就是把这个过程反过来。在这里我们会解释如何使用矩阵变换来表示任意平行或透视视图。本章中的变换将场景（世界空间）的三维点投影到图像（图像空间）中的二维点上，并将给定像素的观察光线上的如何点投影回该像素在图像空间中的位置。**

**若你忘了之前将的内容，建议重新回顾 [第四章] 。**

**就其本身而言，将点从真实世界投影到图像上的能力仅适用于生成 _线框渲染_ ——仅绘制物体的边缘，而且较近的表面 _不会遮挡_ 较远的表面（见 _[图 7.1]_ ）。正如光线追踪需要找到离他最近的交点一样，显示物体实体外观的对象顺序渲染器必须分辨出多个曲面中哪个离屏幕最近，并仅显示该曲面。在这章中，我们假设我们绘制的图形仅包含 _三维线段_ ，并通过 $(x,y,z)$ 格式的两个端点进行表示。后面的章节才会讲到实体表面渲染所需的方法。**

## 7.1 视图变换

视图变换的工作是：将通过 $(x,y,z)$ 表示的三维坐标位置，转化为以像素为单位的图像。它很复杂，这取决于很多方面：相机的方向和位置、投影方法、可视角度、以及图像分辨率。我们在之前已经学到，复杂的变换可以分解为几个简单变换的叠加，视图变换也可以这样。大多数的图形系统使用下面三种变换序列来实现视图变换：

- **相机变换/眼睛变换** ：是一种 _刚体变换 [见 6.3 重要例子]_ ，它能将照相机以合适的朝向放在原点。它只能决定相机的 _位置和方向_ 或者说， _姿势_ 。
- **投影变换** ：它能将摄影机空间中投影点，让所有的点的 $x$ 和 $y$ 都落在 $[-1,1]$ 中。它只能决定 _所需要的投影类型_ 。
- **视口变换/窗口变换** ：它能将上面的单位图像矩阵映射到像素坐标。它只能决定 _图像输出的大小和位置_ 。

> 有些 API 只把 _相机变换_ 称作视图变换。

为了更好的描述这个变换过程（见图 7.2），我们给进行上述变换所使用的不同坐标系起了不同的名字。

相机变换将 **标准坐标** 中的点转换为 **相机坐标** ，而投影变换将那些点从 **相机坐标** 转换为 **标准视图坐标** ，最后，视口变换将 **标准视图坐标** 映射为 **屏幕空间** 。

上面那三个转换都是独立的，但非常简单。我们会先从 **正交投影** 的案例来讨论视口变换，然后讨论 **透视投影** 下的变换。

> 其他的名字：相机空间也叫眼睛空间；相机变换因此也会被叫做视图变换。标准视图坐标也叫做裁剪空间、标准化设备坐标；屏幕空间也叫做像素坐标。

### 7.1.1 视口变换

我们从一个例子开始，这个例子的解决方案将是通用的：

假设我们要观察的几何体是在 **标准视图空间** 中的，同时我们希望产生正交投影的相机的观察方向是 $-z$ 。 _标准立方体_ 包含了所有在 $x,y,z$ 的 $[-1,1]^3$ 范围内的所有点（见图 7.3）。我们将 $x=-1$ 投影在屏幕左边， $x=1$ 投影在屏幕右边， $y=-1$ 投影在屏幕底部， $y=1$ 投影在顶部。

> 标准 (Canonical) 这个词老是出现。我们选用这个词主要是因为它表述方便。比如标准圆 (Canonical Circle) 就的意思就是单位圆 (Unit Circle)。

请回忆一下第三章的知识，我们做了一个约定：每个像素都占有一块以 **整数坐标为中心的正方形区域** 。同时在图像的边界会相比像素中心超出一半像素的长度。最后，最小像素中心的坐标是 $(0,0)$ 。因此，如果我们需要绘制一幅像素为 $n_x\times n_y$ 的图像，那么我们需要将标准平面 $[-1,1]^2$ 映射到矩形 $[-0.5,n_x-0.5]\times [-0.5,n_y-0.5]$ 的区域上。

现在，我们假设所有需要绘制的线段都在 **标准立方体** 中。在之后我们讲到 _裁剪_ 的时候我们会放宽松这个假设。

> 注：将一个正方形映射到一个长方形并不是什么问题。我们只需要给 $x$ 和 $y$ 不同的缩放系数即可。

由于我们要进行的视口变换是将一个轴对齐的矩形映射到另外一个矩形，所以下面的公式是视口变换的一种形式：

$$
\left [ \begin{matrix}
    x_{\rm screen} \\
    y_{\rm screen} \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    \frac{n_x}{2} & 0 & \frac{n_x-1}{2} \\
    0 & \frac{n_y}{2} & \frac{n_y-1}{2} \\
    0 & 0 & 1 \\
    \end{matrix} \right ]  \left [ \begin{matrix}
    x_{\rm canonical} \\
    y_{\rm canonical} \\
    1 \\
    \end{matrix} \right ]
$$

请注意，这个矩阵忽略了标准立方体中的 $z$ 轴量。因为点沿投影方向的距离不会影响该点在图像中的投影位置。但是在我们正式称它为 _“视口矩阵”_ 之前，我们需要添加一行一列，以达到不改变 $z$ 的作用。尽管这一节我们不需要它，但最终 $z$ 值的存在是有必要的，（用于判断远近曲面的关系）。

所以，视口矩阵：

$$
{\rm\textbf{M}_{vp}} = \left [ \begin{matrix}
    \frac{n_x}{2} & 0 & 0 & \frac{n_x-1}{2} \\
    0 & \frac{n_y}{2} & 0 & \frac{n_y-1}{2} \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]
$$

### 7.1.2 投影变换：正交投影变换

**正交投影的步骤如下：**

1. **固定相机（相机变换）**
2. **把 $z$ 轴扔了**
3. **转换为标准正方形 $[-1,1]^2$ .**

一般情况下我们不希望在 **标准立方体** 之外的地方渲染几何体。我们要做的第一步是 在固定视角方向 (朝着 $-z$ 方向， $+y$ 在摄像机头顶) 的同时，能看到任意的矩形。我们不会替换视口矩阵，而是通过将其与右侧的另一个矩阵相乘来计算。

在这些约束条件下，视图空间是一个轴对齐的长方盒子，我们将这个盒子的不同面使用下面的方式命名： $[l,r]\times [b,t]\times [f,n]$ ，如 [图 4.7] 。我们将这个长方盒称作 **正交立方体** ，它的各个平面如下：

$$x=l \equiv \rm left \ plane $$
$$x=r \equiv \rm right \ plane $$
$$y=b \equiv \rm bottom \ plane $$
$$y=t \equiv \rm top \ plane $$
$$z=n \equiv \rm near \ plane $$
$$z=f \equiv \rm far \ plane $$

这些定义假定了观察者是往 $-z$ 轴方向看，头顶对着 $y$ 轴方向。

> 注：很多程序员发现， $x$ 轴指向右， $y$ 轴指向上是很有用的。在一个右手系中，这就表明了我们的视角方向是 $-z$ 轴。同时有一些系统采用左手系，那么视角方向就是 $z$ 轴方向。左手系的系统在文末有标明。

接上面，由于这样规定，所以我们默认 $n>f$ ，但是如果你假设了整个视图都在 $z<0$ 的区域，那么当且仅当 $n>f$ 时， $n$ 平面（近平面）才是真正的离观察者“近”。

上面这个概念在 [图 7.5] 中展示。从 **正交立方体** 变换到 **标准立方体** 的转换是另外一个转换。我们可以简单的将正交视图和标准视图的 **边界** 代入到 [6.3 重要例子] 中的方程中。这样我们可以得到该转换的矩阵：

$$
{\rm\textbf{M}_{orth}} = \left [ \begin{matrix}
    \frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l} \\
    0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\
    0 & 0 & \frac{2}{n-f} & -\frac{n+f}{n-f} \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]
$$

别忘了我们的目标是绘制三维线段。为了达成目标，我们需要将其投影到画面上，忽略 $z$ 坐标。我们通过将两个变换矩阵组合的方式来完成。注意，在程序中，我们先将这两个矩阵相乘，再进行下一步操作：

$$
\left [ \begin{matrix}
    x_{\rm pixel} \\
    y_{\rm pixel} \\
    z_{\rm canonical} \\
    1 \\
    \end{matrix} \right ] = ({\rm\textbf{M}_{vp}}{\rm\textbf{M}_{orth}})\left [ \begin{matrix}
    x \\
    y \\
    z \\
    1 \\
    \end{matrix} \right ]
$$

> 注：这就是使用矩阵进行变换能让程序变得简洁的奥秘！

这下子 $z$ 轴坐标就会在 $[-1,1]$ 中了。虽然我们现在没有使用这一点，但在后续的 _z-buffer 算法_ 中会很有用。

对于构造三维线段的伪代码，会变得简洁清爽：

```java
construct M_vp
construct M_orth

M = M_vp * M_orth

for each line segment(a_i,b_i) do{
    p = M * a_i;
    q = M * b_i;
    drawline(x_p,y_p,x_q,y_q);
}

```

### 7.1.3 相机变换

我们希望能够在三维空间中改变视角，让照相机能够看向任何方向。对于相机的位置和朝向，我们使用下面这种约定：

- 眼睛位置 **e**
- 注视方向 **g**
- 头顶方向向量 **t**

眼睛位置是指眼睛“从什么地方看”的位置。如果认为图形计算是一种摄影的过程，那么眼睛位置就是镜头的中心。注视方向是观察者注视方向的方向向量。头顶方向向量是平面中的任何向量。加入相机在地上，该向量将观察者的头部平分为左右两半，并让相机的顶部指向天空。这些向量为我们提供了足够的信息来以 $\rm\textbf{e}$ 为原点， $\rm\textbf{u,v,w}$ 为基建立一个坐标系。其中：

$$\rm\textbf{w} = -\frac{\textbf{g}}{\parallel \textbf{g} \parallel}$$
$$\rm\textbf{w} = -\frac{\textbf{t}\times \textbf{w}}{\parallel \textbf{t}\times \textbf{w} \parallel}$$
$$\rm\textbf{v} = \rm\textbf{w}\times \rm\textbf{u}$$

如果我们所希望变换的所有点都以上述坐标系（**e，uvw**）存储，那么就可以下班了！可是，正如 [图 7.7] 所示，模型坐标是存储在标准坐标系（**o，xyz**）中的。那么如果要让他们能够适配我们写好的这些计算过程，我们需要将绘制的线段端点的坐标从 $xyz$ 坐标系转化成 $uvw$ 坐标系中。这种转化方式在 [6.5 节] 中讨论过，实现这种变换的矩阵是相机坐标系的标准基矩阵：

$$
{\rm\textbf{M}_{cam}} = \left [ \begin{matrix}
    {\rm\textbf{u}} & {\rm\textbf{v}} & {\rm\textbf{w}} & {\rm\textbf{e}} \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]^{-1} = \left [ \begin{matrix}
    x_u & y_u & z_u & 0 \\
    x_v & y_v & z_v & 0 \\
    x_w & y_w & z_w & 0 \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]\left [ \begin{matrix}
    1 & 0 & 0 & -x_e \\
    0 & 1 & 0 & -y_e \\
    0 & 0 & 1 & -z_e \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]
$$

或者我们也可以把这种变换理解为：先将 ${\rm\textbf{e}}$ 移动到原点 ${\rm\textbf{o}}$ ，然后将 ${\rm\textbf{uvw}}$ 和 ${\rm\textbf{xyz}}$ 对齐。

> 译者注：有看不懂的吗？其实，我们可以想象这个变换是从标准坐标到相机坐标的逆过程。上面的矩阵取逆就是这个意思。而根据矩阵分块，只需对前 $3 \times 3$ 的矩阵取逆。巧了！这个矩阵因为是正交矩阵，所以转置就是它的逆，综上所述，得到了 ${\rm\textbf{M}_{cam}}$ 矩阵。

为了让我们这种算法（仅适用于 $z$ 轴方向观察）适用于任何方向的相机，我们只需要将这种相机变换添加到视口变换和投影变换的乘积中进行组合即可。这样可以在投影之前将原来的世界坐标转换为相机坐标。伪代码如下：

```java
construct M_vp
construct M_orth
construct M_cam
M = M_vp * M_orth * M_cam

for each line segment(a_i,b_i) do{
    p = M_ai
    q = M_bi
    drawline(x_p, y_p, x_q, y_q)
}
```

## 7.2 透视变换

单独出一章节足以显示它的重要性。透视投影需要一些小技巧，来让它匹配我们之前推理得出的向量和矩阵的变换系统。为了更好的理解我们需要做什么，先来看看透视变换需要在 _相机空间_ 中做什么工作。别忘了，视点是位于原点的，相机沿着 $z$ 轴进行观察。

> 注：这里是沿着 $z$ 轴方向，因为我们为了方程更简单忽略了 $z$ 值的正负。在 [7.3 透视投影] 中，我们会考虑正负。

透视图的关键特性在于屏幕上看到的物体大小与 $\frac{1}{z}$ 成正比（相机在原点，看向 $-z$ 轴方向）。这个现象可以用 [图 7.8] 中的方程表示。

$$y_s = \frac{d}{z}y$$

其中， $y$ 是该点的 $y$ 轴坐标， $y_s$ 是需要在屏幕上绘制的位置的 $y$ 值。

如果能够使用刚才我们研究出来的针对正交投影的一套系统，那么就可以将另外一个新的矩阵与之前的矩阵进行组合变换，然后使用已有的算法，那将是极好的。可惜换不得，这样的变换，输入坐标向量会出现在分母位置，所以不能使用 _仿射变换_ 来实现。

但我们可以通过在仿射变换中 **对齐次坐标的推广** 来允许这样的除法。我们已经可以使用 $[x \ y \ z \ 1]^T$ 这样的齐次向量来表示点 $(x,y,z)$ 。其中拓展位始终为 **1** ，这是由 $[0 \ 0 \ 0 \ w]^T \ (w=1)$ 作为仿射变换矩阵的最后一行来保证的。

更绝的是，我们没有必要让最后这个 $w$ 一定是 **1** 。而是可以将其定义为 $xyz$ 坐标的分母。这样，当齐次向量为 $[x \ y \ z \ w]^T$ 时，代表的就是点 $(\frac{x}{w},\frac{y}{w},\frac{z}{w})$ 。使用除了 **1** 以外的其他值可以允许更大的变换。

具体地说，线性变换允许我们计算像下面这样的表达式：

$$x' = ax + by + cz$$

仿射变换能将其拓展为：

$$x' = ax + by + cz+d$$

而让 $w$ 作为分母，增加了更多的可能性，可以让我们计算如下函数：

$$x' = \frac{ax + by + cz + d}{ex + fy + gz + h}$$

这就可以称作是关于 $x,y,z$ 的 **_线性有理函数_** 。但需要满足的一个条件是，所有坐标的分母都应该相同。

表示为矩阵变换，就是：

$$
\left [ \begin{matrix}
    \bar x \\
    \bar y \\
    \bar z \\
    \bar w \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    a_1 & b_1 & c_1 & d_1 \\
    a_2 & b_2 & c_2 & d_2 \\
    a_3 & b_3 & c_3 & d_3 \\
    e & f & g & h \\
    \end{matrix} \right ]\left [ \begin{matrix}
    x \\
    y \\
    z \\
     1 \\
    \end{matrix} \right ]
$$

以及：
$$(x',y',z') = (\frac{\bar x}{\bar w},\frac{\bar y}{\bar w},\frac{\bar z}{\bar w})$$

像这样的变换称为 **投影变换** 。

### 例子

下面的矩阵：

$$
\left [ \begin{matrix}
    2 & 0 & -1 \\
    0 & 3 & 0 \\
    0 & \frac{2}{3} & \frac{1}{3} \\
    \end{matrix} \right ]
$$

代表了一个二维投影变换，它能将单位正方形 $([0,1]\times [0,1])$ 转换为 [图 7.9] 中的梯形（透视变换后的形状）。

我们找一个点来具体看一下： $(1,0)$ 这个点，在计算的时候会被表示为 $[1 \ 0 \ 1 ]^T$ 。然后进行转换，如下：

$$
\left [ \begin{matrix}
    2 & 0 & -1 \\
    0 & 3 & 0 \\
    0 & \frac{2}{3} & \frac{1}{3} \\
    \end{matrix} \right ]\left [ \begin{matrix}
    1 \\
    0 \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    1 \\
    0 \\
    \frac{1}{3} \\
    \end{matrix} \right ]
$$

由于额外量 $w = \frac{1}{3}$ ，所以我们将它进行缩放后得到的点是 $(3,0)$ 。同样的，这个缩放过程可以通过在矩阵 $\rm\textbf{M}$ 前面乘上系数 $c$ 得到，这时得到的结果也会按照 $c$ 倍缩放，不会影响结果。

有一种更优雅的方式来表达相同的意思，它能避免处理额外值 $w$ 。这种方法在三维投影变换中只算是 _四维线性变换_ 。它额外规定了所有标量倍数都指向同一点：

$$\rm\textbf{x} \sim \alpha \textbf{x}$$

符号 $\sim$ 读作“等价于”，意思是两个齐次向量都描述了空间内的同一个点。

## 7.3 透视投影

**关于透视变换我们需要做的是：**

1. **将视锥“挤压”成长方体**
2. **做一次正交投影**

投影变换的机制让 **实现透视图所需要的除以 $z$ 步骤** 变得简单。如同 [图 7.8] 所示，我们可以用矩阵变换来实现透视投影，如下：

$$
\left [ \begin{matrix}
    y_s \\
    1 \\
    \end{matrix} \right ] \sim \left [ \begin{matrix}
    d & 0 & 0 \\
    0 & 1 & 0 \\
    \end{matrix} \right ]\left [ \begin{matrix}
    y \\
    z \\
    1 \\
    \end{matrix} \right ]
$$

这个变换的作用是将二维齐次向量 $[y \ z \ 1]^T$ 转化成一维齐次向量 $[dy \ z]^T$ 。也就是代表了一维（数轴）上的点 $(\frac{dy}{z})$ （这是因为化成齐次坐标后的第二个量是 **1** ，所以需要同除 $z$ ）。

对于三维的“标准的”透视投影，我们使用以往的惯例，让相机在原点，朝向 $-z$ 方向。与正交投影一样，我们也采用了相同的标记方式来标记近平面和远平面。在这一节中，我们将使用近平面作为投影平面，所以图像平面的距离是 $-n$ 。

> 别忘了 $n<0$ 。

然后，所需的映射是 $y_s = \frac{n}{z}y$ ，对于 $x$ 也是同样。那么这样的变换就可以写出矩阵形式：

> 为什么是这个式子？因为近平面上的长度是被“挤压”之后的， $x,y$ 会变成 $x',y'$ 。

所以，我们需要如下的变换：

$$
{\rm\textbf{M}_{persp\rarr orth}}\left [ \begin{matrix}
    x \\
    y \\
    z \\
    1 \\
    \end{matrix} \right ] \rArr \left [ \begin{matrix}
    \frac{nx }{z}\\
    \frac{ny }{z}\\
    ? \\
    \frac{1 }{z} \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    nx \\
    ny \\
    ? \\
    z \\
    \end{matrix} \right ]
$$

而且，我们观察到，在近平面上的点经过变换后，是不会变的：

$$
{\rm\textbf{M}_{persp\rarr orth}}\left [ \begin{matrix}
    x \\
    y \\
    n \\
    1 \\
    \end{matrix} \right ] \rArr \left [ \begin{matrix}
    x \\
    y \\
    n \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    nx \\
    ny \\
    n^2 \\
    n \\
    \end{matrix} \right ]
$$

再且，远平面中心在进行变换之后的点不变：而且，我们观察到，在近平面上的点经过变换后，是不会变的：

$$
{\rm\textbf{M}_{persp\rarr orth}}\left [ \begin{matrix}
    0 \\
    0 \\
    f \\
    1 \\
    \end{matrix} \right ] \rArr \left [ \begin{matrix}
    0 \\
    0 \\
    f \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
     0 \\
    0 \\
    f^2 \\
    f \\
    \end{matrix} \right ]
$$

根据矩阵乘法，我们得到下面的矩阵：

$$
{\rm\textbf{P}} = {\rm\textbf{M}_{persp\rarr orth}} =  \left [ \begin{matrix}
    n & 0 & 0 & 0 \\
    0 & n & 0 & 0 \\
    0 & 0 & n+f & -fn \\
    0 & 0 & 1 & 0 \\
    \end{matrix} \right ]
$$

第一、二、四行实现了透视方程的作用。第三行正如在正交变换和视口变换矩阵中的那样，是为了让 $z$ 值“上车”，以便之后使用 $z$ 值判断那些曲面被覆盖了不需要显示。然而，在透视投影中，我们添加了一个额外量的数乘，而不是常量，这会丢失原来的 $z$ 值——但实际上 $x,y$ 变了， $z$ 不可能不变。相反，在近平面和远平面上的点，我们选择保持 $z$ 值不变。

> 等会就讲到了，听我说你先别急。

有很多矩阵都可以用作透视矩阵，而它们无一例外都会非线性地扭曲 $z$ 坐标， [图 7.12] 和 [图 7.13] 的矩阵展现出了良好的特性：它能将 $z=n$ 这个平面（近平面）上的所有点留下不做处理，同时能够对 $z=f$ 这个平面（远平面）上的点在 $x$ 和 $y$ 维度上适当做“伸缩”处理。矩阵对该点的影响如下：

$$
{\rm\textbf{P}}\left [ \begin{matrix}
    x \\
    y \\
    z \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    nx \\
    ny \\
    (n+f)z-fn \\
    z \\
    \end{matrix} \right ] \sim \left [ \begin{matrix}
    \frac{nx}{z} \\
    \frac{ny}{z} \\
    n+f-\frac{fn}{z} \\
    1 \\
    \end{matrix} \right ]
$$

如你所见， $x$ 和 $y$ 是按照 $z$ 的比例来进行缩放的。因为 $n$ 和 $z$ 都是负值，所以 $x$ 和 $y$ 没有“翻转”。虽然不太明显，但这个变换保留了 $z=n$ 和 $z=f$ 之间的 $z$ 值的相对顺序，便于我们之后对 $z$ 进行深度排序，这是我们之后隐藏曲面所需要的重要信息。

有些时候我们会想要对矩阵 ${\rm\textbf{P}}$ 求逆。例如，当需要将屏幕坐标加上 $z$ 值，并转换回原始空间的时候。 ${\rm\textbf{P}}$ 的逆如下：

$$
{\rm\textbf{P}}^{-1} = \left [ \begin{matrix}
    \frac{1}{n} & 0 & 0 & 0 \\
    0 & \frac{1}{n} & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & -\frac{1}{fn} & \frac{n+f}{fn} \\
    \end{matrix} \right ]
$$

> 严格意义上来说这不是 ${\rm\textbf{P}}$ 的逆矩阵。但是这是 ${\rm\textbf{P}}$ 所表示的转换的逆操作。

齐次向量乘以标量不会影响它的意义。所以矩阵可以更好看一些：

$$
{\rm\textbf{P}}^{-1} = \left [ \begin{matrix}
    f & 0 & 0 & 0 \\
    0 & f & 0 & 0 \\
    0 & 0 & 0 & fn \\
    0 & 0 & -1 & n+f \\
    \end{matrix} \right ]
$$

回看我们讲过的正交投影矩阵 ${\rm\textbf{M}_{orth}}$ ，透视矩阵仅仅起到了将视锥体（被削了脑袋的金字塔状）映射到正交投影体（轴对齐的盒状）的功能。但透视矩阵的牛逼之处在于我们一使用它，就可以通过正交变换来得到 _标准立方体_ 。因此，所有的正交变换都适用，并且我们只是添加了一个矩阵和一个除以 $w$ 的操作而已。而且，我们没有浪费这个 $4\times 4$ 矩阵的最后一行！

将 ${\rm\textbf{P}}$ 和 ${\rm\textbf{M}_{orth}}$ 进行组合，就得到了 _透视投影矩阵_ 。

$${\rm\textbf{M}_{per}} = {\rm\textbf{M}_{orth}}{\rm\textbf{P}}$$

**但还有一个问题：** 如何确定透视图中的 $l,r,b,t$ ？它们定义了我们看到的窗口的大小。 **答案是：** 由于透视矩阵没有改变 $z=n$ 平面（近平面）的 $x,y$ 值，所以我们只需要通过该平面确定它们的值即可。

为了把这个透视矩阵整合到我们研究的 _正交结构_ 中去，我们只需要将原来的 ${\rm\textbf{M}_{orth}}$ 简单改为 ${\rm\textbf{M}_{per}}$ 即可。所以完整的透视投影一条龙服务矩阵是：

$${\rm\textbf{M}} = {\rm\textbf{M}_{vp}} {\rm\textbf{M}_{orth}} {\rm\textbf{P}}{\rm\textbf{M}_{cam}}$$

伪代码也很相似：

```java
construct M_vp
construct M_per
construct M_cam
M = M_vp * M_per * M_cam

for each line segment(a_i,b_i) do{
    p = M_ai
    q = M_bi
    drawline(x_p/w_p, y_p/w_p, x_q/w_q, y_q/w_q)
}
```

注意，除了附加矩阵有变化之外，还变了齐次坐标的除法因子 $w$ 。

乘出来之后的矩阵是这样的：

$$
{\rm\textbf{M}_{per} }= \left [ \begin{matrix}
    \frac{2n}{r-l} & 0 & \frac{l+r}{l-r} & 0 \\
    \\
    0 & \frac{2n}{t-b} & \frac{b+t}{b-t} & 0 \\
    \\
    0 & 0 & \frac{n+f}{n-f} & \frac{2fn}{f-n} \\
    \\
    0 & 0 & 1 & 0 \\
    \end{matrix} \right ]
$$

这种矩阵或类似的矩阵经常出现在文档中，当人们发现它们一般来说表示的是几个简单矩阵的乘积时，它们就不那么神秘了。

### 重要例子

许多 API，如 _OpenGL_ 使用与本文所示相同的视图立方体。它们通常还让用户指定 $n$ 和 $f$ 的绝对值。OpenGL 的投影矩阵是：

$$
{\rm\textbf{M}_{per} }= \left [ \begin{matrix}
    \frac{2|n|}{r-l} & 0 & \frac{l+r}{l-r} & 0 \\
    \\
    0 & \frac{2|n|}{t-b} & \frac{b+t}{b-t} & 0 \\
    \\
    0 & 0 & \frac{|n|+|f|}{|n|-|f|} & \frac{2|f||n|}{|f|-|n|} \\
    \\
    0 & 0 & -1 & 0 \\
    \end{matrix} \right ]
$$

其他的 API 通常将 $n$ 设置为 0， $f$ 设置为 1。 _Blinn_ 建议将规范视图体积设置为 $\left [ 0,1 \right ]^{3}$ 以提高效率。所有这些决策都会稍微改变投影矩阵的格式。

## 7.4 透视变换的一些性质

透视变换的一个重要性质是，它将线段转化成线段，平面转化成平面。此外，它将视图立方体中的线段转化成标准立方体中的线段。为了更好的理解，看下面这个线段：

$${\rm\textbf{q}}+t({\rm\textbf{Q}-\textbf{q}})$$

当它被一个 $4\times 4$ 矩阵 $\rm\textbf{M}$ 转换时，它还是一个齐次坐标的动点：

$${\rm\textbf{M}}{\rm\textbf{q}}+t({\rm\textbf{MQ}}-{\rm\textbf{Mq}}) \equiv {\rm\textbf{r}}+t({\rm\textbf{R}}-{\rm\textbf{r}})$$

因此，这个齐次化的点分布在：

$$\frac{{\rm\textbf{r}}+t({\rm\textbf{R}}-{\rm\textbf{r}})}{w_r+t(w_R-w_r)}$$

如果我们能把上面这个式子写成下面这样的形式：

$$\frac{{\rm\textbf{r}}}{w_r}+f(t) \left(\frac{{\rm\textbf{R}}}{w_R} -\frac{{\rm\textbf{r}}}{w_r} \right)$$

那么就能证明所有齐次化的点都在一条线段上。让我们摁解，得到下面这个形式：

$$f(t)=\frac{w_Rt}{w_r+t(w_R-w_r)}$$

结果表明，线段的映射依然是保留所有点顺序的线段。也就是，经过变换后，线段上的点并不会被重新排序或“撕裂”。

将线段转换为线段的一个副产品是，三角形进行变换时，边和顶点会转化成另外一个三角形的边和顶点。因此，三角形转换后仍是三角形，平面也依旧是平面。

## 7.5 视野（FoV）

尽管我们可以使用 $(l,r,b,t)$ 和 $n$ 来指定一个视窗，但有些时候我们会希望以一种更简单的方式描述它：从它的中心查看，这也意味着：

$$l=-r$$
$$b=-t$$

与此同时，如果我们添加了像素必须为正方形的规定，也就是图像中没有 _形状失真_ ，那么 $r$ 与 $t$ 的比率应该是和水平像素与垂直像素的比率相同。

$$\frac{n_x}{n_y} = \frac{r}{t}$$

当已经给出了 $n_x$ 和 $n_y$ 后，那么只有一个自由变量（离视窗的远近）了。我们通常使用 _视野 Fov_ ，单位为角度 $\theta$ 来描述。这有时也会被称为 _垂直视野_ 。用于区分这个角度到底是与左右相比产生的还是对角线相比产生的。由图可见，垂直视野是：

$$\tan \frac{\theta}{2} = \frac{t}{|n|}$$

## 常见问题

- **_正交变换在实践中用处大吗？_**

  它在判断 _相对长度_ 的时候很有用。同时，它也能简化透视图，因为透视图在医疗可视化领域中成本过高。

- **_我使用图形 API 画出了一个镶嵌球体，但看上去像个椭圆。这是 bug 吗？_**

  不，这是对的。如果你把眼睛也放在相同的角度，它看起来也会像椭圆，这是角度问题。

- **_透视矩阵使用反向操作把正值 $z$ 转换成了负值 $z$ ？这会导致问题吗？_**

  是这样的，转换的方程是：
  $$z' = n+f-\frac{fn}{z}$$
  所以 $z = +\epsilon$ 会被转换成 $z' = -\infty$ ， $z = -\epsilon$ 会被转换成 $z' = \infty$ ( $\epsilon$ 指足够小的数 )。因此所有跨越 $z=0$ 的线段将会被“撕裂”，尽管所有点的投影位置是正确的。当所有的对象都在视图立方体内时，这样的撕裂并没有甚么关系。我们可以通过“切分”视图立方体来解决这个问题。然而，由于有撕裂现象，切分操作会变得更复杂（详见 [第 8 章] ）。

- **_透视矩阵更改了齐次坐标的值。这难道不会使移动和缩放变换用不了吗？_**

  对一个齐次坐标点应用透视矩阵后，我们有：

  $$
  \left [ \begin{matrix}
  1 & 0 & 0 & t_x \\
  0 & 1 & 0 & t_y \\
  0 & 0 & 1 & t_z \\
  0 & 0 & 0 & 1 \\
  \end{matrix} \right ]\left [ \begin{matrix}
  hx \\
  hy \\
  hz \\
  h \\
  \end{matrix} \right ] = \left [ \begin{matrix}
  hx+ht_x \\
  hy+ht_y \\
  hz+ht_z \\
  h \\
  \end{matrix} \right ]\xrightarrow{\rm homigenize}\left [ \begin{matrix}
  x+t_x \\
  y+t_y \\
  z+t_z \\
  1 \\
  \end{matrix} \right ]
  $$

  其他变换也有类似的效果。

# 第八章 图形管线

**前几张已经给我们打好了属性基础，我们可以接着做渲染中第二重要的事了：一个接一个在屏幕上渲染物体，也就是 _对象顺序渲染_ 。在光线追踪时，我们是寻找能够影响它颜色的物体，然后挨个考虑单个像素，但在这里不一样。我们现在是先挨个考虑几何体，然后寻找这个几何体能够影响的像素。在充满 _图元_ 的几何体中计算所有像素的过程被称为 _光栅化_ ，所以对象顺序渲染也可以称作 _光栅渲染_ 。进行该渲染所需的步骤序列——从几何体开始，到更新图像中的像素结束，被称为 _图形管线_ 。**

> **所有的图形系统都有一种或多种“原始物体”，它可以直接被处理，而且复杂的物体会被转化成这种简单物体的组合。它称为“图元”。三角形是用的最多的图元。**

> **基于光栅化的系统也叫 _扫描线着色_ 。**

**对象顺序渲染由于它效率特别高，获得了大成功。在大场景下，数据访问模式对性能影响巨大。而且，按顺序地访问场景中的物体来对像素着色，比在场景中一遍遍搜索物体要高效的多。**

**这章的标题暗示了对象顺序渲染只有一种方法。但实际上并不是这样——存在两个相当不同的图形管线，二者的目标也大相径庭。一个是通过采用 _OpenGL_ 和 _Direct3D_ 等图形 API 的、支持 _交互式渲染_ 的硬件管线；另一种是电影摄制中采用的软件管线，支持 _RenderMan_ 等 API。硬件管线必须足够快，因为它要承担起运行实时游戏、可视化、用户界面的工作，而软件管线（生产管线）必须以最高质量渲染动画和视觉效果，并且这样的渲染应支持大场景，但这样会消耗更多的时间。尽管不同的目标产生了不同的设计思路，但大多数的管线还是有很多相同点。本章将致力于讲解它们的共同点的基础知识，并且稍微偏向硬件管线一些。**

**对象顺序渲染中所需的工作可以被组织为光栅化、光栅化前的几何操作，以及光栅化后的像素操作三个步骤。最常见的几何操作包括前两章学的 _矩阵变换_ ，如将空间的点从物体空间变换到屏幕空间，这样光栅化器的输入格式就是 _像素坐标_ 或者 _屏幕坐标_ （screen space）表示。最常见的像素操作则是隐藏面移除（hidden surface removal），该操作使离观察者更近的表面出现在更远的表面的前方。上述每个阶段还包括了更多的其他操作，这些操作通过相同的通用步骤，从而共同实现了多样化的渲染效果。**

**本章我们将讨论图形管线的四个阶段（如 [图 8.1] ）。几何物体通过交互型应用或者场景描述文件进入管线，而这些几何图形通常由 _顶点集_ 表示。顶点在 _顶点处理阶段_ 被处理，然后由这些顶点产生的 _图元_ 被送到 _光栅化阶段_ 。光栅化器将每个图元分解为一定数量的 _片元_ ，每个被图元覆盖的像素会分配到一个片元。片元在 _片元处理阶段_ 被处理，之后每个像素对应的片元在 _片元混合阶段_ 被组合。**

**我们会从光栅化开始讨论，然后描述在几何阶段和像素阶段分别需要做甚么事情。**

## 8.1 光栅化

光栅化是对象顺序渲染的中心步骤，也是所有图形管线的核心。对于进入的每个图元，光栅器有两个工作：其一是枚举所有被该图元覆盖的像素，其二是对图元中的各个属性进行 **插值** ，插值的目的后面会举例子说明。光栅化器的输出是一系列 **片元** 。每个片元带着自己的属性值们“居住”在一个特定的像素位置上。

这一章中，我们将展示三维场景的光栅化，使用这种光栅化器来渲染三维场景。虽然二维也采用相同的光栅化方法，但如今越来越倾向于采用三维图形系统来包干所有二维的工作。

### 8.1.1 画线

大多数图形工具包都有一个画线命令，这个命令接收两个端点（屏幕坐标）作为参数，见 [图 3.10] ，然后在它们之间画一条线。对于一般的两个端点 $(x_0,y_0)$ 和 $(x_1,y_1)$ ，该 **例程** 需要在这两个点之间绘制一些“合理的”像素，让它们能近似的表示线段。画线的方法基于直线方程，而方程有两种形式可选：隐式方程或参数方程。本章使用隐式方程。

> 尽管我们经常使用整数值端点举例子，但实际上任意的点都应该被支持。

#### 使用隐式方程画线

最常用的画线方法是 _中点算法_ 。中点算法和 _Bresenham 直线算法_ 都能画出相同的直线，但中点算法更直观。

> 译者注：链接：[Bresenham 直线算法](https://zhuanlan.zhihu.com/p/302806158#:~:text=Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95%E6%98%AF%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E7%94%BB%E7%9B%B4%E7%BA%BF%E7%9A%84%E7%AE%97%E6%B3%95%E3%80%82,%E7%9C%9F%E5%AE%9E%E7%9A%84%E7%9B%B4%E7%BA%BF%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%BE%E7%A4%BA%E7%9A%84%E7%B2%BE%E5%BA%A6%E6%9C%89%E9%99%90%EF%BC%8C%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9C%9F%E6%AD%A3%E6%98%BE%E7%A4%BA%E8%BF%9E%E7%BB%AD%E7%9A%84%E7%9B%B4%E7%BA%BF%EF%BC%8C%E4%BA%8E%E6%98%AF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%88%91%E4%BB%AC%E7%94%A8%E4%B8%80%E7%B3%BB%E5%88%97%E7%A6%BB%E6%95%A3%E5%8C%96%E5%90%8E%E7%9A%84%E7%82%B9%EF%BC%88%E5%83%8F%E7%B4%A0%EF%BC%89%E6%9D%A5%E8%BF%91%E4%BC%BC%E8%A1%A8%E7%8E%B0%E8%BF%99%E6%9D%A1%E7%9B%B4%E7%BA%BF%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%E3%80%82%20%E5%9C%A8%E6%9C%AC%E6%96%87%E4%B8%AD%E6%88%91%E4%BB%AC%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95%EF%BC%8C%E5%B9%B6%E9%80%90%E6%AD%A5%E4%BC%98%E5%8C%96%EF%BC%8C%E6%9C%80%E7%BB%88%E5%BC%95%E5%87%BA%E7%BB%8F%E5%85%B8%E7%9A%84Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95%EF%BC%8C%E5%B9%B6%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%8E%9F%E7%90%86%E3%80%82)

我们要做的第一件事是找到那两个点对应的隐式方程：

$$f(x, y) ≡ (y_0 − y_1)x + (x_1 − x_0)y + x_0y_1 − x_1y_0 = 0.$$

我们假设 $x_0<x_1$ 。如果实际上不符合，那么我们交换两个点。那么直线的斜率是：

$$m = \frac{y_1-y_0}{x_1-x_0}$$

下面的讨论假设了 $m \in (0,1]$ ，对于区间 $(-\infty,-1]$ 和 $(-1,0]$ 和 $(1,\infty)$ 是相似的，可以由之前的例子进行推广。

对于 $(0,1]$ 的例子，直线比较“平坦”。也就是 $x$ 比 $y$ 移动地快。如果有一个 API 的 $y$ 轴朝下，我们可能会担心这会让我们的工作变难，但实际上这个细节完全可以忽略。我们可以忽略几何的“上下”，因为不管咋样，数值都是一样的。中点算法的关键假设是：画出中间没有断开的、最细的线（像素沿对角线排列不算断开）。

从左到右的像素绘制过程中，只有两种情况：右边的像素比左边高一格，或是一样高。因此，线段上每一列都只会由一个像素。如果没有像素，那么就是出现了断开，如果有两个以上，这个地方就太粗了。相对的，一行内可能出现不止一个像素。见 [图 8.2] 。

针对 $m \in (0,1]$ 的重点算法首先会确定最左边的像素和最右边的像素的 $x$ **值（列号）** 。然后不断从左向右循环，确定每个像素的 $y$ **值（行号）** 。伪代码如下：

```java
y = y0
for x = x0 to x1 do
    draw(x, y)
    if (some condition) then
        y = y + 1
```

注意这里的 $x$ 和 $y$ 是整数。上面的代码用文字描述是：“从左到右依次绘制像素，并且有时候向上一格”。打造一个高效的判断方式取决于 _if_ 里面的语句。

有一种高效的判断方式是考虑两个端点像素中心的中点。具体地说，刚被绘制的 $(x,y)$ 位置的像素在真实屏幕上的位置是 $(x,y)$ ，那么下一个该绘制的像素只可能是 $(x+1,y)$ 或 $(x+1,y+1)$ 。而两个候选点的中点是 $(x+1,y+0.5)$ 。如果线段通过这个点的下方，那么选取 $(x+1,y)$ ，否则就选取 $(x+1,y+1)$ 。如 [图 8.3] 。

为了判断直线到底是在 $(x+1,y+0.5)$ 的上方还是下方，我们计算上面公式的 $f(x,y+0.5)$ 。按照它的符号来确定点相对于直线的位置。由于 $-f(x,y)=0$ 和 $f(x,y)=0$ 都是正确的直线方程，所以我们还不能马上确定什么符号对应着什么样的位置关系。但是我们可以通过系数判断出来：注意到 $y$ 的系数是 $(x1-x0)$ ，由于我们已经假设了 $x1>x0$ ，因此该系数为正，这意味着当 $y$ 不断增加时， $(x1-x0)y$ 也在增加，因而 $f(x,+\infty)$ 必然为正，且在直线上方，这说明直线上方的点在 $f(x,y)$ 的取值都为正。另外一种判断方法是看梯度向量的 $y$ 分量是否为正。这意味着我们现在能够完善 _if_ 语句的内容了:

```vb
if f(x + 1, y + 0.5) < 0 then
    y = y + 1
```

上述代码可以用于斜率在 0 到 1 之间的情况。读者可能自己找出其他三种情况的方法，它们只有微小的不同。

如果我们想要执行更高效，那么可以采用 _增量式方法_ 。其中有一种增量式方法尝试通过复用前一轮的计算结果，使得循环变得更加高效。在中点算法中，主要的计算是 $f(x+1,y+0.5)$ 。注意到在循环内部，循环第一轮之后，对于当前的 $(x,y)$ ，我们已经在上一轮循环计算过了 $f(x-1,y+0,5)$ 或者 $f(x-1,y-0.5)$ 的值。注意到如下关系：

$$f(x + 1, y) = f(x, y)+(y_0 − y_1)$$
$$f(x + 1, y + 1) = f(x, y)+(y_0 − y_1)+(x_1 − x_0).$$

这就能让我们写出增量式方法的代码：

```vb
y = y0
d = f(x0 + 1, y0 + 0.5)
for x = x0 to x1 do
    draw(x, y)
    if d < 0 then
        y = y + 1
        d = d + (x1 − x0)+(y0 − y1)
    else
        d = d + (y0 − y1)
```

该算法相比于原来的算法速度更快，因为它与之前的代码相比几乎没有 _设置成本_ 。但是也可能会因此积累更多的误差，因为 $f(x,y+0.5)$ 的计算是通过一系列值相加得到的，误差也会累加。不过只要直线不是特别长，误差的影响不大。我们稍微增加一些 _设置成本_ ，可以将循环执行的更快：也就是将 $(x_1-x_0)+(y_0-y_1)$ 和 $y_0-y_1$ 提前算好，就可以在循环中不必重复计算。但如果代码很重要，那么需要检查编译后的代码来确保写的代码没有问题。

> 译者注：此处可阅读《深入理解计算机系统》来探究程序的优化方式。

### 8.1.2 三角形的光栅化

我们经常会需要通过三个二维屏幕坐标：${\rm\textbf{p}_0}=(x_0,y_0), \ {\rm\textbf{p}_1}=(x_1,y_1), \ {\rm\textbf{p}_2}=(x_2,y_2)$ 来绘制二维三角形。这和画线比较相似，但它有一些独有的特征。我们可能会想要根据顶点的颜色或是其他属性来做插值，而插值实际上有了 **重心坐标** 的帮助变得很直观了（见 [2.7 节] ）。举个例子。如果三个顶点的颜色分别是 $\rm\textbf{c}_0$ , $\rm\textbf{c}_1$ , $$ ，那么在三角形内某一点 $(\alpha,\beta,\gamma)$ 的颜色就是：

$${\rm\textbf{c}} = \alpha {\rm\textbf{c}_0} + \beta{\rm\textbf{c}_1}+ \gamma {\rm\textbf{c}_2}$$

上述插值的方法称作 _Gouraud 插值法 (亮度插值法)_ 。

三角形光栅化的另一个微妙的地方在于，我们往往需要对共享顶点和边的三角形做光栅化。这意味着我们需要在不出现漏空的前提下对这些三角形进行光栅化。我们可以运用 **中点算法** 画出每个三角形的边，然后填充它们内部的像素。这意味着相邻的三角形会在它们的边上绘制相同的像素。如果相邻的三角形具有不同的颜色，那么渲染出来的公共边的图像效果将由后绘制的三角形决定。避免这种顺序问题、并消灭漏空的最常用方法是：只画那些像素中心在三角形内部的像素，换句话说就是只绘制那些像素中心在 $(0,1)$ 区间内的像素。但这样又会产生另外一个问题：如果中心刚好就在三角形的边上，那该怎么办？我们在之后会讨论这个问题，它有好几种解决方案。我想说的关键在于，重心坐标给了我们判断是否画一个像素、以及通过顶点插值得到像素颜色的方法。因此，光栅化三角形的问题就能被归结为：如何高效的找到像素中心的坐标。暴力光栅化算法如下：

```vb
for all x do
    for all y do
        compute (α, β, γ) for (x, y)
        if (α ∈ [0, 1] and β ∈ [0, 1] and γ ∈ [0, 1]) then
            c = αc0 + βc1 + γc2
            drawpixel (x, y) with color c
```

下面的算法将外层循环的候选像素限制在一个较小的集合里，使得重心坐标的计算更加高效。

> 为了一个小三角形遍历整个屏幕，是不是太浪费了？！

我们可以通过找到三角形的 **_包围盒_** ，并且只考虑矩形内的像素来提升算法效率。于是我们得到如下算法：

```vb
x_min = floor(x_i)
x_max = ceiling(x_i)
y_min = floor(y_i)
y_max = ceiling(y_i)
for y = y_min to y_max do
    for x = x_min to x_max do
        α = f_12(x, y)/f_12(x0, y0)
        β = f_20(x, y)/f_20(x1, y1)
        γ = f_01(x, y)/f_01(x2, y2)
        if (α > 0 and β > 0 and γ > 0) then
            c = α*c_0 + β*c_1 + γ*c_2
            drawpixel (x, y) with color c
```

在这里， $f_{ij}$ 就是由两点得出的线段，由之前我们讲解的直线方程得到（之后还会用到这个约定）：

$$f_{01}(x, y)=(y_0 − y_1)x + (x_1 − x_0)y + x_0y_1 − x_1y_0,$$
$$f_{12}(x, y)=(y_1 − y_2)x + (x_1 − x_2)y + x_1y_2 − x_2y_1,$$
$$f_{20}(x, y)=(y_2 − y_0)x + (x_0 − x_2)y + x_2y_0 − x_0y_2,$$

请注意，我们使用重心坐标的时候没有判断 $\alpha$ 的正负，而是直接默认 $\alpha>0$ 。因为如果三个重心坐标都是正数，那么它们就能天然满足小于 $1$ 的条件，因为重心坐标之和为 $1$ 。我们也可以只计算两个坐标，通过等式计算出第三个，但是在采用了增量式算法时这不确定能不能变得更加高效；每次计算 $\alpha,\beta,\gamma$ 时都会计算形如 $f(x,y)=Ax+By+C$ 的式子，在里面那层循环中，只有 $x$ 产生变化，每次变化 $1$ 。同时注意到 $f(x + 1, y) = f(x, y) + A$ ，这个式子是增量式算法的基础。

在外层循环中，则是考虑 $f(x,y)$ 到 $f(x,y+1)$ 的变化。因此也能够通过增量式算法获取相似的效率提升。由于三个重心坐标在循环中都是按固定数变化，所以颜色 $\rm\textbf{c}$ 的变化也一样，因为它们都呈线性关系，故颜色也可以运用增量式算法。例如，坐标 $(x+1,y)$ 的 _红色值_ 和坐标 $(x,y)$ 的 _红色值_ 相差的常数值能够被提前计算出来。三角形颜色插值的一个例子如 [图 8.5] 。

#### 处理三角形边界上的像素

我们还妹有讨论对三角形边界穿过的像素点该做 ♂ 点什么。如果一个像素恰好在三角形的边上，如果旁边还有一个三角形，那么他就会处在公共边上。公共边不能轻易的被归到某个三角形上。不画这个像素是最差的选择，这样就会出现漏空。给两个三角形都绘制像素的方法，如果三角形是透明的，会导致双重着色，所以这个方法比上不足比下有余。我们还是希望能把这个像素判给某个三角形，同时方法越简单越好；选择哪个三角形并不重要，但方法好就可以。

有一种解决方案：我们注意到，任何在屏幕坐标外的点必定会在三角形公共边的某一侧。对于两个不重叠的、有公共边的三角形，单独剩下来的那两个顶点一定在边的两侧，同时肯定有其中的一个点是和 _离屏点_ 在同一侧的（见 [图 8.6] ）。上面所说的是我们接下来要采用的神奇方法的原理。

测试方法将计算出离屏点和三角形孤儿顶点代入直线函数的取值，并将它们相乘。根据该乘积的符号决定将公共边算到哪个三角形头上，符号的选择是任意的，本文选择正号。

注意，上述测试不是完美的，因为线段所在的直线也有可能通过选择的离屏点，这样代入取值就是 **0** 。但我们至少大大减少了出问题的情况。使用哪个离屏点是随意的，一般来说 $(-1,-1)$ 是一个不错的选择。但正是因此，我们需要增加一个检查离屏点是否刚好在边所在直线上的步骤。同时我们希望这个检查和判断内外的部分分离开来。于是有如下伪代码：

```vb
x_min = floor(x_i)
x_max = ceiling(x_i)
y_min = floor(y_i)
y_max = ceiling(y_i)
f_α = f12(x_0, y_0)
f_β = f20(x_1, y_1)
f_γ = f01(x_2, y_2)
for y = y_min to y_max do
    for x = x_min to x_max do
        α = f_12(x, y)/f_α
        β = f_20(x, y)/f_β
        γ = f_01(x, y)/f_γ
        if (α ≥ 0 and β ≥ 0 and γ ≥ 0) then
            if (α > 0 or f_α * f12(−1, −1) > 0) and
                    (β > 0 or f_β*f_20(−1, −1) > 0) and
                    (γ > 0 or f_γ*f_01(−1, −1) > 0) then
                c = α*c0 + β*c1 + γ*c2
                drawpixel (x, y) with color c
```

我们期望上面的代码能够解决漏空和重复着色的问题。实际上，如果两个共享顶点有相同的绘制顺序，直线方程就是相同的。否则的话会变个符号。如果编译器改变了渲染顺序，那么可能会因为这个符号出现问题。所以如果你需要一个健壮的程序，那就需要检查编译器的数学单元。同时，需要小心处理伪代码的前四行，因为有公共边刚好在像素中心的特殊情况。

除了实现增量式算法之外，还有一些可以让程序提前退出的点。例如，如果 $\alpha<0$ ，那么就没有必要计算 $\beta$ 和 $\gamma$ 了。这样提前退出可能可以让算法速度变快，我们可以使用性能分析工具 _ProfilingTools_ 来测量是否有性能提升，因为额外的分支也有可能影响流水线或并行性，拖慢运行速度。所以，如果代码很重要，那么我们需要测试所有力所能及的优化方案。

还有一点，就是上述代码的除法可能会出现除零的问题。比如： $f_\gamma = 0$ 。所以我们可以选择捕获浮点错误，或者设置一个检查措施。

### 8.1.3 裁剪

仅仅把图元变换到屏幕坐标并进行光栅化还不太够。因为视景体外，特别是眼睛后面的图元也有可能会被光栅化，导致结果出错。例如，考虑 [图 8.7] 中的三角形：有两个顶点在视景体内，而第三个顶点在眼睛后面。投影变换会将这个点映射到一个 _远平面_ 后面的不可视区域，如果这种操作被允许，三角形就没法被正确地光栅化。因此，光栅化之前需要进行 **裁剪操作** ，以移除图元能够延伸到眼睛后面的部分。

裁剪是图形学中的常规操作，只要一个几何体“切割”到了另外一个几何体就会用到裁剪。例如，如果你使用平面 $x=0$ 切割一个三角形，会将它分为两部分（只要三角形顶点的 $x$ 坐标符号不全相同）。在大多数裁剪的应用中，三角形中在平面的“错误”侧的部分将被抛弃。如 [图 8.8] 所示。

在给光栅化裁剪中，所谓的“错误”侧，也就是需要去掉的一侧是 _视体_ 外面的部分。在视体外的所有几何结构就算都裁剪掉都没啥关系——也就是裁剪掉视体六个平面之外的所有东西，但是有很多系统仅仅裁剪了近平面那一侧的物体。

> 译者注：这里的视体指视锥金字塔截掉前面部分的塔体。

我们将在这一节讨论裁剪模型的基本实现。而不是写一个工业级裁剪工具。

实现裁剪的最常用的两种方法是：

1. 在世界坐标中用视体的六个面进行裁剪（转换前裁剪）
2. 在四维转换空间中的 _齐次除法_ 之前裁剪

上述两种方法都能轻松实现(J. Blinn, 1996) ，对每个三角形应用以下步骤：

```vb
for each of six planes do
    if (triangle entirely outside of plane) then
        break (triangle is not visible)
    else if triangle spans plane then
        clip triangle
        if (quadrilateral is left) then
            break into two triangles
```

### 8.1.4 转换前裁剪（方法 1）

该方法有一个直接的实现。唯一需要解决的问题是： **六个平面方程是什么？** 由于这些方程对同一个图像中的所有三角形都相同，我们不需要非常高效的计算他们。因此，我们可以仅仅对 [图 5.11] 中的变换取逆，并将它应用于视体的八个顶点上：

$$
(x, y, z) =(l, b, n),\\
(r, b, n)\\
(l, t, n)\\
(r, t, n)\\
(l, b, f)\\
(r, b, f)\\
(l, t, f)\\
(r, t, f)
$$

平面方程可以从他们在世界坐标里的像推导出来。我们也可以用向量的几何性质来直接从 _视角参数_ （viewing parameters）得到。

### 8.1.5 齐次坐标的裁剪（方法 2）

但其实，我们一般采用的方法是在做除法之前，对齐次坐标做裁剪。在这里，视体是四维的，它被一个 _三维超平面_ 包围：

$$-x+lw = 0$$
$$x-rw = 0$$
$$-y+bw = 0$$
$$y-bw = 0$$
$$-z+nw = 0$$
$$z-fw = 0$$

这些平面的表达方式非常简单，所以用这个方法编写的程序效率比上个方法要好。算法可以进一步被优化，方法是将视体 $[l,r]\times [b,t] \times [f,n]$ 转换成 $[0,1]^3$ 空间中。其实这样做并没有比三维空间复杂多少。

### 8.1.6 对一个面进行裁剪

不管我们用哪种方式，我们都需要对面进行裁剪。还记得在 [2.5.5 节] 中，我们有一个对于某平面穿过点 $\rm\textbf{q}$ 的隐式方程：

$$f({\rm\textbf{q}}) = {\rm\textbf{n}} \cdot ({\rm\textbf{p}}-{\rm\textbf{q}}) = 0$$

这一般这样写：

$$f({\rm\textbf{q}}) = {\rm\textbf{n}} \cdot {\rm\textbf{p}}+D = 0$$

有趣的是，这个方程不止描述了三维平面，它也表示了二维的线，以及四维平面的 _体近似物（Volumn Analog）_ 。这些玩意儿在它们自己的维度中都叫做平面。

如果我们在 ${\rm\textbf{a}}$ 和 ${\rm\textbf{b}}$ 点之间有一个线段，我们就可以将它用一个平面来“裁剪”，使用的是 [12.4.3 节] 中的 _BSP 树_ 切割三角形的程序。这里， ${\rm\textbf{a}}$ 和 ${\rm\textbf{b}}$ 通过代入对 $f({\rm\textbf{a}})$ 和 $f({\rm\textbf{b}})$ 取值，看他们是不是一正一负，来判断这俩点是不是在平面的两侧。我们喜欢把 $f({\rm\textbf{q}})<0$ 定义为内侧。如果这条线段确实被隔开了，那么我们就可以将下式:

$${\rm\textbf{q}} = {\rm\textbf{a}}+t({\rm\textbf{b}}-{\rm\textbf{a}})$$

代入方程 $f({\rm\textbf{q}}) = 0$ ，得到：

$${\rm\textbf{n}} \cot ({\rm\textbf{a}}+t({\rm\textbf{b}}-{\rm\textbf{a}}))+D = 0$$

解出 $t$ ：

$$t = \frac{{\rm\textbf{n}}\cdot {\rm\textbf{a}}+D}{{\rm\textbf{n}}\cdot ({\rm\textbf{a}}-{\rm\textbf{b}})}$$

这样我们就能找到交点，然后将看不到的地方减去。

裁剪三角形，我们也可以通过 [12.4.3 节] 中的方法进行，得到一个或两个三角形。

## 8.2 光栅化之前和之后的操作

在一个图元被光栅化之前，它的顶点坐标必须是屏幕坐标，同时颜色之类的属性，应该已经被插值，这些属性必须都是已知的。我们通过 _顶点处理（信息准备）_ 这一阶段完成数据的准备工作。在这个阶段，被送来的顶点们将依次经过模型、视图、投影变换，然后将它们的原始坐标转换成屏幕坐标（别忘了，屏幕坐标是以像素为单位的）。与此同时，其他的信息如颜色、表面法线、或纹理坐标，会按需转换。我们在之后的例子会讨论这些属性怎么搞。

在光栅化之后，我们会进行进一步处理，也就是对每一个分片计算颜色和深度。这个过程可以很简单，只经过颜色插值和光栅化计算深度，或者也可以很复杂，包含复杂的着色操作。然后最后，会经过一个 Blend 阶段
