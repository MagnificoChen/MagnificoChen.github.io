<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [["$", "$"], ["\\(", "\\)"]],
            displayMath: [["$$", "$$"], ["\\[", "\\]"]],
            }
        });
    </script>
</head>

# 第六章 变换矩阵

**线性代数的原理可以用来在三维场景中排列对象、使用相机查看对象，并且能让对象显示在屏幕上。像旋转、平移、缩放、投影这样的 _几何变换_ 可以使用矩阵乘法解决，而这章的主题就是实现这些操作用到的 _变换矩阵_ 。**

**我们会展示对于 “以原点出发的向量” 这样的方式来表示的一组点该如何进行变换，然后我们会使用图 6.1 所示的时钟图片来向你直观的进行展示。你只需要把这章时钟的图想象成由一组点组成即可，这些点是向量的终点，原点是向量的起点。我们同样也会讨论以下的这些变换对位置（点）、位移向量、以及表面法向量会产生什么样的作用。**

## 6.1 二维线性变换

我们可以使用 $2\times2$ 的矩阵来对一个二维向量进行变换

$$
\left [\begin{matrix}
  a_{11} & a_{12} \\
  a_{21} & a_{22}
\end{matrix} \right]\left[\begin{matrix}
  x \\
  y
\end{matrix} \right] = \left[\begin{matrix}
  a_{11}x+a_{12}y \\
  a_{21}x+a_{22}y
\end{matrix} \right]
$$

这种变换接收一个二维向量作为输入，通过简单的矩阵乘法生成另外一个二维向量输出，称为 **线性变换** 。

这是一个简单的公式，通过这个操作我们可以实现各种各样的转换，这取决于我们在矩阵里面输入什么内容。目前来说，我们要康康如何沿着 $x$ 和 $y$ 轴进行移动。

### 6.1.1 缩放

最简单的变换是沿坐标轴 **缩放** 。这种变换可以改变长度，有时也会改变方向：

$$
scale \ (s_x,s_y) =  \left [ \begin{matrix}
    s_x & 0 \\
    0 & s_y\\
    \end{matrix} \right]
$$

此矩阵有对笛卡尔分量的 $(x,y)$ 作用：

$$
\left [ \begin{matrix}
    s_x & 0 \\
    0 & s_y\\
    \end{matrix} \right]  \left[\begin{matrix}
    x \\
    y\\
    \end{matrix} \right]   = \left[\begin{matrix}
    s_xx \\
    s_yy \\
    \end{matrix} \right]
$$

所以，从上述公式里我们可以得知两个缩放系数。 $s_x$ 是对 x 轴的缩放系数， $s_y$ 是对 y 轴的缩放系数。所以，下面的矩阵能将原图片等比缩小成原来的四分之一：

$$
scale \ (0.5,0.5) =  \left [ \begin{matrix}
    0.5 & 0 \\
    0 & 0.5\\
    \end{matrix} \right]
$$

### 6.1.2 切变

切变是一种把东西推到一边的变换。它能产生的效果就像用手推一副扑克牌，让他变得倾斜。水平和垂直方向的切变如下所示：

$$
shear \ x(s) =  \left [ \begin{matrix}
    1 & s \\
    0 & 1\\
    \end{matrix} \right] , shear \ y(s) =  \left [ \begin{matrix}
    1 & 0    \\
    s & 1\\
    \end{matrix} \right]
$$

另一种理解切变的方法是只旋转水平/垂直轴。切变将 $y$ 轴顺时针旋转 $\phi$ 度的变换矩阵是：

$$
\left [ \begin{matrix}
    1 & \tan\phi \\
    0 & 1\\
    \end{matrix} \right]
$$

相似的，将 $x$ 轴 _逆时针_ 旋转 $\phi$ 度的变换矩阵是：

$$
\left [ \begin{matrix}
    1 & 0 \\
    \tan\phi & 1\\
    \end{matrix} \right]
$$

### 6.1.3 旋转

假设我们想将一个向量 $\rm\textbf{a}$ _逆时针_ 旋转 $\phi$ 度，得到向量 $\rm\textbf{b}$ ，假设向量 $\rm\textbf{a}$ 与 $x$ 轴成 $\alpha$ 度角，长度是 $r=\sqrt{x_a^2+y_a^2}$ 那么我们可以得到极坐标形式：

$$x_a = r\cos\alpha$$
$$y_a = r\sin\alpha$$

由于 $\rm\textbf{b}$ 仅是 $\rm\textbf{a}$ 旋转，所以长度也是 $r$ ，由于是旋转了 $\phi$ 度，所以使用三角函数的加法，能得到：

$$x_b = r\cos(\alpha+\phi) = r\cos\alpha\cos\phi-r\sin\alpha\sin\phi$$
$$y_b = r\sin(\alpha+\phi) = r\sin\alpha\cos\phi+r\cos\alpha\sin\phi$$

使用 $\rm\textbf{a}$ 的两个分量做替换，有：

$$x_b = x_a\cos\phi-y_a\sin\phi$$
$$y_b = y_a\cos\phi+x_a\sin\phi$$

则我们可以使用矩阵形式来表达，即

$$
rotate \ (\phi) =  \left [ \begin{matrix}
    \cos\phi & -\sin\phi \\
    \sin\phi & \cos\phi\\
    \end{matrix} \right]
$$

请注意， $\phi$ 指的是 **逆时针** 旋转的角度，若需要顺时针旋转，需要添加一个负号。

另外，由于三角函数具有 $\sin^2\phi+\cos^2\phi = 1$ 的特性，而且在这个矩阵中，每行每列都是**正交**的，所以我们能得到，这个变换矩阵是 **正交矩阵** ：这个矩阵的两列分别是对标准正交基向量 $(1,0)$ 和 $(0,1)$ 的变换，同时，两行则是*发送到*标准正交基向量的变换。

### 6.1.4 反射

我们可以通过设置一个负值的缩放系数来完成对坐标轴的反射变换（对称变换），见图 6.8，图 6.9：

$$
reflect \ -x =  \left [ \begin{matrix}
    1 & 0 \\
    0 & -1\\
    \end{matrix} \right], \ reflect \ -y =  \left [ \begin{matrix}
    -1 & 0 \\
    0 & 1\\
    \end{matrix} \right]
$$

有些人可能会认为，将矩阵对角线上的所有元素添一个负值也是一个反射变换，但其实它只是一个 $\pi$ 角度的 **旋转变换**。

> 有时上面这种变换也称作：关于原点进行反射变换。

### 6.1.5 变换的组合和分解

图像程序通常都有需要将一个物体进行多次变换。比如，我们可能先对向量 $\rm\textbf{v}_1$ 进行一个缩放变换 $\rm\textbf{S}$ ，然后进行一个旋转变换 $\rm\textbf{R}$ 。这就需要两部来完成:

$$\rm\textbf{v}_2 = \rm\textbf{Sv}_1, \ \rm\textbf{v}_3 = \rm\textbf{Rv}_2$$

也就是

$$\rm\textbf{v}_3 = \rm\textbf{RSv}_1$$

根据结合律，我们可以让 $\rm\textbf{R}$ 和 $\rm\textbf{S}$ 先乘。但请记住，越靠近 $\rm\textbf{v}_1$ 的矩阵越先被施加效果。

实际中，用旋转和缩放来进行变换已经可以覆盖所有的 _线性变换_ 。这一点很重要，下一节我们会着重讨论。

### 6.1.6 变换的分解

有时，有必要“撤消”转换的组合，将转换分解为更简单的部分。比如，在向用户展示变换的过程时，对单独的旋转和缩放系数进行操作是很有好处的，但往往一整个变换过程被简单的整合在了一个矩阵的内部，旋转变换和缩放变换被混合在一起，会变得不好理解。如果可以通过计算将变换矩阵分解为所需的部分，调整此部分，然后将调整后的片段再次相乘来重新组装成矩阵，就可以实现这样的操作。

​ 事实证明，无论矩阵中的元素是什么，这种分解（或者说因式分解）都是可能被实现的。它提供了一种有用的方式来思考变换，以及变换对几何体的影响。

#### 对称特征值分解

我们首先来看对称矩阵。回忆 5.4 节所学内容，所有的实对称矩阵都可以通过特征值分解进行对角化。如下例：

$${\rm\textbf{A}} =  \rm\textbf{RSR}^T$$

其中 $\rm\textbf{R}$ 是正交矩阵， $\rm\textbf{S}$ 是对角矩阵，我们将使用 $\rm\textbf{v}_1$ 和 $\rm\textbf{v}_2$ 来表示 $\rm\textbf{R}$ 的列向量（特征向量），用 $\rm\lambda_1$ 和 $\rm\lambda_2$ 来表示特征值（对角矩阵的对角线值）。

让我们以几何方面来重新审视以下上面的矩阵乘法：现在我们可以将 $\rm\textbf{R}$ 视为旋转， $\rm\textbf{S}$ 视为缩放，把整个式子看成是组合的变换（图 6.13）：

1. 将 ${\rm\textbf{v}}_1$ 和 ${\rm\textbf{v}}_2$ 旋转到 x 轴和 y 轴（ ${\rm\textbf{R}^T}$ 的效果）
2. 使用 $(\lambda_1,\lambda_2)$ 来缩放 x 和 y。（ ${\rm\textbf{S}}$ 的效果）
3. 将 x 轴和 y 轴转回 ${\rm\textbf{v}}_1$ 和 ${\rm\textbf{v}}_2$ 处。（ ${\rm\textbf{R}}$ 的效果）

我们观察这三种变换叠加在一起的效果，能发现它们具有沿着一个对称轴进行不均匀缩放的效果。和沿着坐标轴近似下缩放类似，图形的对称轴是垂直的，但它们并不是 x y 轴，而是矩阵 ${\rm\textbf{A}}$ 的特征向量。这就告诉了我们：对称矩阵只是进行了一个缩放操作，尽管这个缩放不是均匀的，也不关于坐标轴对称。

让我们看下面的例子：将下面的矩阵进行特征值分解：

$$
\left [ \begin{matrix}
    2 & 1 \\
    1 & 1\\
    \end{matrix} \right] = {\rm\textbf{R}}\left [ \begin{matrix}
    \lambda_1 & 0 \\
    0 & \lambda_2 \\
    \end{matrix} \right]{\rm\textbf{R}^T}
$$

$$
= \left [ \begin{matrix}
    0.8507 & -0.5257 \\
    0.5257 & 0.8507 \\
    \end{matrix} \right] \left [ \begin{matrix}
    2.618 & 0 \\
    0 & 0.382\\
    \end{matrix} \right]\left [ \begin{matrix}
    0.8507 & 0.5257 \\
    -0.5257 & 0.8507 \\
    \end{matrix} \right]
$$

$$ = \rm rotate(31.7\degree) \ scale(2.618,0.382) \ rotate(-31.7\degree)$$

我们应该记住，这是一个对称矩阵，因为我们是采用对称特征值分解来构造解决这个问题的。

#### 奇异值分解

我们在 5.4.1 节也讲过，奇异值分解（SVD）主要用于非对称矩阵的分解，区别在于中间的对角阵两边的矩阵不再是一样的：

$${\rm\textbf{A}} = {\rm\textbf{U}}{\rm\textbf{S}}{\rm\textbf{V}^T}$$

替换掉 ${\rm\textbf{R}}$ 的两个正交矩阵分别是 ${\rm\textbf{U}}$ 和 ${\rm\textbf{V}}$ ，我们将它们的列向量分别称作 ${\rm\textbf{u}_i}$ 和 ${\rm\textbf{v}_i}$ 。在这种情况下， ${\rm\textbf{S}}$ 的对角线元素被称作 **奇异值** 而不是特征值。它的几何描述和对称特征值分解很相似：

1. 将 ${\rm\textbf{v}}_1$ 和 ${\rm\textbf{v}}_2$ 旋转到 x 轴和 y 轴（ ${\rm\textbf{V}^T}$ 的效果）
2. 使用 $(\sigma_1,\sigma_2)$ 来缩放 x 和 y。（ ${\rm\textbf{S}}$ 的效果）
3. 将 x 轴和 y 轴转回 ${\rm\textbf{u}}_1$ 和 ${\rm\textbf{u}}_2$ 处。（ ${\rm\textbf{U}}$ 的效果）

区别在于两个正交矩阵以及旋转过程中。由于奇异值分解会得到两边不同的奇异向量，我们就没有必要得到 _负奇异值_ ，只需要将出现负号的奇异值改正号，然后 **将对应的奇异向量反转方向** 即可。正因为此，奇异值分解总能产生一个正项的对角阵。但矩阵 ${\rm\textbf{U}}$ 和 ${\rm\textbf{V}}$ 并不一定是旋转变换——它可能包含了反射变换。在图形学的几何应用程序中，这一点是一个小问题，不太方便：我们可以通过行列式来区分旋转和反射变换，如果行列式是 +1 ，说明这个变换是一个旋转变换，但如果是反射变换，行列式值是 -1 。如果同时需要旋转，其中一个奇异值可以取反，从而产生旋转-缩放-旋转的效果，此时反射是隐藏在缩放变换中，而不是在旋转变换中。

奇异值分解存在的好处是，我们所看到的**所有**二维变换矩阵**都可以由旋转矩阵和缩放矩阵构成**。切变矩阵是很方便，但组合变换时它不是必需的。

总之，每个矩阵都可以通过 **SVD** 分解为 一个 **旋转矩阵** 乘一个 **缩放矩阵** 再乘另一个 **旋转矩阵** 。只有对称矩阵可以通过特征值对角化分解为 **旋转矩阵** 乘以 **缩放矩阵** ，再乘以 **逆旋转矩阵** ，并且是可以在任意方向上的进行的简单缩放。而对于不对称矩阵的奇异值分解，将通过稍微复杂一点的代数操作，产生与特征值分解相同的三个矩阵的乘积形式。

#### 旋转矩阵的 Paeth 分解

还存在另外一种分解方式：它的作用是即将旋转操作分解为三个切变操作（Paeth，1990），操作如下：

$$
\left [ \begin{matrix}
    \cos\phi & -\sin\phi \\
    \sin\phi & \cos\phi\\
    \end{matrix} \right ] = \left [ \begin{matrix}
    1 & \frac{\cos\phi - 1}{\sin\phi} \\
    0 & -1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & 0 \\
    \sin\phi & -1 \\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & \frac{\cos\phi-1}{\sin\phi} \\
    0 & -1\\
    \end{matrix} \right ]
$$

这样的变换对 _光栅旋转_ 很有用。因为切变是一种效率非常高的图像光栅操作，它虽然会造成一些锯齿，但不会留下孔洞。一个很好的例子是：如果光栅位置是 $(i,j)$ ，我们施加一个水平的切变，就能得到：

$$
\left [ \begin{matrix}
    1 & s \\
    0 & 1\\
    \end{matrix} \right] \left [ \begin{matrix}
    i \\
    j \\
    \end{matrix} \right] = \left [ \begin{matrix}
    i+sj \\
    j \\
    \end{matrix} \right]
$$

如果我们将 $sj$ 舍入到最近的整数，这就相当于将图像的每一行进行横向移动，但行与行的移动量不同。但行内移动量是相同的，这就让我们能够对图像进行无缝旋转。同样的，垂直的切变也是如此，所以通过切变我们可以轻松实现简单光栅旋转。

## 6.2 三维线性变换

三维线性变换就是二维变换的拓展。例如，笛卡尔坐标系中沿轴缩放为：

$$
scale(a_x,a_y,a_z) = \left [ \begin{matrix}
    s_x & 0 & 0 \\
    0 & s_y & 0 \\
    0 & 0 & s_z \\
    \end{matrix} \right]
$$

但旋转就比二维要复杂多了。这里，我们希望简单的沿着 $z$ 轴旋转，所以只改变 $x$ 和 $y$ 的坐标，我们就可以用二维旋转矩阵：

$$
\rm rotate_z(\phi) = \left [ \begin{matrix}
    \cos\phi & -\sin\phi & 0 \\
    \sin\phi & \cos\phi & 0 \\
    0 & 0 & 1 \\
    \end{matrix} \right]
$$

同样我们可以很容易得到沿着 $x$ 轴和 $y$ 轴的旋转矩阵：

$$
\rm rotate_x(\phi) = \left [ \begin{matrix}
    1 & 0 & 0 \\
    0 & \cos\phi & -\sin\phi \\
    0 & \sin\phi & \cos\phi \\
    \end{matrix} \right]
$$

$$
\rm rotate_y(\phi) = \left [ \begin{matrix}
    \cos\phi & 0 &  \sin\phi\\
    0 & 1 & 0 \\
    -\sin\phi & 0 & \cos\phi \\
    \end{matrix} \right]
$$

为什么 $y$ 轴的旋转矩阵看上去好像反了？我们下一节将会讨论，同时讨论对任意轴的旋转。

和二维一样，我们可以对特定的轴进行切变：

$$
\rm shear_x(d_y,d_z) = \left [ \begin{matrix}
    1 & d_y &  d_z\\
    0 & 1 & 0 \\
    0 & 0 & 1 \\
    \end{matrix} \right]
$$

同样的，和二维一样，所有三维的变换矩阵都可以使用奇异值分解来分解成旋转-缩放-旋转的组合。所有对称的三维矩阵都可以使用特征值分解来分解成旋转-缩放-转回的组合，最后，旋转矩阵同样可以表示成三维切变矩阵的乘积。

### 6.2.1 任意三维旋转

和二维一样，三维旋转矩阵也是 **正交矩阵** 。在几何上来说，这意味着矩阵的三个行向量是三个正交单位向量，列向量是三个可能不同的正交单位向量，让我们写下如下的矩阵：

$$
{\rm\textbf{R}}_{uvw} = \left [ \begin{matrix}
    x_u & y_u & z_u\\
    x_v & y_v & z_v \\
    x_w & y_w & z_w \\
    \end{matrix} \right ]
$$

在这里， ${\rm\textbf{u}} = x_u{\rm\textbf{x}}+y_u{\rm\textbf{y}}+z_u{\rm\textbf{z}}$， ${\rm\textbf{v}}$ 和 ${\rm\textbf{w}}$ 也是如此。由于这些向量是正交单位化的，所以：

$${\rm\textbf{u}}\cdot {\rm\textbf{u}} = {\rm\textbf{v}}\cdot {\rm\textbf{v}} = {\rm\textbf{w}}\cdot {\rm\textbf{w}} = 1$$

$${\rm\textbf{u}}\cdot {\rm\textbf{v}} = {\rm\textbf{v}}\cdot {\rm\textbf{w}} = {\rm\textbf{w}}\cdot {\rm\textbf{u}} = 0$$

通过将旋转矩阵作用于 ${\rm\textbf{u}}$ , ${\rm\textbf{v}}$ , ${\rm\textbf{w}}$ ，我们可以推断出矩阵的行为，例如：

$$
{\rm\textbf{R}}_{uvw}{\rm\textbf{u}} = \left [ \begin{matrix}
    x_u & y_u & z_u \\
    x_v & y_v & z_v \\
    x_w & y_w & z_w \\
    \end{matrix} \right ] \left [ \begin{matrix}
    x_u \\
    y_u \\
    z_u \\
    \end{matrix} \right ]  = \left [ \begin{matrix}
    x_ux_u+ y_uy_u +z_uz_u\\
    x_vx_u+y_vy_u+z_vz_u \\
    x_wx_u+y_wy_u+z_wz_u \\
    \end{matrix} \right]
$$

注意 ${\rm\textbf{R}}_{uvw} {\rm\textbf{u}}$ 的三行都是点乘积，所以我们得到：

$$
{\rm\textbf{R}}_{uvw}{\rm\textbf{u}} = \left [ \begin{matrix}
    {\rm\textbf{u}}\cdot {\rm\textbf{u}}\\
    {\rm\textbf{v}}\cdot {\rm\textbf{u}} \\
    {\rm\textbf{w}}\cdot {\rm\textbf{u}} \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    1 \\
    0\\
    0 \\
    \end{matrix} \right] = {\rm\textbf{x}}
$$

类似的，可以算出 ${\rm\textbf{R}}\{uvw\}{\textbf{v}}={\textbf{y}} , {\textbf{R}}\{uvw\}{\textbf{w}}={\textbf{z}}.$ 所以我们可以通过在向量左边乘上 ${\rm\textbf{R}}\{uvw\}$ 这个矩阵， ${\rm\textbf{R}}\{uvw\}$ 通过这个矩阵提供的旋转变换将 $u, v, w$ 旋转到对应的 $x, y, z$ 坐标轴上。

如果 ${{\rm\textbf{R}}\{uvw\}}$ 是一个有正交行向量的旋转矩阵，那么 ${\rm\textbf{R}}^T\{uvw\}$ 就是带有正交列向量的旋转矩阵，其实这个矩阵就是原矩阵的逆矩阵（正交矩阵的性质）。重要的一点是，对于变换矩阵来说，对于矩阵取逆（代数逆）就是对于图形的变化取逆过程（几何逆）。也就是说，如果 ${\rm\textbf{R}}\{uvw\}$ 将 ${\rm\textbf{u}}$ 转向了 $\rm x$ ，那么 ${\rm\textbf{R}}^T\{uvw\}$ 就会将 $\rm x$ 转回 ${\rm\textbf{u}}$ 。对于 ${\rm\textbf{v}}$ 和 $\rm y$ 也一样。所以 **我们总是可以通过正交基来创建旋转矩阵。**

如果我们想要绕着一个任意向量 ${\rm\textbf{a}}$ 旋转，我们可以构建一个 ${\rm\textbf{w}}={\rm\textbf{a}}$ 的正交基 ，然后将这个正交基通过旋转变换到标准基坐标 ${\rm\textbf{xyz}}$ 下（也就是下面右乘的矩阵），然后绕 ${\rm\textbf{z}}$ 轴旋转（中间的矩阵），最后转回 ${\rm\textbf{uvw}}$ 坐标下（左边的矩阵）。用矩阵的形式表示，沿着 ${\rm\textbf{w}}$ 轴旋转 $\phi$ 角度的复合变换矩阵如下所示：

$$
\left [ \begin{matrix}
    x_u & x_v & x_w\\
    y_u & y_v & x_w\\
    z_u & z_v & x_w\\
    \end{matrix} \right ] \left [ \begin{matrix}
    \cos\phi & -\sin\phi & 0\\
    \sin\phi & \cos\phi & 0 \\
    0 & 0 & 1\\
    \end{matrix} \right ]  \left [ \begin{matrix}
    x_u & y_u & z_u\\
    x_v & y_v & z_v\\
    x_w & y_w & z_w\\
    \end{matrix} \right ]
$$

在这里我们给出了单位向量 ${\rm\textbf{w}}$ ，它是一个向着 ${\rm\textbf{a}}$ 方向的单位向量，那么 ${\rm\textbf{u}}$ 和 ${\rm\textbf{v}}$ 是什么呢？计算它们的方法已经在 2.4.6 节给出。

如果我们有一个旋转矩阵，然后希望由轴角的形式来进行旋转，我们可以计算一个实特征值（应该是 $\lambda = 1$ ），然后对应的特征向量就是旋转轴。这是一条不会因为旋转改变的轴。

除了旋转矩阵。还有一些表示旋转的常用方法，详见 16 章。

### 6.2.2 变换法向量

虽然大多数的三维向量我们用它用来表示位置（离原点的偏移）或表示方向，比如表示光的来源，但有些向量是用来表示表面法线的。表面法向量垂直于表面某点切平面。当变换曲面时，这些法向量并不会按照变换曲面的方式进行变换。比如，如果曲面上的所有点都被变换矩阵 ${\rm\textbf{M}}$ 进行了变换，那么与曲面相切的向量 ${\rm\textbf{t}}$ 在被 ${\rm\textbf{M}}$ 乘后就会与变换后的曲面相切。然而，法向量 ${\rm\textbf{n}}$ 被 ${\rm\textbf{M}}$ 乘后，不一定会垂直于变换后曲面的切平面，如图 6.17 所示。

我们可以计算一个变换矩阵 ${\rm\textbf{N}}$ ，这个矩阵将法向量 ${\rm\textbf{n}}$ 变为另外一个向量，而新向量将垂直于转换后的表面。那么怎么计算呢？ 一个方法是：注意到表面法向量和表面切向量是垂直的，因此它们的点积为 0：

$${\rm\textbf{n}^T}{\rm\textbf{t}} = 0$$

如果我们将转换后的向量记为 ${\rm\textbf{t}}_M =  {\rm\textbf{Mt}}$ ， ${\rm\textbf{n}}_N =  {\rm\textbf{Nn}}$ ，那么我们的目标是找到矩阵 ${\rm\textbf{N}}$ ，让 ${\rm\textbf{n}}_N^T {\rm\textbf{t}}_M = 0$ 。通过这个方程，我们可以用一些代数方面的小技巧来求解。首先，我们通过 ${\rm\textbf{I}}$ 的妙用，将上面的式子插入一个单位矩阵：

$${\rm\textbf{n}^T}{\rm\textbf{t}} = {\rm\textbf{n}^T}{\rm\textbf{It}}={\rm\textbf{n}^T}{\rm\textbf{M}^{-1}}{\rm\textbf{Mt}} = 0$$

然后，通过结合律：

$$({\rm\textbf{n}^T}{\rm\textbf{M}^{-1}})({\rm\textbf{Mt}}) = ({\rm\textbf{n}^T}{\rm\textbf{M}^{-1}}){\rm\textbf{t}}_M = 0$$

这意味着垂直于 ${\rm\textbf{t}}_M$ 的行向量正是上面括号内乘出来的向量。这个表达式适用于切平面中的任意切向量。由于在空间中只有一个向量（及其相反方向的向量）垂直于切平面，所以左边乘出来的那个行向量一定是 ${\rm\textbf{n}_N}$ ，也就是 ${\rm\textbf{n}_N^T}$ 。这就有了一个办法来推导 ${\rm\textbf{N}}$ ：

$${\rm\textbf{n}^T}_N = {\rm\textbf{n}^T}{\rm\textbf{M}^{-1},}$$

然后我们将其转置，得到：
$${\rm\textbf{n}_N} = ({\rm\textbf{n}^T}{\rm\textbf{M}^{-1}})^T = ({\rm\textbf{M}^{-1}})^T{\rm\textbf{n}}$$

因此，我们看到能够正确地变换法向量，让它变换后依然是法向量的矩阵是 ${\rm\textbf{N}} = ({\rm\textbf{M}^{-1})^T}$ ，也就是原矩阵取逆的转置。因为这个矩阵可能会改变 ${\rm\textbf{n}}$ 的长度，我们可以将该向量乘一个任意数，这样它能始终指向正确的方向。矩阵的逆是余子式矩阵的转置再除以该矩阵的行列式 _[5.3，行列式和矩阵]_ 。由于我们不关心法向量的长度，所以我们可以跳过矩阵的除法，最后得到，对于一个 $3\times 3$ 矩阵，

$$
{\rm\textbf{N}} = \left [ \begin{matrix}
    m^c_{11} & m^c_{12} & m^c_{13} \\
    m^c_{21} & m^c_{22} & m^c_{23} \\
    m^c_{31} & m^c_{32} & m^c_{33} \\
    \end{matrix} \right ]
$$

这里我们假设了 $m_{ij}$ 是矩阵 ${\rm\textbf{M}}$ 的第 $i$ 行第 $j$ 列的元素。最终我们得到 ${\rm\textbf{N}}$ 的完整表达式是：

$$
{\rm\textbf{N}} = \left [ \begin{matrix}
    m_{22}m_{33}-m_{23}m_{32} & m_{23}m_{31}-m_{21}m_{33} & m_{21}m_{32}-m_{22}m_{31} \\
    m_{13}m_{32}-m_{12}m_{33} & m_{1}m_{33}-m_{13}m_{31} & m_{12}m_{31}-m_{11}m_{32} \\
    m_{12}m_{23}-m_{13}m_{22} & m_{13}m_{21}-m_{11}m_{23} & m_{11}m_{22}-m_{12}m_{21} \\
    \end{matrix} \right ]
$$

## 6.3 平移和仿射变换

我们一直在研究如何使用矩阵 ${\rm\textbf{M}}$ 来给变换向量。在二维空间中，这些变换的形式为：

$$x' = m_{11}x+m_{12}y $$
$$y' = m*{21}x+m*{22}y $$

但我们不能使用这样的变换来 _移动_ 物体。只能进行缩放和旋转。尤其是原点 $(0,0)$ 在线性变换中永远保持不变。想要移动或平移（Translate）一个物体，使其所有的点都移动相同的量，我们需要下面这样的变换形式：

$$x' = x+x_t $$
$$y' = x+y_t $$

而通过将 $(x,y)$ 左乘一个 $2\times2$ 矩阵并不能实现这样的效果。将平移加到我们的线性变换系统的一个简单方法是将一个平移向量与每个变换矩阵 **关联** _(参见非线性方程组)_ ，让矩阵接管旋转缩放，向量来控制平移。这完全可行，但是使用这种方法的后续管理工作很麻烦，而且进行 **组合变换** 时，它们将不再变得清晰明了。

作为替代，我们可以使用一点小技巧，让一个单独的矩阵乘法能同时包含上述两种操作：将点坐标 $(x,y)$ 重新表示为一个三维向量 $[x,y,1]^T$ ，然后使用下面所示的 $3\times3$ 矩阵：

$$
\left [ \begin{matrix}
    m_{11} & m_{12} & x_t \\
    m_{21} & m_{22} & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ]
$$

第三行是固定的，用于将 1 固定到转换后向量的最后一个元素处。而该向量的前两个元素值分别就是关于原向量 $x, y$ 的线性组合：

$$
{\rm\textbf{N}} = \left [ \begin{matrix}
    x' \\
    y' \\
    1  \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    m_{11} & m_{12} & x_t \\
    m_{21} & m_{22} & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    x \\
    y \\
    1  \\
    \end{matrix} \right ]  = {\rm\textbf{N}} = \left [ \begin{matrix}
    m_{11}x+m_{12}y+x_t \\
    m_{21}x+m_{22}y+y_t \\
    1  \\
    \end{matrix} \right ]
$$

我们用单个矩阵就囊括了线性变换！这样的变换我们称作 **仿射变换** 。而这种通过增加一个维度来实现仿射变换的方法称作 **齐次坐标法（Roberts，1965；Riesenfield，1981；Penna&Patterson，1986）** 。齐次坐标不仅仅让实现变换的代码变得清晰明了，而且它让两个变换组合而成的组合变换变得清晰易懂。

但这种新方式也带来了一个问题：当我们需要变换一个不表示位置，只表示 **方向** 或偏移量的向量时，这个向量不应该被改变。而这时，解决办法就是将该向量的第三元素设置为 0：

$$
\left [ \begin{matrix}
    1 & 0 & x_t \\
    0 & 1 & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    x \\
    y \\
    0 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    x \\
    y \\
    0 \\
    \end{matrix} \right ]
$$

这样，我们对该向量做缩放/旋转变换，矩阵左上角的 $2\times 2$ 部分会作用于向量，但后面的平移将相乘得到 0 。此外，向量的第三元素在变换后仍然为 0 ，所以方向向量在变换后仍然为方向向量。

这正是我们想要的结果，所以平移变换可以通过这种方式完美融入该系统：指定额外元素是 0 或是 1 ，取决于我们想要对位置还是方向进行编码。我们需要这样的其次坐标来将位置向量和其他向量分开。如：

$$
\left [ \begin{matrix}
    3 \\
    2 \\
    1 \\
    \end{matrix} \right ] \ is \ a \ location \ , \ \left [ \begin{matrix}
    3 \\
    2 \\
    0 \\
    \end{matrix} \right ] is \ a \ displacement \ or \ direction
$$

过会儿我们讨论透视投影的时候，我们将会发现当该齐次坐标不采用 0 和 1 的时候用处会更大。

在图形系统中，齐次坐标几乎无处不在。而且，齐次坐标是图形硬件中设计和操作渲染器的基础。我们将在 _[第 7 章]_ 看到，齐次坐标使构建透视场景变得更容易。这也是它如此流行的原因。

齐次坐标可以当作一个存储平移变换的好方法。但对于几何方面的解释，有一种不同的说法。主要是，当我们在三维进行基于 z 轴的 _切变_ 时，也是下面这个形式：

$$
\left [ \begin{matrix}
    1 & 0 & x_t \\
    0 & 1 & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    x \\
    y \\
    z \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    x+x_tz \\
    y+y_tz \\
    z \\
    \end{matrix} \right ]
$$

这个样子和二维的平移变换就相差那么一丢丢。只不过这个切变多了一个 z ，z 在二维中没有意义。所以我们通过指定 $z=1$ ，就可以将平移变换用矩阵的形式使用了。比如：首先，在二维平面中移动 $(x_t,y_t)$ 的距离，然后旋转角度 $\phi$ ，就可以用下面的矩阵表示：

$$
{\rm\textbf{M}} = \left [ \begin{matrix}
    \cos\phi & -\sin\phi & 0 \\
    \sin\phi & \cos\phi & 0 \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & 0 & x_t \\
    0 & 1 & y_t \\
    0 & 0 & 1\\
    \end{matrix} \right ]
$$

别忘了，现在的二维旋转矩阵是 $3\times 3$ 了，而且在表示平移的那一列是 0 。通过这种矩阵规范，我们可以将任意数量的二维 **切变、旋转、平移** 组合到一个三维的矩阵中。这个三维矩阵的最后一行永远都是 $(0,0,1)$ ，因此我们其实没啥必要存储它，毕竟这样还能省点空间。只需要在进行计算的时候，我们把最后一行加上即可。

在三维空间中，这样的技巧同样适用，只需要添加第四维度即可，对于方向向量也一样，将第四个坐标设置为 0 就能让它不受平移的影响了。

### 重要例子

在图形学中，我们经常会需要构建变换矩阵。而且图像不一定在原点。如：构建一个变换矩阵，让这两个点 $[x_l,x_h]\times[y_l,y_h]$ 构成的矩形变换到 $[x_l',x_h']\times[y_l',y_h']$ 。此时，我们通过下面的步骤解决问题会更加直观：

1. 将 $(x_l,y_l)$ 移动到原点
2. 将矩形缩放到目标矩形的尺寸
3. 将原点移回到 $(x_l',y_l')$

别忘了右边的矩阵先产生作用。这样我们有：

$${\rm Windows} = {\rm translate}(x_l',y_l') \ {\rm scale}(\frac{x_h'-x_l'}{x_h-x_l},\frac{y_h'-y_l'}{y_h-y_l}) \ {\rm translate}(-x_l,-y_l)$$

$$
= \left [ \begin{matrix}
    1 & 0 & x_l' \\
    0 & 1 & y_l' \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    \frac{x_h'-x_l'}{x_h-x_l} & 0 & 0 \\
    0 & \frac{y_h'-y_l'}{y_h-y_l} & 0 \\
    0 & 0 & 1\\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & 0 & -x_l \\
    0 & 1 & -y_l \\
    0 & 0 & 1\\
    \end{matrix} \right ]
$$

$$
= \left [ \begin{matrix}
    \frac{x_h'-x_l'}{x_h-x_l} & 0 & \frac{x_l'x_h-x_h'x_l}{x_h-x_l} \\
    0 & \frac{y_h'-y_l'}{y_h-y_l} & \frac{y_l'y_h-y_h'y_l}{y_h-y_l} \\
    0 & 0 & 1\\
    \end{matrix} \right ]
$$

有一个重要的变换，可以构成一个类，叫 _刚体变换_ 。这种变换只由平移和旋转组成，因此它们不会对物体进行拉伸或收缩。

## 6.4 变换矩阵的逆

对于一个可逆矩阵，我们可以通过代数方法去求它的逆，同时，如果我们知道了几何逆干了甚么，我们也可以使用几何方法求逆。比如，缩放 $(s_x,s_y,s_z)$ 的逆是 $(1/s_x,1/s_y,1/s_z)$ 。而旋转 $\phi$ 角度的几何逆是旋转 $-\phi$ 角度，平移的逆过程是向相反方向平移。如果我们有一个复合变换矩阵 $\rm\textbf{M} = \rm\textbf{M}_1\textbf{M}_2\cdots\textbf{M}_n$ ，那么它的逆就是

$$\rm\textbf{M}^{-1} = \rm\textbf{M}_n^{-1}\textbf{M}_{n-1}^{-1}\cdots\textbf{M}_1^{-1}$$

同样的，对于确定类型的变换矩阵，求逆很容易。我们已经提到过缩放矩阵，它是对角阵，第二个重要的例子是旋转矩阵，它是正交矩阵。我们在 _[5.2.4 节]_ 说过，正交矩阵的逆矩阵就是它的转置。这个性质让它能很轻松的得到旋转的逆和刚体变换的逆。除此之外，如果一个矩阵的底部有 $[0 \ 0 \ 0 \ 1]$ ，那么这个矩阵的逆的底部也有 $[0 \ 0 \ 0 \ 1]$ 。

有趣的是，我们可以使用奇异值分解来对一个矩阵取逆。因为我们知道，所有的矩阵都可以被分解为旋转乘缩放再乘旋转，所以将它们取逆是很简单的。比如：在三维空间中，有：

$${\rm\textbf{M}} = {\rm\textbf{R}_1}\cdot {\rm scale}(\sigma_1,\sigma_2,\sigma_3)\cdot{\rm\textbf{R}_2}$$

根据穿脱法则，有：

$${\rm\textbf{M}^{-1}} = {\rm\textbf{R}_2^T \cdot{\rm scale}(\frac{1}{\sigma_1},\frac{1}{\sigma_2},\frac{1}{\sigma_3})}\cdot{\rm\textbf{R}_1^T}$$

只需要算出各个部分即可求逆。

## 6.5 坐标转换

前面讨论的所有内容都是在讲怎么通过变换矩阵来移动点。但我们也可以讲这个操作视为 **改变这个点所在的坐标系** 。例如，在 _[图 6.19]_ 中，我们看到了描述运动的两种方法。在不同的情况下，这两者中的其中一种会更适用。

比如，一个赛车游戏可能会有一个城市的模型和一个车辆的模型。如果游戏向玩家展示的是挡风玻璃外面的视角，那么车内的物体会始终绘制在屏幕的固定位置，同时当玩家开始驾驶时，街景和建筑物开始向后移动。每一帧上我们都会对窗外的事物进行一次变换，让他们相比于上一帧更远。实现这种效果的一种方法是简单地讲建筑物向后移动；另外一种方法则是建筑物不动，但改变我们生成视图的坐标系，让坐标系动起来。后面这种方法所作的变换是在改变城市几何体的坐标，并将城市几何体的坐标表示为车内的坐标。两种方法加在车辆外部几何体的变换矩阵在最后都是完全相同的。

如果这个游戏同样支持俯瞰视角，来让玩家看见车辆在城市中的位置的话，那么建筑和街景就需要在固定位置生成，车辆则需要一帧一帧的移动。正如上面所说的，也有两种方法可以使用。我们可以想象将汽车从世界坐标系的原位置移动到目标位置，或者可以想象这个过程是对车辆的几何体坐标的转换（这个坐标附着在车辆几何上），而不是让固定在城市的坐标系移动。这两种转换坐标的 **转换矩阵** 清楚的说明了两种模式（车相对于城市、城市相对于车）执行的变换 **互为逆矩阵** 。

改变坐标系的思想和编程中的 _类型转换_ 很相似。在我们能够让浮点数和整数相加之前，我们首先需要将整数转换为浮点数，让类型能够匹配。所以当我们一起生成汽车和城市之前，我们需要将车辆坐标转换为城市坐标，或者取决于我们的需要反着来，这样坐标才能匹配。

在管理多个坐标系的时候，会很容易混淆，最后让对象坐标错误，导致对象在不该出现的地方出现。但我们通过系统地思考坐标系之间的转换，我们可以得到准确的转换。

几何上来说，一个坐标系统（坐标框架）由一个 _原点_ 和一个 _基_ （三个向量组成的集合）构成。正交基非常方便，所以我们说到坐标系，如果没有另外说明，就假设它们是正交的。在一个原点为 ${\rm\textbf{p}}$ ，基是 $\{ {\rm\textbf{u,v,w}} \}$ 的坐标框架中，坐标 $(u,v,w)$ 这样表示：

$${\rm\textbf{p}}+u{\rm\textbf{u}}+v{\rm\textbf{v}}+w{\rm\textbf{w}}.$$

当我们在计算机中存储这些向量时，它们需要采用某种坐标系来进行表示。开始之前，我们要设计一些标准坐标系，通常称为 **全局坐标/世界坐标** ，用于表示和区分其他的坐标系。比如在我们上面说的这个城市里，我们可能会采用 _街道网格_ ，按照惯例将 $x$ 轴设定在主街道， $y$ 轴指向上方， $z$ 轴沿着中央大道。然后我们就能清晰的指定车辆坐标系的原点和基。

在二维平面，我们通常使用 ${\rm\textbf{o}}$ 作为原点， ${\rm\textbf{x}}$ 和 ${\rm\textbf{y}}$ 作为右手基向量。

> 注：在二维平面，“右手”是指从 ${\rm\textbf{x}}$ 开始逆时针到 ${\rm\textbf{y}}$ 。

但与此同时，可能会有另外一个坐标，使用 ${\rm\textbf{e}}$ 作为原点， ${\rm\textbf{u}}$ 和 ${\rm\textbf{v}}$ 作为基，这时请注意，标准坐标系不会被显式存储，因为它们作为别的坐标系的参考系。在该坐标系中， ${\rm\textbf{p}}$ 的位置就会被记为有序数对作为简写：

$${\rm\textbf{p}} = (x_p,y_p) = {\rm\textbf{o}}+x_p{\rm\textbf{x}}+y_p{\rm\textbf{y}}$$

下面来看 _[图 6.20]_ 的例子：在这里， $(x_p,y_p) = (2.5,0.9)$ ，注意这个坐标已经假定了坐标原点 ${\rm\textbf{o}}$ 。相似地，我们可以用另一个方程表示 ${\rm\textbf{p}}$ ：

$${\rm\textbf{p}} = (x_p,y_p) = {\rm\textbf{e}}+u_p{\rm\textbf{u}}+v_p{\rm\textbf{v}}$$

而在图中另外一个坐标系，这个点的坐标是 $(u_p,v_p) = (0.5,-0.7)$ 。同样，其他信息被省略了。

我们也可以用矩阵来表示同样的关系：

$$
\left [ \begin{matrix}
    x_p \\
    y_p \\
    1\\
    \end{matrix} \right ] = \left [ \begin{matrix}
    1 & 0 & x_e \\
    0 & 1 & y_e \\
    0 & 0 & 1 \\
    \end{matrix} \right ] \left [ \begin{matrix}
    x_u & x_v & 0 \\
    y_u & y_v & 0 \\
    0 & 0 & 1 \\
    \end{matrix} \right ]\left [ \begin{matrix}
    u_p \\
    v_p \\
    1\\
    \end{matrix} \right ]  = \left [ \begin{matrix}
    x_u & x_v & x_e \\
    y_u & y_v & y_e \\
    0 & 0 & 1 \\
    \end{matrix} \right ] \left [ \begin{matrix}
    u_p \\
    v_p \\
    1\\
    \end{matrix} \right ]
$$

值得注意的是，这里假设了我们将点 ${\rm\textbf{e}}$ 和向量 ${\rm\textbf{u}}$ 、 ${\rm\textbf{v}}$ 存储在了标准坐标系下，而该等式的第一项是默认了 $(x,y)$ 标准坐标系。根据我们在这一张讨论的变换基本类型，这是一个 **旋转变换** （涉及 ${\rm\textbf{u，v}}$ ），然后进行了一个 **平移变换** （涉及 ${\rm\textbf{e}}$ ）。让我们同时看旋转和平移矩阵，你会发现写下它们很容易：我们只需要将 ${\rm\textbf{u，v，e}}$ 放在这个矩阵的第 1，2，3 列，然后加上最后一行 $[0 \ 0 \ 1]$ 即可。如下：

$$
{\rm\textbf{p}}_{xy} = \left [ \begin{matrix}
    {\rm\textbf{u}} & {\rm\textbf{v}} & {\rm\textbf{e}} \\
    0 & 0 & 1 \\
    \end{matrix} \right ] {\rm\textbf{p}}_{uv}
$$

我们将这个矩阵称为 **_坐标框架-标准坐标矩阵_** 。它接收框架坐标 $(u,v)$ ，然后将它转换为标准坐标系下的坐标。

反过来，我们有：

$$
\left [ \begin{matrix}
    u_p \\
    v_p \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    x_u & y_u & 0 \\
    x_v & y_v & 0 \\
    0 & 0 & 1 \\
    \end{matrix} \right ] \left [ \begin{matrix}
    1 & 0 & -x_e \\
    0 & 1 & -y_e \\
    0 & 0 & 1 \\
    \end{matrix} \right ]\left [ \begin{matrix}
    x_p \\
    y_p \\
    1\\
    \end{matrix} \right ]
$$

这是一个先平移，后旋转的变换：也就是之前那个（先旋转再平移）的逆变换。当这两个变换矩阵相乘组合后，产生的矩阵正是上面那个矩阵（从坐标框架到标准坐标）的 **逆矩阵** 。也就是 **_标准坐标-坐标框架矩阵_** ：

$$
{\rm\textbf{p}}_{uv} = \left [ \begin{matrix}
    {\rm\textbf{u}} & {\rm\textbf{v}} & {\rm\textbf{e}} \\
    0 & 0 & 1 \\
    \end{matrix} \right ] ^{-1} {\rm\textbf{p}}_{xy}
$$

同样的，标准坐标-坐标框架矩阵接收一个标准坐标系的点，并将它转换为 $(u,v)$ 坐标系中的点。我们把这个矩阵简单的标了个逆，是因为它不能使用 ${\rm\textbf{e,u,v}}$ 的标准坐标立即写出来。但请记住，所有坐标系都是等效的，使用 $x$ 和 $y$ 来存储坐标只是我们的习惯，让它看上去不对等。标准坐标-坐标框架矩阵可以简单的表示为 ${\rm\textbf{o,x,y}}$ 的坐标：

$$
{\rm\textbf{p}}_{uv} = \left [ \begin{matrix}
    {\rm\textbf{x}}_{uv} & {\rm\textbf{y}}_{uv} & {\rm\textbf{o}}_{uv} \\
    0 & 0 & 1 \\
    \end{matrix} \right ]  {\rm\textbf{p}}_{xy}
$$

**以上的所有结论再三维空间均可用。**

## 常见问题

- **_我难道不能直接摁算摁编程，而不采用这种矩阵形式吗？_**

  当然可以。但实际上，这样做更难推导，更难 debug，效率也不高。而且，当下所有的图形 API 都采用了矩阵形式，你要是用图形库，就必须理解它。

- **_矩阵的底部永远是_** $[0 \ 0 \ 0 \ 1]$ ，**_那么我还要存储它吗？_**

  除非包含了**透视变换** _[第 7 章]_ ，否则不需要存储。

# 第七章 视图变换

**在上一章，我们见识了怎么使用矩阵工具来对二维或三维物体进行变换。几何变换的第二个重要内容是如何将物体在三维空间中移动，同时在二维视角中呈现这一内容。这种从三维到二维的变换称之为 _视图变换_ ，在以对象为顺序的渲染中起着重要作用。在这个过程中，我们需要快速的找到每个物体的图像-空间位置。**

**当我们在第四章学习光线追踪时，我们就介绍了不同种类的透视和正交视图；以及介绍了如何在任意视角生成视角光线。这一章的内容就是把这个过程反过来。在这里我们会解释如何使用矩阵变换来表示任意平行或透视视图。本章中的变换将场景（世界空间）的三维点投影到图像（图像空间）中的二维点上，并将给定像素的观察光线上的如何点投影回该像素在图像空间中的位置。**

**若你忘了之前将的内容，建议重新回顾 [第四章] 。**

**就其本身而言，将点从真实世界投影到图像上的能力仅适用于生成 _线框渲染_ ——仅绘制物体的边缘，而且较近的表面 _不会遮挡_ 较远的表面（见 _[图 7.1]_ ）。正如光线追踪需要找到离他最近的交点一样，显示物体实体外观的对象顺序渲染器必须分辨出多个曲面中哪个离屏幕最近，并仅显示该曲面。在这章中，我们假设我们绘制的图形仅包含 _三维线段_ ，并通过 $(x,y,z)$ 格式的两个端点进行表示。后面的章节才会讲到实体表面渲染所需的方法。**

## 7.1 视图变换

视图变换的工作是：将通过 $(x,y,z)$ 表示的三维坐标位置，转化为以像素为单位的图像。它很复杂，这取决于很多方面：相机的方向和位置、投影方法、可视角度、以及图像分辨率。我们在之前已经学到，复杂的变换可以分解为几个简单变换的叠加，视图变换也可以这样。大多数的图形系统使用下面三种变换序列来实现视图变换：

- **相机变换/眼睛变换** ：是一种 _刚体变换 [见 6.3 重要例子]_ ，它能将照相机以合适的朝向放在原点。它只能决定相机的 _位置和方向_ 或者说， _姿势_ 。
- **投影变换** ：它能将摄影机空间中投影点，让所有的点的 $x$ 和 $y$ 都落在 $[-1,1]$ 中。它只能决定 _所需要的投影类型_ 。
- **视口变换/窗口变换** ：它能将上面的单位图像矩阵映射到像素坐标。它只能决定 _图像输出的大小和位置_ 。

> 有些 API 只把 _相机变换_ 称作视图变换。

为了更好的描述这个变换过程（见图 7.2），我们给进行上述变换所使用的不同坐标系起了不同的名字。

相机变换将 **标准坐标** 中的点转换为 **相机坐标** ，而投影变换将那些点从 **相机坐标** 转换为 **标准视图坐标** ，最后，视口变换将 **标准视图坐标** 映射为 **屏幕空间** 。

上面那三个转换都是独立的，但非常简单。我们会先从 **正交投影** 的案例来讨论视口变换，然后讨论 **透视投影** 下的变换。

> 其他的名字：相机空间也叫眼睛空间；相机变换因此也会被叫做视图变换。标准视图坐标也叫做裁剪空间、标准化设备坐标；屏幕空间也叫做像素坐标。

### 7.1.1 视口变换

我们从一个例子开始，这个例子的解决方案将是通用的：

假设我们要观察的几何体是在 **标准视图空间** 中的，同时我们希望产生正交投影的相机的观察方向是 $-z$ 。 _标准立方体_ 包含了所有在 $x,y,z$ 的 $[-1,1]^3$ 范围内的所有点（见图 7.3）。我们将 $x=-1$ 投影在屏幕左边， $x=1$ 投影在屏幕右边， $y=-1$ 投影在屏幕底部， $y=1$ 投影在顶部。

> 标准 (Canonical) 这个词老是出现。我们选用这个词主要是因为它表述方便。比如标准圆 (Canonical Circle) 就的意思就是单位圆 (Unit Circle)。

请回忆一下第三章的知识，我们做了一个约定：每个像素都占有一块以 **整数坐标为中心的正方形区域** 。同时在图像的边界会相比像素中心超出一半像素的长度。最后，最小像素中心的坐标是 $(0,0)$ 。因此，如果我们需要绘制一幅像素为 $n_x\times n_y$ 的图像，那么我们需要将标准平面 $[-1,1]^2$ 映射到矩形 $[-0.5,n_x-0.5]\times [-0.5,n_y-0.5]$ 的区域上。

现在，我们假设所有需要绘制的线段都在 **标准立方体** 中。在之后我们讲到 _裁剪_ 的时候我们会放宽松这个假设。

> 注：将一个正方形映射到一个长方形并不是什么问题。我们只需要给 $x$ 和 $y$ 不同的缩放系数即可。

由于我们要进行的视口变换是将一个轴对齐的矩形映射到另外一个矩形，所以下面的公式是视口变换的一种形式：

$$
\left [ \begin{matrix}
    x_{\rm screen} \\
    y_{\rm screen} \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    \frac{n_x}{2} & 0 & \frac{n_x-1}{2} \\
    0 & \frac{n_y}{2} & \frac{n_y-1}{2} \\
    0 & 0 & 1 \\
    \end{matrix} \right ]  \left [ \begin{matrix}
    x_{\rm canonical} \\
    y_{\rm canonical} \\
    1 \\
    \end{matrix} \right ]
$$

请注意，这个矩阵忽略了标准立方体中的 $z$ 轴量。因为点沿投影方向的距离不会影响该点在图像中的投影位置。但是在我们正式称它为 _“视口矩阵”_ 之前，我们需要添加一行一列，以达到不改变 $z$ 的作用。尽管这一节我们不需要它，但最终 $z$ 值的存在是有必要的，（用于判断远近曲面的关系）。

所以，视口矩阵：

$$
{\rm\textbf{M}_{vp}} = \left [ \begin{matrix}
    \frac{n_x}{2} & 0 & 0 & \frac{n_x-1}{2} \\
    0 & \frac{n_y}{2} & 0 & \frac{n_y-1}{2} \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]
$$

### 7.1.2 投影变换：正交投影变换

**正交投影的步骤如下：**

1. **固定相机（相机变换）**
2. **把 $z$ 轴扔了**
3. **转换为标准正方形 $[-1,1]^2$ .**

一般情况下我们不希望在 **标准立方体** 之外的地方渲染几何体。我们要做的第一步是 在固定视角方向 (朝着 $-z$ 方向， $+y$ 在摄像机头顶) 的同时，能看到任意的矩形。我们不会替换视口矩阵，而是通过将其与右侧的另一个矩阵相乘来计算。

在这些约束条件下，视图空间是一个轴对齐的长方盒子，我们将这个盒子的不同面使用下面的方式命名： $[l,r]\times [b,t]\times [f,n]$ ，如 [图 4.7] 。我们将这个长方盒称作 **正交立方体** ，它的各个平面如下：

$$x=l \equiv \rm left \ plane $$
$$x=r \equiv \rm right \ plane $$
$$y=b \equiv \rm bottom \ plane $$
$$y=t \equiv \rm top \ plane $$
$$z=n \equiv \rm near \ plane $$
$$z=f \equiv \rm far \ plane $$

这些定义假定了观察者是往 $-z$ 轴方向看，头顶对着 $y$ 轴方向。

> 注：很多程序员发现， $x$ 轴指向右， $y$ 轴指向上是很有用的。在一个右手系中，这就表明了我们的视角方向是 $-z$ 轴。同时有一些系统采用左手系，那么视角方向就是 $z$ 轴方向。左手系的系统在文末有标明。

接上面，由于这样规定，所以我们默认 $n>f$ ，但是如果你假设了整个视图都在 $z<0$ 的区域，那么当且仅当 $n>f$ 时， $n$ 平面（近平面）才是真正的离观察者“近”。

上面这个概念在 [图 7.5] 中展示。从 **正交立方体** 变换到 **标准立方体** 的转换是另外一个转换。我们可以简单的将正交视图和标准视图的 **边界** 代入到 [6.3 重要例子] 中的方程中。这样我们可以得到该转换的矩阵：

$$
{\rm\textbf{M}_{orth}} = \left [ \begin{matrix}
    \frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l} \\
    0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\
    0 & 0 & \frac{2}{n-f} & -\frac{n+f}{n-f} \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]
$$

别忘了我们的目标是绘制三维线段。为了达成目标，我们需要将其投影到画面上，忽略 $z$ 坐标。我们通过将两个变换矩阵组合的方式来完成。注意，在程序中，我们先将这两个矩阵相乘，再进行下一步操作：

$$
\left [ \begin{matrix}
    x_{\rm pixel} \\
    y_{\rm pixel} \\
    z_{\rm canonical} \\
    1 \\
    \end{matrix} \right ] = ({\rm\textbf{M}_{vp}}{\rm\textbf{M}_{orth}})\left [ \begin{matrix}
    x \\
    y \\
    z \\
    1 \\
    \end{matrix} \right ]
$$

> 注：这就是使用矩阵进行变换能让程序变得简洁的奥秘！

这下子 $z$ 轴坐标就会在 $[-1,1]$ 中了。虽然我们现在没有使用这一点，但在后续的 _z-buffer 算法_ 中会很有用。

对于构造三维线段的伪代码，会变得简洁清爽：

```java
construct M_vp
construct M_orth

M = M_vp * M_orth

for each line segment(a_i,b_i) do{
    p = M * a_i;
    q = M * b_i;
    drawline(x_p,y_p,x_q,y_q);
}

```

### 7.1.3 相机变换

我们希望能够在三维空间中改变视角，让照相机能够看向任何方向。对于相机的位置和朝向，我们使用下面这种约定：

- 眼睛位置 **e**
- 注视方向 **g**
- 头顶方向向量 **t**

眼睛位置是指眼睛“从什么地方看”的位置。如果认为图形计算是一种摄影的过程，那么眼睛位置就是镜头的中心。注视方向是观察者注视方向的方向向量。头顶方向向量是平面中的任何向量。加入相机在地上，该向量将观察者的头部平分为左右两半，并让相机的顶部指向天空。这些向量为我们提供了足够的信息来以 $\rm\textbf{e}$ 为原点， $\rm\textbf{u,v,w}$ 为基建立一个坐标系。其中：

$$\rm\textbf{w} = -\frac{\textbf{g}}{\parallel \textbf{g} \parallel}$$
$$\rm\textbf{w} = -\frac{\textbf{t}\times \textbf{w}}{\parallel \textbf{t}\times \textbf{w} \parallel}$$
$$\rm\textbf{v} = \rm\textbf{w}\times \rm\textbf{u}$$

如果我们所希望变换的所有点都以上述坐标系（**e，uvw**）存储，那么就可以下班了！可是，正如 [图 7.7] 所示，模型坐标是存储在标准坐标系（**o，xyz**）中的。那么如果要让他们能够适配我们写好的这些计算过程，我们需要将绘制的线段端点的坐标从 $xyz$ 坐标系转化成 $uvw$ 坐标系中。这种转化方式在 [6.5 节] 中讨论过，实现这种变换的矩阵是相机坐标系的标准基矩阵：

$$
{\rm\textbf{M}_{cam}} = \left [ \begin{matrix}
    {\rm\textbf{u}} & {\rm\textbf{v}} & {\rm\textbf{w}} & {\rm\textbf{e}} \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]^{-1} = \left [ \begin{matrix}
    x_u & y_u & z_u & 0 \\
    x_v & y_v & z_v & 0 \\
    x_w & y_w & z_w & 0 \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]\left [ \begin{matrix}
    1 & 0 & 0 & -x_e \\
    0 & 1 & 0 & -y_e \\
    0 & 0 & 1 & -z_e \\
    0 & 0 & 0 & 1 \\
    \end{matrix} \right ]
$$

或者我们也可以把这种变换理解为：先将 ${\rm\textbf{e}}$ 移动到原点 ${\rm\textbf{o}}$ ，然后将 ${\rm\textbf{uvw}}$ 和 ${\rm\textbf{xyz}}$ 对齐。

> 译者注：有看不懂的吗？其实，我们可以想象这个变换是从标准坐标到相机坐标的逆过程。上面的矩阵取逆就是这个意思。而根据矩阵分块，只需对前 $3 \times 3$ 的矩阵取逆。巧了！这个矩阵因为是正交矩阵，所以转置就是它的逆，综上所述，得到了 ${\rm\textbf{M}_{cam}}$ 矩阵。

为了让我们这种算法（仅适用于 $z$ 轴方向观察）适用于任何方向的相机，我们只需要将这种相机变换添加到视口变换和投影变换的乘积中进行组合即可。这样可以在投影之前将原来的世界坐标转换为相机坐标。伪代码如下：

```java
construct M_vp
construct M_orth
construct M_cam
M = M_vp * M_orth * M_cam

for each line segment(a_i,b_i) do{
    p = M_ai
    q = M_bi
    drawline(x_p, y_p, x_q, y_q)
}
```

## 7.2 透视变换

单独出一章节足以显示它的重要性。透视投影需要一些小技巧，来让它匹配我们之前推理得出的向量和矩阵的变换系统。为了更好的理解我们需要做什么，先来看看透视变换需要在 _相机空间_ 中做什么工作。别忘了，视点是位于原点的，相机沿着 $z$ 轴进行观察。

> 注：这里是沿着 $z$ 轴方向，因为我们为了方程更简单忽略了 $z$ 值的正负。在 [7.3 透视投影] 中，我们会考虑正负。

透视图的关键特性在于屏幕上看到的物体大小与 $\frac{1}{z}$ 成正比（相机在原点，看向 $-z$ 轴方向）。这个现象可以用 [图 7.8] 中的方程表示。

$$y_s = \frac{d}{z}y$$

其中， $y$ 是该点的 $y$ 轴坐标， $y_s$ 是需要在屏幕上绘制的位置的 $y$ 值。

如果能够使用刚才我们研究出来的针对正交投影的一套系统，那么就可以将另外一个新的矩阵与之前的矩阵进行组合变换，然后使用已有的算法，那将是极好的。可惜换不得，这样的变换，输入坐标向量会出现在分母位置，所以不能使用 _仿射变换_ 来实现。

但我们可以通过在仿射变换中 **对齐次坐标的推广** 来允许这样的除法。我们已经可以使用 $[x \ y \ z \ 1]^T$ 这样的齐次向量来表示点 $(x,y,z)$ 。其中拓展位始终为 **1** ，这是由 $[0 \ 0 \ 0 \ w]^T \ (w=1)$ 作为仿射变换矩阵的最后一行来保证的。

更绝的是，我们没有必要让最后这个 $w$ 一定是 **1** 。而是可以将其定义为 $xyz$ 坐标的分母。这样，当齐次向量为 $[x \ y \ z \ w]^T$ 时，代表的就是点 $(\frac{x}{w},\frac{y}{w},\frac{z}{w})$ 。使用除了 **1** 以外的其他值可以允许更大的变换。

具体地说，线性变换允许我们计算像下面这样的表达式：

$$x' = ax + by + cz$$

仿射变换能将其拓展为：

$$x' = ax + by + cz+d$$

而让 $w$ 作为分母，增加了更多的可能性，可以让我们计算如下函数：

$$x' = \frac{ax + by + cz + d}{ex + fy + gz + h}$$

这就可以称作是关于 $x,y,z$ 的 **_线性有理函数_** 。但需要满足的一个条件是，所有坐标的分母都应该相同。

表示为矩阵变换，就是：

$$
\left [ \begin{matrix}
    \bar x \\
    \bar y \\
    \bar z \\
    \bar w \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    a_1 & b_1 & c_1 & d_1 \\
    a_2 & b_2 & c_2 & d_2 \\
    a_3 & b_3 & c_3 & d_3 \\
    e & f & g & h \\
    \end{matrix} \right ]\left [ \begin{matrix}
    x \\
    y \\
    z \\
     1 \\
    \end{matrix} \right ]
$$

以及：
$$(x',y',z') = (\frac{\bar x}{\bar w},\frac{\bar y}{\bar w},\frac{\bar z}{\bar w})$$

像这样的变换称为 **投影变换** 。

### 例子

下面的矩阵：

$$
\left [ \begin{matrix}
    2 & 0 & -1 \\
    0 & 3 & 0 \\
    0 & \frac{2}{3} & \frac{1}{3} \\
    \end{matrix} \right ]
$$

代表了一个二维投影变换，它能将单位正方形 $([0,1]\times [0,1])$ 转换为 [图 7.9] 中的梯形（透视变换后的形状）。

我们找一个点来具体看一下： $(1,0)$ 这个点，在计算的时候会被表示为 $[1 \ 0 \ 1 ]^T$ 。然后进行转换，如下：

$$
\left [ \begin{matrix}
    2 & 0 & -1 \\
    0 & 3 & 0 \\
    0 & \frac{2}{3} & \frac{1}{3} \\
    \end{matrix} \right ]\left [ \begin{matrix}
    1 \\
    0 \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    1 \\
    0 \\
    \frac{1}{3} \\
    \end{matrix} \right ]
$$

由于额外量 $w = \frac{1}{3}$ ，所以我们将它进行缩放后得到的点是 $(3,0)$ 。同样的，这个缩放过程可以通过在矩阵 $\rm\textbf{M}$ 前面乘上系数 $c$ 得到，这时得到的结果也会按照 $c$ 倍缩放，不会影响结果。

有一种更优雅的方式来表达相同的意思，它能避免处理额外值 $w$ 。这种方法在三维投影变换中只算是 _四维线性变换_ 。它额外规定了所有标量倍数都指向同一点：

$$\rm\textbf{x} \sim \alpha \textbf{x}$$

符号 $\sim$ 读作“等价于”，意思是两个齐次向量都描述了空间内的同一个点。

## 7.3 透视投影

**关于透视变换我们需要做的是：**

1. **将视锥“挤压”成长方体**
2. **做一次正交投影**

投影变换的机制让 **实现透视图所需要的除以 $z$ 步骤** 变得简单。如同 [图 7.8] 所示，我们可以用矩阵变换来实现透视投影，如下：

$$
\left [ \begin{matrix}
    y_s \\
    1 \\
    \end{matrix} \right ] \sim \left [ \begin{matrix}
    d & 0 & 0 \\
    0 & 1 & 0 \\
    \end{matrix} \right ]\left [ \begin{matrix}
    y \\
    z \\
    1 \\
    \end{matrix} \right ]
$$

这个变换的作用是将二维齐次向量 $[y \ z \ 1]^T$ 转化成一维齐次向量 $[dy \ z]^T$ 。也就是代表了一维（数轴）上的点 $(\frac{dy}{z})$ （这是因为化成齐次坐标后的第二个量是 **1** ，所以需要同除 $z$ ）。

对于三维的“标准的”透视投影，我们使用以往的惯例，让相机在原点，朝向 $-z$ 方向。与正交投影一样，我们也采用了相同的标记方式来标记近平面和远平面。在这一节中，我们将使用近平面作为投影平面，所以图像平面的距离是 $-n$ 。

> 别忘了 $n<0$ 。

然后，所需的映射是 $y_s = \frac{n}{z}y$ ，对于 $x$ 也是同样。那么这样的变换就可以写出矩阵形式：

> 为什么是这个式子？因为近平面上的长度是被“挤压”之后的， $x,y$ 会变成 $x',y'$ 。

所以，我们需要如下的变换：

$$
{\rm\textbf{M}_{persp\to orth}}\left [ \begin{matrix}
    x \\
    y \\
    z \\
    1 \\
    \end{matrix} \right ] \Rightarrow \left [ \begin{matrix}
    \frac{nx }{z}\\
    \frac{ny }{z}\\
    ? \\
    \frac{1 }{z} \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    nx \\
    ny \\
    ? \\
    z \\
    \end{matrix} \right ]
$$

而且，我们观察到，在近平面上的点经过变换后，是不会变的：

$$
{\rm\textbf{M}_{persp\Rightarrow orth}}\left [ \begin{matrix}
    x \\
    y \\
    n \\
    1 \\
    \end{matrix} \right ] \Rightarrow \left [ \begin{matrix}
    x \\
    y \\
    n \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    nx \\
    ny \\
    n^2 \\
    n \\
    \end{matrix} \right ]
$$

再且，远平面中心在进行变换之后的点不变：而且，我们观察到，在近平面上的点经过变换后，是不会变的：

$$
{\rm\textbf{M}_{persp\Rightarrow orth}}\left [ \begin{matrix}
    0 \\
    0 \\
    f \\
    1 \\
    \end{matrix} \right ] \Rightarrow \left [ \begin{matrix}
    0 \\
    0 \\
    f \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
     0 \\
    0 \\
    f^2 \\
    f \\
    \end{matrix} \right ]
$$

根据矩阵乘法，我们得到下面的矩阵：

$$
{\rm\textbf{P}} = {\rm\textbf{M}_{persp\Rightarrow orth}} =  \left [ \begin{matrix}
    n & 0 & 0 & 0 \\
    0 & n & 0 & 0 \\
    0 & 0 & n+f & -fn \\
    0 & 0 & 1 & 0 \\
    \end{matrix} \right ]
$$

第一、二、四行实现了透视方程的作用。第三行正如在正交变换和视口变换矩阵中的那样，是为了让 $z$ 值“上车”，以便之后使用 $z$ 值判断那些曲面被覆盖了不需要显示。然而，在透视投影中，我们添加了一个额外量的数乘，而不是常量，这会丢失原来的 $z$ 值——但实际上 $x,y$ 变了， $z$ 不可能不变。相反，在近平面和远平面上的点，我们选择保持 $z$ 值不变。

> 等会就讲到了，听我说你先别急。

有很多矩阵都可以用作透视矩阵，而它们无一例外都会非线性地扭曲 $z$ 坐标， [图 7.12] 和 [图 7.13] 的矩阵展现出了良好的特性：它能将 $z=n$ 这个平面（近平面）上的所有点留下不做处理，同时能够对 $z=f$ 这个平面（远平面）上的点在 $x$ 和 $y$ 维度上适当做“伸缩”处理。矩阵对该点的影响如下：

$$
{\rm\textbf{P}}\left [ \begin{matrix}
    x \\
    y \\
    z \\
    1 \\
    \end{matrix} \right ] = \left [ \begin{matrix}
    nx \\
    ny \\
    (n+f)z-fn \\
    z \\
    \end{matrix} \right ] \sim \left [ \begin{matrix}
    \frac{nx}{z} \\
    \frac{ny}{z} \\
    n+f-\frac{fn}{z} \\
    1 \\
    \end{matrix} \right ]
$$

如你所见， $x$ 和 $y$ 是按照 $z$ 的比例来进行缩放的。因为 $n$ 和 $z$ 都是负值，所以 $x$ 和 $y$ 没有“翻转”。虽然不太明显，但这个变换保留了 $z=n$ 和 $z=f$ 之间的 $z$ 值的相对顺序，便于我们之后对 $z$ 进行深度排序，这是我们之后隐藏曲面所需要的重要信息。

有些时候我们会想要对矩阵 ${\rm\textbf{P}}$ 求逆。例如，当需要将屏幕坐标加上 $z$ 值，并转换回原始空间的时候。 ${\rm\textbf{P}}$ 的逆如下：

$$
{\rm\textbf{P}}^{-1} = \left [ \begin{matrix}
    \frac{1}{n} & 0 & 0 & 0 \\
    0 & \frac{1}{n} & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & -\frac{1}{fn} & \frac{n+f}{fn} \\
    \end{matrix} \right ]
$$

> 严格意义上来说这不是 ${\rm\textbf{P}}$ 的逆矩阵。但是这是 ${\rm\textbf{P}}$ 所表示的转换的逆操作。

齐次向量乘以标量不会影响它的意义。所以矩阵可以更好看一些：

$$
{\rm\textbf{P}}^{-1} = \left [ \begin{matrix}
    f & 0 & 0 & 0 \\
    0 & f & 0 & 0 \\
    0 & 0 & 0 & fn \\
    0 & 0 & -1 & n+f \\
    \end{matrix} \right ]
$$

回看我们讲过的正交投影矩阵 ${\rm\textbf{M}_{orth}}$ ，透视矩阵仅仅起到了将视锥体（被削了脑袋的金字塔状）映射到正交投影体（轴对齐的盒状）的功能。但透视矩阵的牛逼之处在于我们一使用它，就可以通过正交变换来得到 _标准立方体_ 。因此，所有的正交变换都适用，并且我们只是添加了一个矩阵和一个除以 $w$ 的操作而已。而且，我们没有浪费这个 $4\times 4$ 矩阵的最后一行！

将 ${\rm\textbf{P}}$ 和 ${\rm\textbf{M}_{orth}}$ 进行组合，就得到了 _透视投影矩阵_ 。

$${\rm\textbf{M}_{per}} = {\rm\textbf{M}_{orth}}{\rm\textbf{P}}$$

**但还有一个问题：** 如何确定透视图中的 $l,r,b,t$ ？它们定义了我们看到的窗口的大小。 **答案是：** 由于透视矩阵没有改变 $z=n$ 平面（近平面）的 $x,y$ 值，所以我们只需要通过该平面确定它们的值即可。

为了把这个透视矩阵整合到我们研究的 _正交结构_ 中去，我们只需要将原来的 ${\rm\textbf{M}_{orth}}$ 简单改为 ${\rm\textbf{M}_{per}}$ 即可。所以完整的透视投影一条龙服务矩阵是：

$${\rm\textbf{M}} = {\rm\textbf{M}_{vp}} {\rm\textbf{M}_{orth}} {\rm\textbf{P}}{\rm\textbf{M}_{cam}}$$

伪代码也很相似：

```java
construct M_vp
construct M_per
construct M_cam
M = M_vp * M_per * M_cam

for each line segment(a_i,b_i) do{
    p = M_ai
    q = M_bi
    drawline(x_p/w_p, y_p/w_p, x_q/w_q, y_q/w_q)
}
```

注意，除了附加矩阵有变化之外，还变了齐次坐标的除法因子 $w$ 。

乘出来之后的矩阵是这样的：

$$
{\rm\textbf{M}_{per} }= \left [ \begin{matrix}
    \frac{2n}{r-l} & 0 & \frac{l+r}{l-r} & 0 \\
    \\
    0 & \frac{2n}{t-b} & \frac{b+t}{b-t} & 0 \\
    \\
    0 & 0 & \frac{n+f}{n-f} & \frac{2fn}{f-n} \\
    \\
    0 & 0 & 1 & 0 \\
    \end{matrix} \right ]
$$

这种矩阵或类似的矩阵经常出现在文档中，当人们发现它们一般来说表示的是几个简单矩阵的乘积时，它们就不那么神秘了。

### 重要例子

许多 API，如 _OpenGL_ 使用与本文所示相同的视图立方体。它们通常还让用户指定 $n$ 和 $f$ 的绝对值。OpenGL 的投影矩阵是：

$$
{\rm\textbf{M}_{per} }= \left [ \begin{matrix}
    \frac{2|n|}{r-l} & 0 & \frac{l+r}{l-r} & 0 \\
    \\
    0 & \frac{2|n|}{t-b} & \frac{b+t}{b-t} & 0 \\
    \\
    0 & 0 & \frac{|n|+|f|}{|n|-|f|} & \frac{2|f||n|}{|f|-|n|} \\
    \\
    0 & 0 & -1 & 0 \\
    \end{matrix} \right ]
$$

其他的 API 通常将 $n$ 设置为 0， $f$ 设置为 1。 _Blinn_ 建议将规范视图体积设置为 $\left [ 0,1 \right ]^{3}$ 以提高效率。所有这些决策都会稍微改变投影矩阵的格式。

## 7.4 透视变换的一些性质

透视变换的一个重要性质是，它将线段转化成线段，平面转化成平面。此外，它将视图立方体中的线段转化成标准立方体中的线段。为了更好的理解，看下面这个线段：

$${\rm\textbf{q}}+t({\rm\textbf{Q}-\textbf{q}})$$

当它被一个 $4\times 4$ 矩阵 $\rm\textbf{M}$ 转换时，它还是一个齐次坐标的动点：

$${\rm\textbf{M}}{\rm\textbf{q}}+t({\rm\textbf{MQ}}-{\rm\textbf{Mq}}) \equiv {\rm\textbf{r}}+t({\rm\textbf{R}}-{\rm\textbf{r}})$$

因此，这个齐次化的点分布在：

$$\frac{{\rm\textbf{r}}+t({\rm\textbf{R}}-{\rm\textbf{r}})}{w_r+t(w_R-w_r)}$$

如果我们能把上面这个式子写成下面这样的形式：

$$\frac{{\rm\textbf{r}}}{w_r}+f(t) \left(\frac{{\rm\textbf{R}}}{w_R} -\frac{{\rm\textbf{r}}}{w_r} \right)$$

那么就能证明所有齐次化的点都在一条线段上。让我们摁解，得到下面这个形式：

$$f(t)=\frac{w_Rt}{w_r+t(w_R-w_r)}$$

结果表明，线段的映射依然是保留所有点顺序的线段。也就是，经过变换后，线段上的点并不会被重新排序或“撕裂”。

将线段转换为线段的一个副产品是，三角形进行变换时，边和顶点会转化成另外一个三角形的边和顶点。因此，三角形转换后仍是三角形，平面也依旧是平面。

## 7.5 视野（FoV）

尽管我们可以使用 $(l,r,b,t)$ 和 $n$ 来指定一个视窗，但有些时候我们会希望以一种更简单的方式描述它：从它的中心查看，这也意味着：

$$l=-r$$
$$b=-t$$

与此同时，如果我们添加了像素必须为正方形的规定，也就是图像中没有 _形状失真_ ，那么 $r$ 与 $t$ 的比率应该是和水平像素与垂直像素的比率相同。

$$\frac{n_x}{n_y} = \frac{r}{t}$$

当已经给出了 $n_x$ 和 $n_y$ 后，那么只有一个自由变量（离视窗的远近）了。我们通常使用 _视野 Fov_ ，单位为角度 $\theta$ 来描述。这有时也会被称为 _垂直视野_ 。用于区分这个角度到底是与左右相比产生的还是对角线相比产生的。由图可见，垂直视野是：

$$\tan \frac{\theta}{2} = \frac{t}{|n|}$$

## 常见问题

- **_正交变换在实践中用处大吗？_**

  它在判断 _相对长度_ 的时候很有用。同时，它也能简化透视图，因为透视图在医疗可视化领域中成本过高。

- **_我使用图形 API 画出了一个镶嵌球体，但看上去像个椭圆。这是 bug 吗？_**

  不，这是对的。如果你把眼睛也放在相同的角度，它看起来也会像椭圆，这是角度问题。

- **_透视矩阵使用反向操作把正值 $z$ 转换成了负值 $z$ ？这会导致问题吗？_**

  是这样的，转换的方程是：
  $$z' = n+f-\frac{fn}{z}$$
  所以 $z = +\epsilon$ 会被转换成 $z' = -\infty$ ， $z = -\epsilon$ 会被转换成 $z' = \infty$ ( $\epsilon$ 指足够小的数 )。因此所有跨越 $z=0$ 的线段将会被“撕裂”，尽管所有点的投影位置是正确的。当所有的对象都在视图立方体内时，这样的撕裂并没有甚么关系。我们可以通过“切分”视图立方体来解决这个问题。然而，由于有撕裂现象，切分操作会变得更复杂（详见 [第 8 章] ）。

- **_透视矩阵更改了齐次坐标的值。这难道不会使移动和缩放变换用不了吗？_**

  对一个齐次坐标点应用透视矩阵后，我们有：

  $$
  \left [ \begin{matrix}
  1 & 0 & 0 & t_x \\
  0 & 1 & 0 & t_y \\
  0 & 0 & 1 & t_z \\
  0 & 0 & 0 & 1 \\
  \end{matrix} \right ]\left [ \begin{matrix}
  hx \\
  hy \\
  hz \\
  h \\
  \end{matrix} \right ] = \left [ \begin{matrix}
  hx+ht_x \\
  hy+ht_y \\
  hz+ht_z \\
  h \\
  \end{matrix} \right ]\xrightarrow{\rm homigenize}\left [ \begin{matrix}
  x+t_x \\
  y+t_y \\
  z+t_z \\
  1 \\
  \end{matrix} \right ]
  $$

  其他变换也有类似的效果。

# 第八章 图形管线

**前几张已经给我们打好了属性基础，我们可以接着做渲染中第二重要的事了：一个接一个在屏幕上渲染物体，也就是 _对象顺序渲染_ 。在光线追踪时，我们是寻找能够影响它颜色的物体，然后挨个考虑单个像素，但在这里不一样。我们现在是先挨个考虑几何体，然后寻找这个几何体能够影响的像素。在充满 _图元_ 的几何体中计算所有像素的过程被称为 _光栅化_ ，所以对象顺序渲染也可以称作 _光栅渲染_ 。进行该渲染所需的步骤序列——从几何体开始，到更新图像中的像素结束，被称为 _图形管线_ 。**

> **所有的图形系统都有一种或多种“原始物体”，它可以直接被处理，而且复杂的物体会被转化成这种简单物体的组合。它称为“图元”。三角形是用的最多的图元。**

> **基于光栅化的系统也叫 _扫描线着色_ 。**

**对象顺序渲染由于它效率特别高，获得了大成功。在大场景下，数据访问模式对性能影响巨大。而且，按顺序地访问场景中的物体来对像素着色，比在场景中一遍遍搜索物体要高效的多。**

**这章的标题暗示了对象顺序渲染只有一种方法。但实际上并不是这样——存在两个相当不同的图形管线，二者的目标也大相径庭。一个是通过采用 _OpenGL_ 和 _Direct 三维_ 等图形 API 的、支持 _交互式渲染_ 的硬件管线；另一种是电影摄制中采用的软件管线，支持 _RenderMan_ 等 API。硬件管线必须足够快，因为它要承担起运行实时游戏、可视化、用户界面的工作，而软件管线（生产管线）必须以最高质量渲染动画和视觉效果，并且这样的渲染应支持大场景，但这样会消耗更多的时间。尽管不同的目标产生了不同的设计思路，但大多数的管线还是有很多相同点。本章将致力于讲解它们的共同点的基础知识，并且稍微偏向硬件管线一些。**

**对象顺序渲染中所需的工作可以被组织为光栅化、光栅化前的几何操作，以及光栅化后的像素操作三个步骤。最常见的几何操作包括前两章学的 _矩阵变换_ ，如将空间的点从物体空间变换到屏幕空间，这样光栅化器的输入格式就是 _像素坐标_ 或者 _屏幕坐标_ （screen space）表示。最常见的像素操作则是隐藏面移除（hidden surface removal），该操作使离观察者更近的表面出现在更远的表面的前方。上述每个阶段还包括了更多的其他操作，这些操作通过相同的通用步骤，从而共同实现了多样化的渲染效果。**

**本章我们将讨论图形管线的四个阶段（如 [图 8.1] ）。几何物体通过交互型应用或者场景描述文件进入管线，而这些几何图形通常由 _顶点集_ 表示。顶点在 _顶点处理阶段_ 被处理，然后由这些顶点产生的 _图元_ 被送到 _光栅化阶段_ 。光栅化器将每个图元分解为一定数量的 _片元_ ，每个被图元覆盖的像素会分配到一个片元。片元在 _片元处理阶段_ 被处理，之后每个像素对应的片元在 _片元混合阶段_ 被组合。**

**我们会从光栅化开始讨论，然后描述在几何阶段和像素阶段分别需要做甚么事情。**

## 8.1 光栅化

光栅化是对象顺序渲染的中心步骤，也是所有图形管线的核心。对于进入的每个图元，光栅器有两个工作：其一是枚举所有被该图元覆盖的像素，其二是对图元中的各个属性进行 **插值** ，插值的目的后面会举例子说明。光栅化器的输出是一系列 **片元** 。每个片元带着自己的属性值们“居住”在一个特定的像素位置上。

> 在不做多重采样抗锯齿（MSAA）时，我们认为一个片元就是一个像素。

这一章中，我们将展示三维场景的光栅化，使用这种光栅化器来渲染三维场景。虽然二维也采用相同的光栅化方法，但如今越来越倾向于采用三维图形系统来包干所有二维的工作。

### 8.1.1 画线

大多数图形工具包都有一个画线命令，这个命令接收两个端点（屏幕坐标）作为参数，见 [图 3.10] ，然后在它们之间画一条线。对于一般的两个端点 $(x_0,y_0)$ 和 $(x_1,y_1)$ ，该 **例程** 需要在这两个点之间绘制一些“合理的”像素，让它们能近似的表示线段。画线的方法基于直线方程，而方程有两种形式可选：隐式方程或参数方程。本章使用隐式方程。

> 尽管我们经常使用整数值端点举例子，但实际上任意的点都应该被支持。

#### 使用隐式方程画线

最常用的画线方法是 _中点算法_ 。中点算法和 _Bresenham 直线算法_ 都能画出相同的直线，但中点算法更直观。

> 译者注：链接：[Bresenham 直线算法](https://zhuanlan.zhihu.com/p/302806158#:~:text=Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95%E6%98%AF%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E7%94%BB%E7%9B%B4%E7%BA%BF%E7%9A%84%E7%AE%97%E6%B3%95%E3%80%82,%E7%9C%9F%E5%AE%9E%E7%9A%84%E7%9B%B4%E7%BA%BF%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%BE%E7%A4%BA%E7%9A%84%E7%B2%BE%E5%BA%A6%E6%9C%89%E9%99%90%EF%BC%8C%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9C%9F%E6%AD%A3%E6%98%BE%E7%A4%BA%E8%BF%9E%E7%BB%AD%E7%9A%84%E7%9B%B4%E7%BA%BF%EF%BC%8C%E4%BA%8E%E6%98%AF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%88%91%E4%BB%AC%E7%94%A8%E4%B8%80%E7%B3%BB%E5%88%97%E7%A6%BB%E6%95%A3%E5%8C%96%E5%90%8E%E7%9A%84%E7%82%B9%EF%BC%88%E5%83%8F%E7%B4%A0%EF%BC%89%E6%9D%A5%E8%BF%91%E4%BC%BC%E8%A1%A8%E7%8E%B0%E8%BF%99%E6%9D%A1%E7%9B%B4%E7%BA%BF%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%E3%80%82%20%E5%9C%A8%E6%9C%AC%E6%96%87%E4%B8%AD%E6%88%91%E4%BB%AC%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95%EF%BC%8C%E5%B9%B6%E9%80%90%E6%AD%A5%E4%BC%98%E5%8C%96%EF%BC%8C%E6%9C%80%E7%BB%88%E5%BC%95%E5%87%BA%E7%BB%8F%E5%85%B8%E7%9A%84Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95%EF%BC%8C%E5%B9%B6%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3Bresenham%E7%9B%B4%E7%BA%BF%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%8E%9F%E7%90%86%E3%80%82)

我们要做的第一件事是找到那两个点对应的隐式方程：

$$f(x, y) ≡ (y_0 − y_1)x + (x_1 − x_0)y + x_0y_1 − x_1y_0 = 0.$$

我们假设 $x_0 < x_1$ 。如果实际上不符合，那么我们交换两个点。那么直线的斜率是：

$$m = \frac{y_1-y_0}{x_1-x_0}$$

下面的讨论假设了 $m \in (0,1]$ ，对于区间 $(-\infty,-1]$ 和 $(-1,0]$ 和 $(1,\infty)$ 是相似的，可以由之前的例子进行推广。

对于 $(0,1]$ 的例子，直线比较“平坦”。也就是 $x$ 比 $y$ 移动地快。如果有一个 API 的 $y$ 轴朝下，我们可能会担心这会让我们的工作变难，但实际上这个细节完全可以忽略。我们可以忽略几何的“上下”，因为不管咋样，数值都是一样的。中点算法的关键假设是：画出中间没有断开的、最细的线（像素沿对角线排列不算断开）。

从左到右的像素绘制过程中，只有两种情况：右边的像素比左边高一格，或是一样高。因此，线段上每一列都只会由一个像素。如果没有像素，那么就是出现了断开，如果有两个以上，这个地方就太粗了。相对的，一行内可能出现不止一个像素。见 [图 8.2] 。

针对 $m \in (0,1]$ 的重点算法首先会确定最左边的像素和最右边的像素的 $x$ **值（列号）** 。然后不断从左向右循环，确定每个像素的 $y$ **值（行号）** 。伪代码如下：

```java
y = y0
for x = x0 to x1 do
    draw(x, y)
    if (some condition) then
        y = y + 1
```

注意这里的 $x$ 和 $y$ 是整数。上面的代码用文字描述是：“从左到右依次绘制像素，并且有时候向上一格”。打造一个高效的判断方式取决于 _if_ 里面的语句。

有一种高效的判断方式是考虑两个端点像素中心的中点。具体地说，刚被绘制的 $(x,y)$ 位置的像素在真实屏幕上的位置是 $(x,y)$ ，那么下一个该绘制的像素只可能是 $(x+1,y)$ 或 $(x+1,y+1)$ 。而两个候选点的中点是 $(x+1,y+0.5)$ 。如果线段通过这个点的下方，那么选取 $(x+1,y)$ ，否则就选取 $(x+1,y+1)$ 。如 [图 8.3] 。

为了判断直线到底是在 $(x+1,y+0.5)$ 的上方还是下方，我们计算上面公式的 $f(x,y+0.5)$ 。按照它的符号来确定点相对于直线的位置。由于 $-f(x,y)=0$ 和 $f(x,y)=0$ 都是正确的直线方程，所以我们还不能马上确定什么符号对应着什么样的位置关系。但是我们可以通过系数判断出来：注意到 $y$ 的系数是 $(x1-x0)$ ，由于我们已经假设了 $x1>x0$ ，因此该系数为正，这意味着当 $y$ 不断增加时， $(x1-x0)y$ 也在增加，因而 $f(x,+\infty)$ 必然为正，且在直线上方，这说明直线上方的点在 $f(x,y)$ 的取值都为正。另外一种判断方法是看梯度向量的 $y$ 分量是否为正。这意味着我们现在能够完善 _if_ 语句的内容了:

```vb
if f(x + 1, y + 0.5) < 0 then
    y = y + 1
```

上述代码可以用于斜率在 0 到 1 之间的情况。读者可能自己找出其他三种情况的方法，它们只有微小的不同。

如果我们想要执行更高效，那么可以采用 _增量式方法_ 。其中有一种增量式方法尝试通过复用前一轮的计算结果，使得循环变得更加高效。在中点算法中，主要的计算是 $f(x+1,y+0.5)$ 。注意到在循环内部，循环第一轮之后，对于当前的 $(x,y)$ ，我们已经在上一轮循环计算过了 $f(x-1,y+0,5)$ 或者 $f(x-1,y-0.5)$ 的值。注意到如下关系：

$$f(x + 1, y) = f(x, y)+(y_0 − y_1)$$
$$f(x + 1, y + 1) = f(x, y)+(y_0 − y_1)+(x_1 − x_0).$$

这就能让我们写出增量式方法的代码：

```vb
y = y0
d = f(x0 + 1, y0 + 0.5)
for x = x0 to x1 do
    draw(x, y)
    if d < 0 then
        y = y + 1
        d = d + (x1 − x0)+(y0 − y1)
    else
        d = d + (y0 − y1)
```

该算法相比于原来的算法速度更快，因为它与之前的代码相比几乎没有 _设置成本_ 。但是也可能会因此积累更多的误差，因为 $f(x,y+0.5)$ 的计算是通过一系列值相加得到的，误差也会累加。不过只要直线不是特别长，误差的影响不大。我们稍微增加一些 _设置成本_ ，可以将循环执行的更快：也就是将 $(x_1-x_0)+(y_0-y_1)$ 和 $y_0-y_1$ 提前算好，就可以在循环中不必重复计算。但如果代码很重要，那么需要检查编译后的代码来确保写的代码没有问题。

> 译者注：此处可阅读《深入理解计算机系统》来探究程序的优化方式。

### 8.1.2 三角形的光栅化

我们经常会需要通过三个二维屏幕坐标：${\rm\textbf{p}_0}=(x_0,y_0), \ {\rm\textbf{p}_1}=(x_1,y_1), \ {\rm\textbf{p}_2}=(x_2,y_2)$ 来绘制二维三角形。这和画线比较相似，但它有一些独有的特征。我们可能会想要根据顶点的颜色或是其他属性来做插值，而插值实际上有了 **重心坐标** 的帮助变得很直观了（见 [2.7 节] ）。举个例子。如果三个顶点的颜色分别是 $\rm\textbf{c}_0$ , $\rm\textbf{c}_1$ , $$ ，那么在三角形内某一点 $(\alpha,\beta,\gamma)$ 的颜色就是：

$${\rm\textbf{c}} = \alpha {\rm\textbf{c}_0} + \beta{\rm\textbf{c}_1}+ \gamma {\rm\textbf{c}_2}$$

上述插值的方法称作 _Gouraud 插值法 (亮度插值法)_ 。

三角形光栅化的另一个微妙的地方在于，我们往往需要对共享顶点和边的三角形做光栅化。这意味着我们需要在不出现漏空的前提下对这些三角形进行光栅化。我们可以运用 **中点算法** 画出每个三角形的边，然后填充它们内部的像素。这意味着相邻的三角形会在它们的边上绘制相同的像素。如果相邻的三角形具有不同的颜色，那么渲染出来的公共边的图像效果将由后绘制的三角形决定。避免这种顺序问题、并消灭漏空的最常用方法是：只画那些像素中心在三角形内部的像素，换句话说就是只绘制那些像素中心在 $(0,1)$ 区间内的像素。但这样又会产生另外一个问题：如果中心刚好就在三角形的边上，那该怎么办？我们在之后会讨论这个问题，它有好几种解决方案。我想说的关键在于，重心坐标给了我们判断是否画一个像素、以及通过顶点插值得到像素颜色的方法。因此，光栅化三角形的问题就能被归结为：如何高效的找到像素中心的坐标。暴力光栅化算法如下：

```vb
for all x do
    for all y do
        compute (α, β, γ) for (x, y)
        if (α ∈ [0, 1] and β ∈ [0, 1] and γ ∈ [0, 1]) then
            c = αc0 + βc1 + γc2
            drawpixel (x, y) with color c
```

下面的算法将外层循环的候选像素限制在一个较小的集合里，使得重心坐标的计算更加高效。

> 为了一个小三角形遍历整个屏幕，是不是太浪费了？！

我们可以通过找到三角形的 **_包围盒_** ，并且只考虑矩形内的像素来提升算法效率。于是我们得到如下算法：

```vb
x_min = floor(x_i)
x_max = ceiling(x_i)
y_min = floor(y_i)
y_max = ceiling(y_i)
for y = y_min to y_max do
    for x = x_min to x_max do
        α = f_12(x, y)/f_12(x0, y0)
        β = f_20(x, y)/f_20(x1, y1)
        γ = f_01(x, y)/f_01(x2, y2)
        if (α > 0 and β > 0 and γ > 0) then
            c = α*c_0 + β*c_1 + γ*c_2
            drawpixel (x, y) with color c
```

在这里， $f_{ij}$ 就是由两点得出的线段，由之前我们讲解的直线方程得到（之后还会用到这个约定）：

$$f_{01}(x, y)=(y_0 − y_1)x + (x_1 − x_0)y + x_0y_1 − x_1y_0,$$
$$f_{12}(x, y)=(y_1 − y_2)x + (x_1 − x_2)y + x_1y_2 − x_2y_1,$$
$$f_{20}(x, y)=(y_2 − y_0)x + (x_0 − x_2)y + x_2y_0 − x_0y_2,$$

请注意，我们使用重心坐标的时候没有判断 $\alpha$ 的正负，而是直接默认 $\alpha>0$ 。因为如果三个重心坐标都是正数，那么它们就能天然满足小于 $1$ 的条件，因为重心坐标之和为 $1$ 。我们也可以只计算两个坐标，通过等式计算出第三个，但是在采用了增量式算法时这不确定能不能变得更加高效；每次计算 $\alpha,\beta,\gamma$ 时都会计算形如 $f(x,y)=Ax+By+C$ 的式子，在里面那层循环中，只有 $x$ 产生变化，每次变化 $1$ 。同时注意到 $f(x + 1, y) = f(x, y) + A$ ，这个式子是增量式算法的基础。

在外层循环中，则是考虑 $f(x,y)$ 到 $f(x,y+1)$ 的变化。因此也能够通过增量式算法获取相似的效率提升。由于三个重心坐标在循环中都是按固定数变化，所以颜色 $\rm\textbf{c}$ 的变化也一样，因为它们都呈线性关系，故颜色也可以运用增量式算法。例如，坐标 $(x+1,y)$ 的 _红色值_ 和坐标 $(x,y)$ 的 _红色值_ 相差的常数值能够被提前计算出来。三角形颜色插值的一个例子如 [图 8.5] 。

#### 处理三角形边界上的像素

我们还妹有讨论对三角形边界穿过的像素点该做 ♂ 点什么。如果一个像素恰好在三角形的边上，如果旁边还有一个三角形，那么他就会处在公共边上。公共边不能轻易的被归到某个三角形上。不画这个像素是最差的选择，这样就会出现漏空。给两个三角形都绘制像素的方法，如果三角形是透明的，会导致双重着色，所以这个方法比上不足比下有余。我们还是希望能把这个像素判给某个三角形，同时方法越简单越好；选择哪个三角形并不重要，但方法好就可以。

有一种解决方案：我们注意到，任何在屏幕坐标外的点必定会在三角形公共边的某一侧。对于两个不重叠的、有公共边的三角形，单独剩下来的那两个顶点一定在边的两侧，同时肯定有其中的一个点是和 _离屏点_ 在同一侧的（见 [图 8.6] ）。上面所说的是我们接下来要采用的神奇方法的原理。

测试方法将计算出离屏点和三角形孤儿顶点代入直线函数的取值，并将它们相乘。根据该乘积的符号决定将公共边算到哪个三角形头上，符号的选择是任意的，本文选择正号。

注意，上述测试不是完美的，因为线段所在的直线也有可能通过选择的离屏点，这样代入取值就是 **0** 。但我们至少大大减少了出问题的情况。使用哪个离屏点是随意的，一般来说 $(-1,-1)$ 是一个不错的选择。但正是因此，我们需要增加一个检查离屏点是否刚好在边所在直线上的步骤。同时我们希望这个检查和判断内外的部分分离开来。于是有如下伪代码：

```vb
x_min = floor(x_i)
x_max = ceiling(x_i)
y_min = floor(y_i)
y_max = ceiling(y_i)
f_α = f12(x_0, y_0)
f_β = f20(x_1, y_1)
f_γ = f01(x_2, y_2)
for y = y_min to y_max do
    for x = x_min to x_max do
        α = f_12(x, y)/f_α
        β = f_20(x, y)/f_β
        γ = f_01(x, y)/f_γ
        if (α ≥ 0 and β ≥ 0 and γ ≥ 0) then
            if (α > 0 or f_α * f12(−1, −1) > 0) and
                    (β > 0 or f_β*f_20(−1, −1) > 0) and
                    (γ > 0 or f_γ*f_01(−1, −1) > 0) then
                c = α*c0 + β*c1 + γ*c2
                drawpixel (x, y) with color c
```

我们期望上面的代码能够解决漏空和重复着色的问题。实际上，如果两个共享顶点有相同的绘制顺序，直线方程就是相同的。否则的话会变个符号。如果编译器改变了渲染顺序，那么可能会因为这个符号出现问题。所以如果你需要一个健壮的程序，那就需要检查编译器的数学单元。同时，需要小心处理伪代码的前四行，因为有公共边刚好在像素中心的特殊情况。

除了实现增量式算法之外，还有一些可以让程序提前退出的点。例如，如果 $\alpha<0$ ，那么就没有必要计算 $\beta$ 和 $\gamma$ 了。这样提前退出可能可以让算法速度变快，我们可以使用性能分析工具 _ProfilingTools_ 来测量是否有性能提升，因为额外的分支也有可能影响流水线或并行性，拖慢运行速度。所以，如果代码很重要，那么我们需要测试所有力所能及的优化方案。

还有一点，就是上述代码的除法可能会出现除零的问题。比如： $f_\gamma = 0$ 。所以我们可以选择捕获浮点错误，或者设置一个检查措施。

### 8.1.3 裁剪

仅仅把图元变换到屏幕坐标并进行光栅化还不太够。因为视景体外，特别是眼睛后面的图元也有可能会被光栅化，导致结果出错。例如，考虑 [图 8.7] 中的三角形：有两个顶点在视景体内，而第三个顶点在眼睛后面。投影变换会将这个点映射到一个 _远平面_ 后面的不可视区域，如果这种操作被允许，三角形就没法被正确地光栅化。因此，光栅化之前需要进行 **裁剪操作** ，以移除图元能够延伸到眼睛后面的部分。

裁剪是图形学中的常规操作，只要一个几何体“切割”到了另外一个几何体就会用到裁剪。例如，如果你使用平面 $x=0$ 切割一个三角形，会将它分为两部分（只要三角形顶点的 $x$ 坐标符号不全相同）。在大多数裁剪的应用中，三角形中在平面的“错误”侧的部分将被抛弃。如 [图 8.8] 所示。

在给光栅化裁剪中，所谓的“错误”侧，也就是需要去掉的一侧是 _视体_ 外面的部分。在视体外的所有几何结构就算都裁剪掉都没啥关系——也就是裁剪掉视体六个平面之外的所有东西，但是有很多系统仅仅裁剪了近平面那一侧的物体。

> 译者注：这里的视体指视锥金字塔截掉前面部分的塔体。

我们将在这一节讨论裁剪模型的基本实现。而不是写一个工业级裁剪工具。

实现裁剪的最常用的两种方法是：

1. 在世界坐标中用视体的六个面进行裁剪（转换前裁剪）
2. 在四维转换空间中的 _齐次除法_ 之前裁剪

上述两种方法都能轻松实现(J. Blinn, 1996) ，对每个三角形应用以下步骤：

```vb
for each of six planes do
    if (triangle entirely outside of plane) then
        break (triangle is not visible)
    else if triangle spans plane then
        clip triangle
        if (quadrilateral is left) then
            break into two triangles
```

### 8.1.4 转换前裁剪（方法 1）

该方法有一个直接的实现。唯一需要解决的问题是： **六个平面方程是什么？** 由于这些方程对同一个图像中的所有三角形都相同，我们不需要非常高效的计算他们。因此，我们可以仅仅对 [图 5.11] 中的变换取逆，并将它应用于视体的八个顶点上：

$$
(x, y, z) =(l, b, n),\\
(r, b, n)\\
(l, t, n)\\
(r, t, n)\\
(l, b, f)\\
(r, b, f)\\
(l, t, f)\\
(r, t, f)
$$

平面方程可以从他们在世界坐标里的像推导出来。我们也可以用向量的几何性质来直接从 _视角参数_ （viewing parameters）得到。

### 8.1.5 齐次坐标的裁剪（方法 2）

但其实，我们一般采用的方法是在做除法之前，对齐次坐标做裁剪。在这里，视体是四维的，它被一个 _三维超平面_ 包围：

$$-x+lw = 0$$
$$x-rw = 0$$
$$-y+bw = 0$$
$$y-bw = 0$$
$$-z+nw = 0$$
$$z-fw = 0$$

这些平面的表达方式非常简单，所以用这个方法编写的程序效率比上个方法要好。算法可以进一步被优化，方法是将视体 $[l,r]\times [b,t] \times [f,n]$ 转换成 $[0,1]^3$ 空间中。其实这样做并没有比三维空间复杂多少。

### 8.1.6 对一个面进行裁剪

不管我们用哪种方式，我们都需要对面进行裁剪。还记得在 [2.5.5 节] 中，我们有一个对于某平面穿过点 $\rm\textbf{q}$ 的隐式方程：

$$f({\rm\textbf{q}}) = {\rm\textbf{n}} \cdot ({\rm\textbf{p}}-{\rm\textbf{q}}) = 0$$

这一般这样写：

$$f({\rm\textbf{q}}) = {\rm\textbf{n}} \cdot {\rm\textbf{p}}+D = 0$$

有趣的是，这个方程不止描述了三维平面，它也表示了二维的线，以及四维平面的 _体近似物（Volumn Analog）_ 。这些玩意儿在它们自己的维度中都叫做平面。

如果我们在 ${\rm\textbf{a}}$ 和 ${\rm\textbf{b}}$ 点之间有一个线段，我们就可以将它用一个平面来“裁剪”，使用的是 [12.4.3 节] 中的 _BSP 树_ 切割三角形的程序。这里， ${\rm\textbf{a}}$ 和 ${\rm\textbf{b}}$ 通过代入对 $f({\rm\textbf{a}})$ 和 $f({\rm\textbf{b}})$ 取值，看他们是不是一正一负，来判断这俩点是不是在平面的两侧。我们喜欢把 $f({\rm\textbf{q}})<0$ 定义为内侧。如果这条线段确实被隔开了，那么我们就可以将下式:

$${\rm\textbf{q}} = {\rm\textbf{a}}+t({\rm\textbf{b}}-{\rm\textbf{a}})$$

代入方程 $f({\rm\textbf{q}}) = 0$ ，得到：

$${\rm\textbf{n}} \cot ({\rm\textbf{a}}+t({\rm\textbf{b}}-{\rm\textbf{a}}))+D = 0$$

解出 $t$ ：

$$t = \frac{{\rm\textbf{n}}\cdot {\rm\textbf{a}}+D}{{\rm\textbf{n}}\cdot ({\rm\textbf{a}}-{\rm\textbf{b}})}$$

这样我们就能找到交点，然后将看不到的地方减去。

裁剪三角形，我们也可以通过 [12.4.3 节] 中的方法进行，得到一个或两个三角形。

## 8.2 光栅化之前和之后的操作

> 注：首先，一个用顶点描述的几何对象通过交互应用或者场景描述文件被扔进管线， **顶点处理** 对这些点（通过正交视图或者透视视图，注意视图主要处理 x、y 值，z 值用于后续的表面遮盖处理，所以后续的光栅化也是针对二维）处理成为 **图元（geometric primitive，一般为三角形）** ；接着，图元被送进 **光栅化阶段** ，光栅化器会将图元分解为许多 **片元** ，一个片元是一个像素的 3D 投射，其与像素有一样的属性，同时图元会覆盖每一个像素；然后，片元进入 **片元处理阶段** 进一步处理；最后片元与对应的像素在 **fragment blending stage（片元混合阶段）** 组合。

在一个图元被光栅化之前，它的顶点坐标必须是屏幕坐标，同时颜色之类的属性应该已经被插值，这些属性必须都是已知的。我们通过 _顶点处理（信息准备）_ 这一阶段完成数据的准备工作。在这个阶段，被送来的顶点们将依次经过模型、视图、投影变换，然后将它们的原始坐标转换成屏幕坐标（别忘了，屏幕坐标是以像素为单位的）。与此同时，其他的信息如颜色、表面法线或纹理坐标，会按需转换。我们在之后的例子会讨论这些属性怎么搞。

在光栅化之后，我们会进行进一步处理，也就是对每一个分片计算颜色和深度。这个过程可以很简单，只经过颜色插值和光栅化计算深度，或者也可以很复杂，包含复杂的着色操作。然后最后，会经过一个 _Blend 阶段_ ，它将
图元生成的多个分片进行组合，然后计算出像素的最终值。最常见的 Blend 方法是选取离眼睛最近（深度最小）的分片。

我们会提供不同阶段的例子以便理解。

### 8.2.1 简单的二维平面绘图

最简单的图形管线，在 **顶点处理** 和 **片元处理** 的时候啥也不做。在混合阶段，每个片元的颜色只是简单的覆盖之前那个片元的颜色。这个应用使用像素坐标直接提供图元，光栅化器做所有的工作。这样的安排在以前古老的图形 API 中很常见，一般这样的图形 API 是用来绘制 UI 之类的二维玩意儿的。如果图元的顶点都是一个颜色，那么我们就会以纯色填充。同时我们的模型光纤也支持使用颜色插值进行渐变色填充。

### 8.2.2 最小的三维图形管线

为了绘制三维空间中的物体，我们需要对二维的图像管线做一些改变。唯一需要改变的地方就是改变一个简单的转换矩阵： **顶点绘制阶段** 通过将 顶点位置坐标 和 之前模型-相机-投影-视口变换产生的矩阵 相乘，获得和二维空间中绘制方式相同的 _屏幕-空间三角形_ 。

这存在一个小问题。我们的简单三维图形管线为了让绘制的前后关系正确（也就是让前面的覆盖后面的），需要从后往前渲染。这个方法就是 _画家算法_ 。先画最远，然后一步一步画近处的覆盖远处的。这个定理给了我们一个解决问题的思路，但仍会有一个问题：那就是——如果三个三角形相互交错（如 [图 8.9] ），那么画家定理就失效了，因为你不可能找得到正确顺序。而且最主要的是，给图元进行深度排序是很费时间的，尤其是大场景，会拖慢整个管线的速度。

### 8.2.3 使用深度缓冲（z-Buffer）隐藏表面

实际上，由于有 bug，画家定理并没有被广泛使用。我们通常使用一种简单有效的方法来移除隐藏的表面，这就是我们要讲的： **深度缓冲（z-Buffer）** 。方法很简单：对于每个像素，我们将它们离得最近的表面的信息留下，把远处的片元信息给丢掉。我们使用一个除了 RGB 值之外额外的值来存储深度。也就是深度（z 值）。深度缓冲区（z-Buffer）指的就是这个额外的值组成的像素网格。

深度缓冲算法是在 **混合阶段** 被实现的。 通过比较每个片元深度缓冲区的值，我们可以判断出哪个片元更近。如果更近，那么这个像素此时的颜色和深度值就会被新的值覆盖。但如果更远，那么我们就不管它了。为了保证第一个片元能够覆盖原始值，我们将深度的原始值设置成 MAX （MAX 是远平面的深度。或者一个足够大的值也可以）。这样不管是什么顺序渲染，我们都能显示出正确的渲染画面。

深度缓冲算法徐娅每个片元都携带一个深度值。那么我们就可以通过获取顶点的深度值，然后进行**插值**实现，就和我们处理颜色的道理一样。

深度缓冲的方法真是太好用辣！它提供了一种处理隐藏平面的简单实用的方法。这种方法比几何方法（几何方法是将曲面切成一片一片，然后按照深度排序）简单多了，因为这种方法不会弄出来新的问题要解决。深度信息只有、也只需要在确定像素的时候才用得到。深度缓冲在 _硬件图形管线_ 中被 **原生支持** ，同时也是软件管线的最常用方法。

#### 精度问题

在实际处理中，缓冲区存的深度值类型是 **非负整型** 。用整型比浮点数更好，因为在管线中，我们需要快速的内存交换，节约这些时间来优化图形管线，牺牲那么一点精确度是完全值得的。

但整型的使用会导致一些进精度问题。如果我们使用的整型有范围： $\{0,1,2, \cdots B-1\}$ ，我们就会将近平面的深度值设为 $0$ , 将远平面的深度设为 $B-1$ 。对了，这里的讨论我们假定 $z,n$ 和 $f$ 都是正的。当然负值的情况也是一样的。为了减少内存的用量， $B$ 越小越好，所以我们把深度 $z$ 值映射到一个桶： $\Delta z = (f-n)/B$ 中。

如果我们能分配 $b$ 个比特来存储深度值，那么 $B = 2^b$ 。我们在这里又要尽量使 $B$ 越大越好，为了能够清晰区分不同深度。

举个例子。如果你在渲染一个场景，而每个三角形的深度间隔都至少为 $1$ 米。那么设置 $\Delta z < 1$ 就可以显示正确的画面。缩小 $\Delta z$ 有两种办法：将近平面和远平面之间的间隔缩小；或者是将 $b$ 增大。在一般的 API 中，一般来说 $b$ 是固定的，我们只能调整远近平面的距离。

在生成透视图像时，深度值的精度设置必须小心。我们一般将 $\Delta z$ 用在透视除法之后。别忘了我们在 [7.3 节] 讲过的透视除法：

$$z = n+f-\frac{fn}{z_w}$$

在这里，实际的深度是 $z_w$（世界深度） 而不是 $z$ （除法后获得的深度）。我们可以通过将两个转换后平面的值相减来获得前后的深度差：

$$\Delta z \approx \frac{fn\Delta z_w}{z_w^2} $$

深度差的大小与深度坐标有关。在世界坐标下，前后深度差为：

$$\Delta z \approx \frac{z_w^2\Delta z}{fn}$$

请注意 $\Delta z$ 这个量是我们之前讨论的那个。深度最大值是 $z'=f$ 对应的那个。也就是：

$$\Delta z^{max}_w \approx \frac{f\Delta z}{n}$$

如果我们为了看到我们眼睛正前方的物体，取了近平面值 $n=0$，那么这个值就会变得无穷大——这是我们不想看到的。为了让 $\Delta z^{max}_w$ 越小越好，我们应该缩小 $f$ ，放大 $n$ 。因此，选择正确的 $n,f$ 值很重要。

### 8.2.4 逐顶点着色

目前为止，我们设计的这个程序需要给送进来的三角形图元确定颜色。光栅化器只做了 **颜色插值** 的工作，它将插值后的颜色直接输出。但是有些时候我们决定这样还不够，对于三维空间的物体着色，除了正确的颜色，我们还需要光照，这才是真正的着色过程。所以我们需要 [第 4 章] 学过的 **光照方程** 。别忘记，那个方程有一些参数：它需要 **光源方向** 、 **眼睛方向** 、 **表面法线** 来计算表面的颜色。

一种着色的计算方法在 **顶点处理阶段** 进行。应用程序会提供在顶点处的表面法向量，同时单独提供光源的位置和颜色（由于它对每个表面作用都是相同的，所以不需要每个顶点特意区分一下）。对于每个顶点，我们通过相机-光源-顶点的位置来联合判断观察者的方向和光源的方向。我们想要的着色方程，它的输出应该是一个颜色，这个颜色输出到光栅化器中，当作顶点颜色使用。像这样给顶点着色的方式，也被称作是 _高洛德着色_ 。

与此同时，我们需要确定在着色过程中使用哪种坐标。我们可以选择世界坐标，或是相机坐标。但不管使用什么坐标，我们都得确保这种坐标是 **正交** 的，因为其他的投影，如透视投影是会改变角度的，这样对着色过程会产生影响。如果我们使用相机坐标，那么有一个好处就是不用管相机位置了，因为它始终都在原点，在正交投影中，视角方向永远是 $+z$ 。

逐顶点着色也有一些弊端。比如它能渲染的最高精度就是 **图元** 。因为它是逐顶点处理，所以无法对更小的部分单独处理。若是有一个包含地板的房间需要着色，房间中间有一个光源，地板仅使用两个大三角形进行绘制。这样的话，我们会从地板的角落开始逐顶点绘制。这样在经过三个顶点的插值之后，地板中间的颜色会变得河南，明显是不真实的。再者，对于需要着色镜面高光的那些光滑表面，需要非常小的图元来进行着色，不然着色看上去就会非常虚假。

> 我们怎么知道顶点的法向量是什么？
>
> - 因为一个顶点的周边可能会有很多个三角形，我们可以将它旁边的三角形的法向量们做平均（简单平均或加权平均）
> - 使用重心坐标进行插值

[图 8.13] 展示了使用逐顶点着色的两个球体。

### 8.2.5 逐片元着色

> 我们也将这种着色称作 _Phong（冯）着色_ ，但它不基于布林-冯着色模型。

为了防止逐顶点着色插值引起的瑕疵，我们可以将 **插值** 这一步移动到 **着色** 这一步的 **前面**。在逐片元着色中，我们使用完全一样的方程。但该方程接收 以插值后的向量表示的片元 作为输入，而不是原来那样的顶点输入。

在逐片元着色中，着色所需要的各种参数是作为属性通过 **光栅化器** 传输的，所以在 **顶点处理** 阶段，我们需要和 **片元处理** 同步，并且正确的处理数据。有一种方法，是将相机空间中的表面法向量和相机空间中的顶点坐标进行插值，这样它们每个像素都会拥有一个属于自己的法线向量，就可以进行着色了。正如逐顶点着色的过程一样。

[图 8.14] 展示了使用逐片元着色的两个球体。

### 8.2.6 纹理映射

纹理（将在 [第 11 章] 讨论）是添加在着色表面的图像，它能给物体的表面添加额外的纹理细节，让它们看上去更加逼真。原理很简单——在着色计算完毕后，我们使用纹理中的颜色代替渲染出来的颜色即可。这一步叫 _纹理查找_ 。着色器会找到一个 _纹理坐标_ ，纹理映射负责找到那一个点的图像值，然后返回给着色器。在着色计算中会使用这个纹理值。

定义纹理坐标的一个最常用的办法是，将纹理坐标作为顶点的另外一个属性存在。这样每个图元就知道它在纹理的哪个地方了。

### 8.2.7 着色频率

着色计算应该在第几个步骤被执行？这个问题是由颜色变换的快慢（也就是需要的细节量）决定的。对大场景进行着色，比如光滑表面的漫反射，计算频率可以不必那么高，我们可以计算完之后进行 _插值_ 。这就是 **低着色频率** 。而对于那些小场景的着色，如高光着色、丰富的纹理着色，就需要 **高着色频率** 。如果我们需要在图像中能够清楚的看到某些细节，那么对于那些细节的着色频率就至少应该是 _每个像素着色一次_ 。

因此，大场景的视觉效果可以在 **顶点处理阶段** 进行安全的计算。虽然这样定义的图元挺大的，有好几个像素。但其实同样的，只要顶点在图像中比较密集，高着色频率也可以在顶点处理阶段进行计算；对于那些比较稀疏的顶点，那么可以放到 **片元处理阶段** 进行计算。

举个例子，在游戏中使用的实时渲染管线一般使用的图元是包含了好几个像素的，为了运行的更快。所以它的着色步骤一般就会在 **片元处理阶段** 。与此相对的， _PRMan_ （皮克斯公司的动画渲染器）这个系统会对每个顶点都做一次着色，在第一次切片后，所有的表面都会被切分成由“微多边形”构成，这个“微多边形”就是一个像素的大小。因为图元很小，这个场景就很适合使用 **逐顶点着色** 。

## 8.3 简单抗锯齿

就和光线追踪一样，光栅化也会导致 斜线/三角形边 产生锯齿，这和我们判断一条线经不经过像素没关系。实际上，我们这章讲的简单三角形光栅化，就是会产生锯齿的，所以也叫 _走样光栅化_ 。和光学追踪的解决方法一样，解决办法可以是允许像素被图元 **部分覆盖** ，这样做一些模糊会有助于优化视觉效果，如 [图 8.15] 所示。

我们对于 _反走样_ ，也就是抗锯齿，有一些不同的实现方式。和光学追踪的操作一样，我们可以通过 _模糊_ ，也就是使用 _盒式滤波_ 对像素进行模糊化处理。这意味着我们定义的物体都有一块区域可供绘制。比如 [图 8.15] 就可以被认为是一种边缘宽度为 $1$ 的盒式滤波的结果.

> 有比盒式滤波更好的滤波器。但是对于大部分应用来说它已经够用了。

实现盒式滤波最简单的方法是通过 _超采样_ ：我们可以使用更高的分辨率绘制图像，然后将其降低分辨率。比如我们想要一个 $256\times 256$ 的图像，宽度是 $1.2$ 像素宽度，那么我们可以渲染一个 $1024\times 1024$ 的图像，然后将它 $4\times 4$ 的格子里取平均。这就是一种盒式滤波的类似操作，只要物体那些不是特别小，小到像素距离以内，它的效果就很好。

但是超采样很耗性能。因为导致走样的便基本上都是图元的边，而不是我们想象的因为颜色的突变产生走样。如果每个像素能存储多个遮盖和深度的信息，那么就算只有一种颜色计算出来，也能获得比较好的反走样效果。在 **逐顶点着色** 的系统中，如 RenderMan，我们可以简单通过超分辨率来实现，这种系统这样做开销不大，是因为逐顶点着色简单地将色彩插值，然后分发给不同的片元。而在 **逐片元着色** 的系统中，如实时渲染流水线，我们使用 _多重采样抗锯齿（MXAA）_ ，通过在一个片元后面添加多个采样点，然后计算采样点的覆盖率来计算颜色。深度值也是如此。

## 8.4 剔除图元以提升效能

对象顺序渲染的长处：只遍历整个场景的所有物体一次，也是它的软肋。在处理复杂场景的时候，会显得不那么友好。比如我们有一整个城市的建模，但你处在城市中央只需要看到几栋楼，这时对象顺序渲染的压力就会非常大；但那些后面的东西你本来就看不到，相当于做了无用功。

将看不到的东西扔掉，避免它们浪费处理资源，这个过程就叫 **剔除** 。有三种常见的剔除策略：

- 视锥体剔除：移除视锥体以外的几何体
- 遮挡剔除：移除视锥体内的、但可能被近处的几何体遮挡或很模糊的几何体
- 背面剔除：移除不朝向相机的那一面图元

我们会简单讨论一哈视锥剔除和背面剔除，但在高性能计算中剔除优化是一个复杂的课题。

### 8.4.1 视锥体剔除

如果一整个图元都在视锥外面，那么它就不会渲染任何片元出来，我们就可以剔除它。如果我们能设计一个快速的判断方法，那么应该就可以极大的提升运行效率。但从另外一个角度来说，单独去一个一个判断图元是否在视锥内，消耗是非常大的，还不如直接全着色然后最后让光栅化器来展示一部分。

视锥体剔除，对于那些物体里有很多三角形的情况效果非常好。这样我们就能将这个物体放进一个 _包围体_ 中。如果这个包围体都在视锥外了，那么就说明整个物体都不需要渲染了。例如，我们有由 $1000$ 个三角形组成的一个物体，被一个球体包围，它的中心是 $\rm\textbf{c}$ ，半径是 $r$ 。那么我们可以通过下面这个方程判断这个球是否在裁切平面之外：

$$\rm(\textbf{p} - \textbf{a})\cdot \textbf{n} = 0$$

这里 $\rm\textbf{a}$ 是平面上的点， $\rm\textbf{p}$ 是一个变量。这个方程的意思也可以换个说法，也就是判断球心 $\rm\textbf{c}$ 与平面的距离是否大于 $r$ 。也就是：

$$\frac{\rm(\textbf{c} - \textbf{a})\cdot \textbf{n}}{\parallel \rm \textbf{n} \parallel} > r$$

不过，这个球体可能会和平面重叠，也就是所有的三角形都在平面外的时候，因此，这个判断是相对保守的。测试是否保守取决于球体以何种方式包围物体。

类似的方法可以在 [12 章] 的空间数据结构中使用到。

### 8.4.2 背面剔除

当多边形都是闭合的（也就是它是不会“进水”的），那么就如 [第 10 章] 讨论的，每个闭合的多边形都有一个指向外侧的法向量。而对于这些模型，离眼睛的远端显然不需要着色，所以这些多边形甚至可以在管线 **开始之前** 就进行裁切。这种测试和 [10.3.1 节] 进行的剪影绘制相同。

## 常见问题

- **_我经常看到别的地方使用大量篇幅来解释裁切，内容多很多，为啥这章这么少？_**

  这一章介绍的裁切能用了，只是缺少优化。一般来说工业级的裁切才用的到这些优化。

- **_不是三角形的多边形如何光栅化？_**

  它们可以通过直接逐行扫描进行光栅化，或者它们被分解成三角形进行光栅化。后者较为常见。

- **_采用反走样总会更好是吗？_**

  其实不是。有些图不用抗锯齿可以更加清晰，正如一些程序使用不抗锯齿的字体，因为它们刚好辨认。

- **_我用的 API 文档提到了“视觉关系场景图”和“矩阵堆栈”。这些是图形管线的一部分吗？_**

  图形管线肯定在设计之初考虑到了这些。其实不管我们认为它属不属于管线都无所谓。本书在 [12 章] 会对它进行讨论。

- **_将深度作为一个单独的距离参数是比之前透视矩阵的非线性矩阵的参数更好吗？_**

  看情况。单独的深度信息有一个特点是距离更短，离眼睛处的分辨率更高。如果使用的是 LOD 系统（多细节层次），那么越远的物体就越糊，这时候深度的特性就派上用场了。

- **_深度缓存软件很有用吗？_**

  是的。大多数 3D 计算机图形制作的电影都使用了 Pixar 提供的深度缓存软件。

# 第九章 信号处理

**在图形学中，我们经常会遇到变量连续变化的函数：图像就是其中之一。但你会随着图形学的研究深入遇到越来越多的这类函数。这类函数和流式数据类似，不能被计算机直接表示。但我们不管咋样，都得在计算机中用一些比特来表示它。有一个很好用的方法是对这些函数进行 _采样_ ：也就是存储这个函数许多不同点的值，然后在需要函数的时候，通过这些值来还原这个函数。**

**你现在肯定已经熟悉使用二维网格表示像素的过程了——这其实就是一种采样！想象一下数码相机拍的照片：实际图像是由相机镜头构成的一个连续函数，但相机将它采样为二位网格状的数据。从数学的角度来说，这就是将一个 $\mathbb{R}^2 \Rightarrow \rm\textbf{C}$ （C 代表颜色集合）的函数转换成了一个二位的色彩采样阵列，即 $\mathbb{Z}^2 \Rightarrow \rm\textbf{C}$ 类型的函数。**

**另外一个采样表示的例子就是二位输入平板，可以在上面写写画画。在这里，原始函数是一个描述运动的函数，也就是 $\mathbb{R} \Rightarrow \mathbb{R}^2$ 的函数，平板将运动数字化，组成二位坐标的序列，也就是 $\mathbb{Z} \Rightarrow \mathbb{R}^2$ 的函数。**

**让我们增加一个维度，看看CT扫描仪：它能无创的扫描人体，然后得到人身体断层的密度值。扫描仪的输出是三维网格的密度数据：它将身体的密度数据（ $\mathbb{R}^2 \Rightarrow \mathbb{R}$ ）转化成三维实数数组 ( $\mathbb{Z}^2 \Rightarrow \mathbb{R}$ )。**

**看上去这些例子不太一样，但实际上他们都是用的同一种数学方法。所有的例子都将一个函数采样成多维网格的形式，同时，所有例子我们都需要将采集后的采样点重新组合成一个函数。**

**回到二维图像的例子上来，看上去像素已经够表示一幅图片了，我们也没想过怎么将采样点转化回函数。但，如果你想要缩放图像呢？尤其是非整数倍的缩放，那该怎么办？简单的算法难以完成这些要求，因为它在缩放时很容易产生 *走样* 。想要了解为什么会产生走样，我们需要走进采样理论的世界。**

**重建一个连续函数，并不是图形学的专利。它在很多地方得以使用，如数字音频、计算物理等，图形学只不过是其中的一个受益人而已。采样重建理论的基础形成于1920年左右，并在1940年时产生了我们现在用得到的那些理论。**

**这一张从一维音频开始，介绍了采样重建理论。然后，我们会讲述采样理论基础的数学和算法，最后，我们会研究频域视角的细节，它能让我们更直观的看到算法的行为。**

## 9.1 数字音频：一维采样

虽然采样很早就在通讯领域使用了，但直到1982年光盘的产生之后，数字音频才开始成为采样的第一“大客户”。

在录音时，麦克风将声音（声音是空气中的压力波）转化为在时间上不断变化的电压。这种电信号会以某种方式存储起来，以便以后发送给扬声器重新播放，这时候电压就会在扬声器内，通过与电信号同步，让振膜发出声音，信号重新变成压力波。

录制音频，并将它数字化的方法用到了采样：使用 *模数转换器* 测量电压信号，一秒测量几千次，这样能够形成一个数据流，可以存储在计算机的磁盘上或其他地方；在播放的时候，数据流以合适的速度进行读取，通过 *数模转换器* ，数据信号会转换成电信号，放入扬声器的输入区。

事实证明，能否录制出效果好的音频取决于每秒的采样率。较低的采样率对于录制鼓点可能效果还行，但录制笛子的时候就会听上去有问题，升高采样率就能很好的录制笛声。为了去除 *欠采样失真* ，数字录音机会将模数转换器的输入端做 *滤波* ，去除输入信号的高频区域，正是它们导致了失真问题。

输出端会出现另外一个问题：数模转换器会在接受采样输入的同时产生电压输出，但直到下一个采样输入前，电压是保持不变的，这就造成了一个类似楼梯的电压图像，这样的电压图像转化成声音就会产生高频噪声，听上去“滋滋滋”。为了去除 *重建性失真* ，音频播放器也会进行滤波，平滑波形。

### 9.1.1 采样失真和走样

我们上面说的录音机的采样流程和图形学需要的采样很类似。同样地，采样率不够会导致欠采样走样和重建性走样；同样地，解决方案都是在采样之前进行滤波，然后在重建后再进行一次滤波。

过低采样率引发的问题，有一个很直观的解释，请看 [图9.2] 。这里我们有两个 $\sin$ 函数。第一个函数我们在一个周期内采样10.8次，第二个只采样1.2次。高采样率显然更能体现图像特性，但主要问题是下面的使用低采样率的采样结果，和低频正弦波采样出的点是同一个。这种情况下，我们一般会将其重建为另外一个低频正弦波，这样就产生了失真。

一旦采样完毕后，只有点留下，我们就不知道这些点到底是高频正弦还是低频正弦的采样结果了，也没法正确的还原原始的函数。这样的情形就叫 *“走样”* 。

只要采样和重建的频率比较凑巧，那么就会出现走样。在音频中，比如原音频是10KHz的铃声，使用8KHz采样，就会变成6KHz的音调，听起来非常奇怪。在图像中，走样一般以 *摩尔纹* 的形式呈现。如 [图9.34] 的百叶窗。

同样的， [图9.34] 提供了图像走样的另外一种样子：也就是斜线产生锯齿。

理解上面的问题比较容易，但还有一些定量的问题需要探究：

- 多大的采样率能保证较好的成品？
- 采样和重建阶段使用的滤波器用哪种合适？
- 抗锯齿需要用哪种程度的平滑？

等到我们在 [9.5节] 讲完之后，我们就能回答这些问题了。

## 9.2 卷积

讨论采样和重建算法之前，我们先要看看数学基础： *卷积* 。卷积是一个简单的数学概念，它是我们采样、滤波、重建操作的基础，也是后面我们分析算法的基础。

卷积是一种函数操作：它接受两个函数，将他们合成一个新的函数。本书中，卷积的符号表示采用 $\star$ 。 $f$ 和 $g$ 的卷积是 $f\star g$ 。这时候我们说， $f$ 被 $g$ 卷积， $f\star g$ 是 $f$ 和 $g$ 卷积的结果。

卷积可以应用于连续函数（关于实数 $x$ 的函数 $f(x)$ ）或离散序列（关于整数 $i$ 的函数 $a[i]$ ）。 它可以应用于在一维、二维或更高维上定义的函数（也就是一、二或更多参数的函数）。 我们将首先从离散的一维情况开始，然后继续介绍连续函数以及二维和三维函数。

为了方便定义，我们假定了函数定义域是无穷，尽管实际应用中它会在某些地方停止。

### 9.2.1 滑动平均（MA）

为了对卷积有一个简单的印象，请思考一下对一个函数使用滑动平均（ [图9.3] ）。我们使用距离 $r$ 定义平滑操作的 *半径* 。在这个范围内对函数取平均值。

这种思想可以用于离散，也可以用于连续函数。如果用于连续函数，如果我们在对一个连续函数 $g(x)$ 做平滑，那么它的平均就相当于对其积分，并处以区间长度：

$$h(x) = \frac{1}{2r} \int_{x+r}^{x-r} g(t) dt$$

从另外一个角度来说，如果是离散的函数 $a[i]$ 那么取平均的意思就是对 $a$ 进行求和，然后除以值的个数：

$$c[i] = \frac{1}{2r+1} \sum_{j=i-r}^{i+r} a[j]$$

你会注意到在例子中，我们使用的分母是经过计算的，这样你在处理常数函数的时候结果肯定也是原来那个常数。

滑动平均的思想是卷积的精髓。他们之间唯一的区别是，在卷积中，滑动平均是以一种加权平均。

>  **为什么我们要在这里讨论卷积？** 你可以想想滑动平均的功能：它能平滑曲线，滤除超高或超低的值。

### 9.2.2 离散卷积

我们从最离散的卷积情况开始：也就是将一个离散序列 $a[i]$ 和另外一个离散序列 $b[i]$ 进行卷积。结果是 $(a\star b)[i]$ 。这个过程就像将 $a$ 进行一个滑动平均，但和直接使用半径 $r$ 取平均不同，这一次我们的权重是由 $b[i]$ 指定的：其中值 $b[i-j]$ 给出了位置 $j$ 处样本的权重，该位置距离正在计算卷积的位置 $i$ 的距离为 $i-j$ 。 这就是 $(a \star b)$ 的定义，表示为:

$$(a \star b)[i] = \sum a[j]b[i-j]$$

[图9.4] 描述了通过一个滤波序列 $b$ 计算离散序列 $a$ 的卷积。序列 $b$ 支持 $5$ 个样本。计算出的结果 $a\star b$ 是对序列 $a$ 这个地方周围共 $5$ 个值通过 $b$ 这五处的值进行加权平均。

如果我们忽略上面的 $j$ 的边界，我们就可以知道，这个求和操作是从 $-\infty$ 到 $+\infty$ 的，正如上面所说，我们能计算出来 $b[0] = \frac{6}{16}$ ， $a[\pm 1] = \frac{4}{16}$ 等等。

在图形学中，我们用于计算的函数很可能是 *有限支持* 的，换句话说，函数只在一块区间内是非零。如果我们假设 $b$ 是有限支持的，那么就会有一个 *“非零半径”* ，让 $|k| < r$ 时有 $b[k] = 0$ 。在之前 $a\star b$ 的例子中，我们可以将求和公式这样写：

$$(a\star b)[i] = \sum_{j=i-r}^{i+r} a[j]b[i-j]$$

然后我们也可以写出伪代码：

```vb
function convolve(sequence a, filter b, int i)
    s = 0
    r = b.radius
    for j = i − r to i + r do
        s = s + a[j] * b[i − j]
        return s
```

#### 卷积滤波

由于我们需要卷积来滤波，所以卷积很重要。回过头看看我们之前讲的滑动平均，你会发现滑动平均也是一种特殊的卷积。当我们对某范围内进行滑动平均，也就相当于通过某个半径内权重相同，半径外权重为 $0$ 的序列卷积。这种在特定非零区间上权重相同的滤波器称为 *盒式滤波* 。对于半径为 $r$ 的盒式滤波，有：

$$b[k] = \begin{equation*}
    \begin{cases}
        \frac{1}{2r+1} \ \ \ ,-r \leq k \leq r,  \\
        0 \ \ \ \ \ \ \ \ , \rm otherwise.
     \end{cases}
\end{equation*}
$$

就像这个例子一样，卷积滤波一般会被定义为所有的权重和为 $1$ 。这样，信号就不会被增强或减少。

#### 卷积的性质

写了这么多卷积的东西，我们发现卷积似乎是 *不对称操作* ： $a$ 是需要做平滑的序列； $b$ 是提供权重的序列。但其实，卷积有一个很棒的特点：那就是 **滤波器** 和 **信号** 其实是可以交换的。我们想想之前所说的 $a\star b$ ：如果两者交换，那么切片其实就是从 $b$ 的原点开始往后数数；也就是，我们可以将原式的 $j$ 换成 $i-k$ 。改变序号后的式子如下：

$$(a\star b)[i] = \sum_{k}a[i-k]b[i-(i-k)] \\
 \ = \sum_{k}b[k]a[i-k]$$

这不就是原来的式子吗？所以，我们说有 $(a\star b)=(b\star a)$ ，也就是说，卷积有 **交换律** 。

更广泛地说，卷积是一种 **“类似于乘法”** 的运算。就像数或函数的加法或乘法，卷积也一样，卷积的结果不会因为改变了项或者括号的顺序而改变。也就是具有 **结合律、交换律和分配律** 。

这样的性质非常自然而然，而且我们还可以在计算的时候利用这些性质来化简。（想想分配律的组合化简）。

最简单的滤波可以是单位滤波，也就是半径为 $0$ ，或是序列 $d[i] = ...,0,0,1,0,0,...$ 。显然，这样卷积 $a$ 和 $d$ ，卷积出来的结果还是 $a$ 自己。它有时候挺有用：比如我们在使用 $b$ 平滑 $a$ 之后需要把他本身减掉，那么可以直接使用 $d-b$ 作为卷积的第二个序列。

### 9.2.4 连续函数的卷积

尽管在计算机中进行运算的实际上是离散的序列，但那些采样的序列总是被用来表示某些连续函数的。所以我们需要能够计算出这些连续函数。所以，研究离散和连续/连续和连续函数的卷积的很有必要的。

连续函数的卷积公式来自离散的推广：

$$(f\star g)(x) = \int_{-\infty}^{+\infty}f(t)g(x-t)dt$$

那么我们怎么解释这个公式呢？从图像上看，最后的值代表了 $g$ **翻转** 后， $f$ 和 $g$ 的乘积所画出的图形 与 $x$ 轴包围的面积。就和离散状况一样，卷积是一种滑动平均，滤波器的值提供了做平均的 *权重* 。见 [图9.10]

同样的，连续函数的卷积也有 **交换律、结合律和分配律** 。

#### 例子：两个盒式滤波函数进行卷积

定义 $f$ 是一个盒式滤波函数：

$$f(x) = \begin{equation*}
     \begin{cases}
         1  \ \  - \frac{1}{2} \leq x \leq \frac{1}{2} \\
         0 \ \ \ \rm otherwise. \\
     \end{cases}
 \end{equation*}
$$

那么 $f \star f$ 是什么呢？由定义，我们可以得到：

$$(f\star f)(x) = \int_{-\infty}^{\infty} f(t)f(x-t)dt$$

[图9.11] 展示了这个情况。在 $x \leq -1$ 和 $x \geq 1$ 的区间上，我们看到两个盒式滤波器出现了值为 $0$ 的重叠区域，这意味着卷积的结果是 $0$ 。而有重叠的非零区域，我们容易得到结果是 $1-|x|$ 。

综上可得，
$$(f \star f)(x) = \begin{equation*}
     \begin{cases}
         1-|x|  \ \ \  -1 \leq x \leq 1 \\
         0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \rm otherwise. \\
     \end{cases}
 \end{equation*}
$$

这个函数叫 *帐篷函数* ，也是一个常用的滤波器函数。见 [9.3.1节]

#### 狄拉克Delta函数

在离散卷积中，我们发现了脉冲序列 $d$ 起到了作为 *单位函数* 的作用。也就是，任何函数和他进行卷积，结果不变。在连续函数中，也有一种类似的函数。我们将这种函数称作 ***狄拉克Delta函数*** 。用 $\delta (x)$ 表示。

看上去，狄拉克函数是类似于在 $0$ 点竖了一根针。它很细，但这块地方进行积分，结果是 $1$ 。这样定义的目的是让狄拉克函数选择（也就是卷积）出另外一个函数在 $0$ 处的值：

$$\int_{-\infty}^{\infty} \delta (x)f(x)dx = f(0)$$

但狄拉克函数在 $0$ 点时的值没有定义过（你可以认为值接近与 $+\infty$ ），但对于任意的 $x \neq 0$ ，它的值始终是 $0$ 。

由于狄拉克函数的性质，我们得以找到对于卷积运算的“单位函数”。

### 9.2.5 离散-连续函数的卷积

我们已经发现了一种联系离散和连续的方式： **采样** 。通过简单的忽略其他的非整数值，我们可以得到一个序列：

$$a[i] = f(i)$$

倒着讲，我们将离散序列变成连续函数的方式称为 *重建* 。我们通过使用另外一种形式的 **卷积** 来完成重建的过程。也就是我们这一节讲的： **离散-连续函数的卷积** ：

$$(a\star f)(x) = \sum a[i]f(x-i)$$

---

书上的内容似乎不太好理解。如果你没看懂，我们来看一个例子：

在物理课上, 我们知道机械波是可以叠加的。我们假设有一个机械波 $g(x,t)$ , 描述了 $t$ 时刻 $x$ 点的位移。假设它的 **振源** 是原点, 那么如果将振源 **平移** 到点 $y$ , 那么这个机械波就变成了 $g(x-y,t)$ 。该函数表示的意义是：有一个振源在 $y$ 点，那么 $t$ 时刻在 $x$ 位置的位移是 $g(x-y,t)$ 。

现在我们假设有 $n$ 个振源，它们分别位于点 $y_1,...,y_n$ ，每个振源都是 $0$ 时刻开始振动。由于机械波是可以叠加的, 在 $t$ 时刻，任意点 $x$ 处由振荡引起的位移便是:

$$h(x,t) = \sum^{n}_{i=1} g(x-y_i,t)$$

现在情况稍微复杂一点：每个振源的振动强度不一样，由 $A_1,...,A_n$ 表示。上式就会变成：

$$h(x,t) =  \sum^{n}_{i=1} A_ig(x-y_i,t)$$

既然振源和振幅一一对应了，我们可以考虑把它写成一个函数 $f(x_i) = A_i$ 。其他地方则取 $0$ 。再次改变上式，很容易就能得到：

$$h(x,t) =  \sum^{n}_{i=1} f(y_i)g(x-y_i,t)$$

写到这里，你应该已经发现了，对每个时刻 $t$ ，将 $g(x-y_i,t)$ 视为 $g_t(x-y_i)$ ，它描述了在某时刻，各点的运动状态，这样我们也能将 $h(x,t)$ 视作 $h_t(x)$ 。剔除了 $t$ 的影响，我们终于能写出 $x$ 和 $y$ 之间的纯粹的关系：

$$h_t(x) = \sum^{n}_{i=1} f(y_i)g_t(x-y_i)$$

这样我们就得到了单离散单连续情形的卷积 $h_t = f \star g_t$ ！

---

### 9.2.6 多维卷积

我们之前一直在讲一维的卷积：单个变量 $x$ 或者是单个序列 $i$ 。但图形学中的应用大多数是二维的，尤其是二维图像。不过，从一维拓展到二维、三维卷积，是比较简单的。

从离散卷积的定义开始，类似的，我们拓展到二维：

$$(a \star b)[i,j] = \sum_{i'} \sum_{j'}a[i',j']b[i-i',j-j']$$

如果 $b$ 是一个定义好的滤波器，拥有 $r$ 的半径，那么一共就会有 $(2r+1)^2$ 个值，我们就可以加上边界：

$$(a \star b)[i,j] = \sum_{i'=i-r}^{i+r} \sum_{j'=j-r}^{j+r} a[i',j']b[i-i',j-j']$$

具体图像如 [图9.16] 所示。

用代码表示如下：

```vb
function convolve2d(sequence2d a, filter2d b, int i, int j)
    s = 0
    r = b.radius
    for i_1 = i-r to i+r do
        for j_1 = j-r to j+r do
            s = s+a[i_1][j_1]*b[i-i_1][j-j_1]
    return s
```

它的几何意义和一维是一样的：每个输出的值是输入值周围一圈的带权平均。这里的 *滤波器* 则是类似于遮罩一样、罩住需要取带权平均的区域。

所以，类似的，我们也能推广出二维连续函数的卷积公式：

$$(f\star g)(x,y) = \int\int f(x',y')g(x-x',y-y')dx'dy'$$
$$(a\star g)(x,y) = \sum_{i}\sum_{j} a[i,j]g(x-i,y-j)$$

上面的情况都一样，都是某个点的值经过周围值平均后的结果。对于双连续函数的卷积，则是按照周围一圈区域的积分来确定平均的权值。

同样的，我们已经可以轻易推出更高维的情况了。

## 9.3 卷积滤波器

了解了卷积，我们来看看在图形学中常用的一些滤波器。

下面要介绍的滤波器都有一个固定的半径，它们的半径有一个默认值，便于我们使用。例如，盒式滤波的默认半径是 $\frac{1}{2}$ ，立方体滤波的默认半径是 $2$ 。最后，我们规定了所有的滤波器都要满足积分为 $1$ ，即 $\int_{x=0}^{\infty}f(x)dx = 1$ ，这样我们就能不改变信号的平均大小，然后对信号做采样和重建。

我们在 [9.4.3节] 即将说到，一些应用需要不同尺寸的滤波器，这可以通过缩放滤波器得到。





