<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [["$", "$"], ["\\(", "\\)"]],
            displayMath: [["$$", "$$"], ["\\[", "\\]"]],
            }
        });
    </script>
</head>

# 第九章 信号处理

**在图形学中，我们经常会遇到变量连续变化的函数：图像就是其中之一。但你会随着图形学的研究深入遇到越来越多的这类函数。这类函数和流式数据类似，不能被计算机直接表示。但我们不管咋样，都得在计算机中用一些比特来表示它。有一个很好用的方法是对这些函数进行 _采样_ ：也就是存储这个函数许多不同点的值，然后在需要函数的时候，通过这些值来还原这个函数。**

**你现在肯定已经熟悉使用二维网格表示像素的过程了——这其实就是一种采样！想象一下数码相机拍的照片：实际图像是由相机镜头构成的一个连续函数，但相机将它采样为二位网格状的数据。从数学的角度来说，这就是将一个 $\mathbb{R}^2 \Rightarrow \rm\textbf{C}$ （C 代表颜色集合）的函数转换成了一个二位的色彩采样阵列，即 $\mathbb{Z}^2 \Rightarrow \rm\textbf{C}$ 类型的函数。**

**另外一个采样表示的例子就是二位输入平板，可以在上面写写画画。在这里，原始函数是一个描述运动的函数，也就是 $\mathbb{R} \Rightarrow \mathbb{R}^2$ 的函数，平板将运动数字化，组成二位坐标的序列，也就是 $\mathbb{Z} \Rightarrow \mathbb{R}^2$ 的函数。**

**让我们增加一个维度，看看 CT 扫描仪：它能无创的扫描人体，然后得到人身体断层的密度值。扫描仪的输出是三维网格的密度数据：它将身体的密度数据（ $\mathbb{R}^2 \Rightarrow \mathbb{R}$ ）转化成三维实数数组 ( $\mathbb{Z}^2 \Rightarrow \mathbb{R}$ )。**

**看上去这些例子不太一样，但实际上他们都是用的同一种数学方法。所有的例子都将一个函数采样成多维网格的形式，同时，所有例子我们都需要将采集后的采样点重新组合成一个函数。**

**回到二维图像的例子上来，看上去像素已经够表示一幅图片了，我们也没想过怎么将采样点转化回函数。但，如果你想要缩放图像呢？尤其是非整数倍的缩放，那该怎么办？简单的算法难以完成这些要求，因为它在缩放时很容易产生 _走样_ 。想要了解为什么会产生走样，我们需要走进采样理论的世界。**

**重建一个连续函数，并不是图形学的专利。它在很多地方得以使用，如数字音频、计算物理等，图形学只不过是其中的一个受益人而已。采样重建理论的基础形成于 1920 年左右，并在 1940 年时产生了我们现在用得到的那些理论。**

**这一张从一维音频开始，介绍了采样重建理论。然后，我们会讲述采样理论基础的数学和算法，最后，我们会研究频域视角的细节，它能让我们更直观的看到算法的行为。**

## 9.1 数字音频：一维采样

虽然采样很早就在通讯领域使用了，但直到 1982 年光盘的产生之后，数字音频才开始成为采样的第一“大客户”。

在录音时，麦克风将声音（声音是空气中的压力波）转化为在时间上不断变化的电压。这种电信号会以某种方式存储起来，以便以后发送给扬声器重新播放，这时候电压就会在扬声器内，通过与电信号同步，让振膜发出声音，信号重新变成压力波。

录制音频，并将它数字化的方法用到了采样：使用 _模数转换器_ 测量电压信号，一秒测量几千次，这样能够形成一个数据流，可以存储在计算机的磁盘上或其他地方；在播放的时候，数据流以合适的速度进行读取，通过 _数模转换器_ ，数据信号会转换成电信号，放入扬声器的输入区。

事实证明，能否录制出效果好的音频取决于每秒的采样率。较低的采样率对于录制鼓点可能效果还行，但录制笛子的时候就会听上去有问题，升高采样率就能很好的录制笛声。为了去除 _欠采样失真_ ，数字录音机会将模数转换器的输入端做 _滤波_ ，去除输入信号的高频区域，正是它们导致了失真问题。

输出端会出现另外一个问题：数模转换器会在接受采样输入的同时产生电压输出，但直到下一个采样输入前，电压是保持不变的，这就造成了一个类似楼梯的电压图像，这样的电压图像转化成声音就会产生高频噪声，听上去“滋滋滋”。为了去除 _重建性失真_ ，音频播放器也会进行滤波，平滑波形。

### 9.1.1 采样失真和走样

我们上面说的录音机的采样流程和图形学需要的采样很类似。同样地，采样率不够会导致欠采样走样和重建性走样；同样地，解决方案都是在采样之前进行滤波，然后在重建后再进行一次滤波。

过低采样率引发的问题，有一个很直观的解释，请看 [图 9.2] 。这里我们有两个 $\sin$ 函数。第一个函数我们在一个周期内采样 10.8 次，第二个只采样 1.2 次。高采样率显然更能体现图像特性，但主要问题是下面的使用低采样率的采样结果，和低频正弦波采样出的点是同一个。这种情况下，我们一般会将其重建为另外一个低频正弦波，这样就产生了失真。

一旦采样完毕后，只有点留下，我们就不知道这些点到底是高频正弦还是低频正弦的采样结果了，也没法正确的还原原始的函数。这样的情形就叫 _“走样”_ 。

只要采样和重建的频率比较凑巧，那么就会出现走样。在音频中，比如原音频是 10KHz 的铃声，使用 8KHz 采样，就会变成 6KHz 的音调，听起来非常奇怪。在图像中，走样一般以 _摩尔纹_ 的形式呈现。如 [图 9.34] 的百叶窗。

同样的， [图 9.34] 提供了图像走样的另外一种样子：也就是斜线产生锯齿。

理解上面的问题比较容易，但还有一些定量的问题需要探究：

- 多大的采样率能保证较好的成品？
- 采样和重建阶段使用的滤波器用哪种合适？
- 抗锯齿需要用哪种程度的平滑？

等到我们在 [9.5 节] 讲完之后，我们就能回答这些问题了。

## 9.2 卷积

讨论采样和重建算法之前，我们先要看看数学基础： _卷积_ 。卷积是一个简单的数学概念，它是我们采样、滤波、重建操作的基础，也是后面我们分析算法的基础。

卷积是一种函数操作：它接受两个函数，将他们合成一个新的函数。本书中，卷积的符号表示采用 $\star$ 。 $f$ 和 $g$ 的卷积是 $f\star g$ 。这时候我们说， $f$ 被 $g$ 卷积， $f\star g$ 是 $f$ 和 $g$ 卷积的结果。

卷积可以应用于连续函数（关于实数 $x$ 的函数 $f(x)$ ）或离散序列（关于整数 $i$ 的函数 $a[i]$ ）。 它可以应用于在一维、二维或更高维上定义的函数（也就是一、二或更多参数的函数）。 我们将首先从离散的一维情况开始，然后继续介绍连续函数以及二维和三维函数。

为了方便定义，我们假定了函数定义域是无穷，尽管实际应用中它会在某些地方停止。

### 9.2.1 滑动平均（MA）

为了对卷积有一个简单的印象，请思考一下对一个函数使用滑动平均（ [图 9.3] ）。我们使用距离 $r$ 定义平滑操作的 _半径_ 。在这个范围内对函数取平均值。

这种思想可以用于离散，也可以用于连续函数。如果用于连续函数，如果我们在对一个连续函数 $g(x)$ 做平滑，那么它的平均就相当于对其积分，并处以区间长度：

$$h(x) = \frac{1}{2r} \int_{x+r}^{x-r} g(t) dt$$

从另外一个角度来说，如果是离散的函数 $a[i]$ 那么取平均的意思就是对 $a$ 进行求和，然后除以值的个数：

$$c[i] = \frac{1}{2r+1} \sum_{j=i-r}^{i+r} a[j]$$

你会注意到在例子中，我们使用的分母是经过计算的，这样你在处理常数函数的时候结果肯定也是原来那个常数。

滑动平均的思想是卷积的精髓。他们之间唯一的区别是，在卷积中，滑动平均是以一种加权平均。

> **为什么我们要在这里讨论卷积？** 你可以想想滑动平均的功能：它能平滑曲线，滤除超高或超低的值。

### 9.2.2 离散卷积

我们从最离散的卷积情况开始：也就是将一个离散序列 $a[i]$ 和另外一个离散序列 $b[i]$ 进行卷积。结果是 $(a\star b)[i]$ 。这个过程就像将 $a$ 进行一个滑动平均，但和直接使用半径 $r$ 取平均不同，这一次我们的权重是由 $b[i]$ 指定的：其中值 $b[i-j]$ 给出了位置 $j$ 处样本的权重，该位置距离正在计算卷积的位置 $i$ 的距离为 $i-j$ 。 这就是 $(a \star b)$ 的定义，表示为:

$$(a \star b)[i] = \sum a[j]b[i-j]$$

[图 9.4] 描述了通过一个滤波序列 $b$ 计算离散序列 $a$ 的卷积。序列 $b$ 支持 $5$ 个样本。计算出的结果 $a\star b$ 是对序列 $a$ 这个地方周围共 $5$ 个值通过 $b$ 这五处的值进行加权平均。

如果我们忽略上面的 $j$ 的边界，我们就可以知道，这个求和操作是从 $-\infty$ 到 $+\infty$ 的，正如上面所说，我们能计算出来 $b[0] = \frac{6}{16}$ ， $a[\pm 1] = \frac{4}{16}$ 等等。

在图形学中，我们用于计算的函数很可能是 _有限支持_ 的，换句话说，函数只在一块区间内是非零。如果我们假设 $b$ 是有限支持的，那么就会有一个 _非零半径_ ，让 $|k| < r$ 时有 $b[k] = 0$ 。在之前 $a\star b$ 的例子中，我们可以将求和公式这样写：

$$(a\star b)[i] = \sum_{j=i-r}^{i+r} a[j]b[i-j]$$

然后我们也可以写出伪代码：

```vb
function convolve(sequence a, filter b, int i)
    s = 0
    r = b.radius
    for j = i − r to i + r do
        s = s + a[j] * b[i − j]
        return s
```

#### 卷积滤波

由于我们需要卷积来滤波，所以卷积很重要。回过头看看我们之前讲的滑动平均，你会发现滑动平均也是一种特殊的卷积。当我们对某范围内进行滑动平均，也就相当于通过某个半径内权重相同，半径外权重为 $0$ 的序列卷积。这种在特定非零区间上权重相同的滤波器称为 _盒式滤波_ 。对于半径为 $r$ 的盒式滤波，有：

$$
b[k] = \begin{equation*}
    \begin{cases}
        \frac{1}{2r+1} \ \ \ ,-r \leq k \leq r,  \\
        0 \ \ \ \ \ \ \ \ , \rm otherwise.
     \end{cases}
\end{equation*}
$$

就像这个例子一样，卷积滤波一般会被定义为所有的权重和为 $1$ 。这样，信号就不会被增强或减少。

#### 卷积的性质

写了这么多卷积的东西，我们发现卷积似乎是 _不对称操作_ ： $a$ 是需要做平滑的序列； $b$ 是提供权重的序列。但其实，卷积有一个很棒的特点：那就是 **滤波器** 和 **信号** 其实是可以交换的。我们想想之前所说的 $a\star b$ ：如果两者交换，那么切片其实就是从 $b$ 的原点开始往后数数；也就是，我们可以将原式的 $j$ 换成 $i-k$ 。改变序号后的式子如下：

$$
(a\star b)[i] = \sum_{k}a[i-k]b[i-(i-k)] \\
 \ = \sum_{k}b[k]a[i-k]
$$

这不就是原来的式子吗？所以，我们说有 $(a\star b)=(b\star a)$ ，也就是说，卷积有 **交换律** 。

更广泛地说，卷积是一种 **“类似于乘法”** 的运算。就像数或函数的加法或乘法，卷积也一样，卷积的结果不会因为改变了项或者括号的顺序而改变。也就是具有 **结合律、交换律和分配律** 。

这样的性质非常自然而然，而且我们还可以在计算的时候利用这些性质来化简。（想想分配律的组合化简）。

最简单的滤波可以是单位滤波，也就是半径为 $0$ ，或是序列 $d[i] = ...,0,0,1,0,0,...$ 。显然，这样卷积 $a$ 和 $d$ ，卷积出来的结果还是 $a$ 自己。它有时候挺有用：比如我们在使用 $b$ 平滑 $a$ 之后需要把他本身减掉，那么可以直接使用 $d-b$ 作为卷积的第二个序列。

### 9.2.4 连续函数的卷积

尽管在计算机中进行运算的实际上是离散的序列，但那些采样的序列总是被用来表示某些连续函数的。所以我们需要能够计算出这些连续函数。所以，研究离散和连续/连续和连续函数的卷积的很有必要的。

连续函数的卷积公式来自离散的推广：

$$(f\star g)(x) = \int_{-\infty}^{+\infty}f(t)g(x-t)dt$$

那么我们怎么解释这个公式呢？从图像上看，最后的值代表了 $g$ **翻转** 后， $f$ 和 $g$ 的乘积所画出的图形 与 $x$ 轴包围的面积。就和离散状况一样，卷积是一种滑动平均，滤波器的值提供了做平均的 _权重_ 。见 [图 9.10]

同样的，连续函数的卷积也有 **交换律、结合律和分配律** 。

#### 例子：两个盒式滤波函数进行卷积

定义 $f$ 是一个盒式滤波函数：

$$
f(x) = \begin{equation*}
     \begin{cases}
         1  \ \  - \frac{1}{2} \leq x \leq \frac{1}{2} \\
         0 \ \ \ \rm otherwise. \\
     \end{cases}
 \end{equation*}
$$

那么 $f \star f$ 是什么呢？由定义，我们可以得到：

$$(f\star f)(x) = \int_{-\infty}^{\infty} f(t)f(x-t)dt$$

[图 9.11] 展示了这个情况。在 $x \leq -1$ 和 $x \geq 1$ 的区间上，我们看到两个盒式滤波器出现了值为 $0$ 的重叠区域，这意味着卷积的结果是 $0$ 。而有重叠的非零区域，我们容易得到结果是 $1-|x|$ 。

综上可得，

$$
(f \star f)(x) = \begin{equation*}
     \begin{cases}
         1-|x|  \ \ \  -1 \leq x \leq 1 \\
         0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \rm otherwise. \\
     \end{cases}
 \end{equation*}
$$

这个函数叫 _帐篷函数_ ，也是一个常用的滤波器函数。见 [9.3.1 节]

#### 狄拉克 Delta 函数

在离散卷积中，我们发现了脉冲序列 $d$ 起到了作为 _单位函数_ 的作用。也就是，任何函数和他进行卷积，结果不变。在连续函数中，也有一种类似的函数。我们将这种函数称作 **_狄拉克 Delta 函数_** 。用 $\delta (x)$ 表示。

看上去，狄拉克函数是类似于在 $0$ 点竖了一根针。它很细，但这块地方进行积分，结果是 $1$ 。这样定义的目的是让狄拉克函数选择（也就是卷积）出另外一个函数在 $0$ 处的值：

$$\int_{-\infty}^{\infty} \delta (x)f(x)dx = f(0)$$

但狄拉克函数在 $0$ 点时的值没有定义过（你可以认为值接近与 $+\infty$ ），但对于任意的 $x \neq 0$ ，它的值始终是 $0$ 。

由于狄拉克函数的性质，我们得以找到对于卷积运算的“单位函数”。

### 9.2.5 离散-连续函数的卷积

我们已经发现了一种联系离散和连续的方式： **采样** 。通过简单的忽略其他的非整数值，我们可以得到一个序列：

$$a[i] = f(i)$$

倒着讲，我们将离散序列变成连续函数的方式称为 _重建_ 。我们通过使用另外一种形式的 **卷积** 来完成重建的过程。也就是我们这一节讲的： **离散-连续函数的卷积** ：

$$(a\star f)(x) = \sum a[i]f(x-i)$$

---

书上的内容似乎不太好理解。如果你没看懂，我们来看一个例子：

在物理课上, 我们知道机械波是可以叠加的。我们假设有一个机械波 $g(x,t)$ , 描述了 $t$ 时刻 $x$ 点的位移。假设它的 **振源** 是原点, 那么如果将振源 **平移** 到点 $y$ , 那么这个机械波就变成了 $g(x-y,t)$ 。该函数表示的意义是：有一个振源在 $y$ 点，那么 $t$ 时刻在 $x$ 位置的位移是 $g(x-y,t)$ 。

现在我们假设有 $n$ 个振源，它们分别位于点 $y_1,...,y_n$ ，每个振源都是 $0$ 时刻开始振动。由于机械波是可以叠加的, 在 $t$ 时刻，任意点 $x$ 处由振荡引起的位移便是:

$$h(x,t) = \sum^{n}_{i=1} g(x-y_i,t)$$

现在情况稍微复杂一点：每个振源的振动强度不一样，由 $A_1,...,A_n$ 表示。上式就会变成：

$$h(x,t) =  \sum^{n}_{i=1} A_ig(x-y_i,t)$$

既然振源和振幅一一对应了，我们可以考虑把它写成一个函数 $f(x_i) = A_i$ 。其他地方则取 $0$ 。再次改变上式，很容易就能得到：

$$h(x,t) =  \sum^{n}_{i=1} f(y_i)g(x-y_i,t)$$

写到这里，你应该已经发现了，对每个时刻 $t$ ，将 $g(x-y_i,t)$ 视为 $g_t(x-y_i)$ ，它描述了在某时刻，各点的运动状态，这样我们也能将 $h(x,t)$ 视作 $h_t(x)$ 。剔除了 $t$ 的影响，我们终于能写出 $x$ 和 $y$ 之间的纯粹的关系：

$$h_t(x) = \sum^{n}_{i=1} f(y_i)g_t(x-y_i)$$

这样我们就得到了单离散单连续情形的卷积 $h_t = f \star g_t$ ！

---

### 9.2.6 多维卷积

我们之前一直在讲一维的卷积：单个变量 $x$ 或者是单个序列 $i$ 。但图形学中的应用大多数是二维的，尤其是二维图像。不过，从一维拓展到二维、三维卷积，是比较简单的。

从离散卷积的定义开始，类似的，我们拓展到二维：

$$(a \star b)[i,j] = \sum_{i'} \sum_{j'}a[i',j']b[i-i',j-j']$$

如果 $b$ 是一个定义好的滤波器，拥有 $r$ 的半径，那么一共就会有 $(2r+1)^2$ 个值，我们就可以加上边界：

$$(a \star b)[i,j] = \sum_{i'=i-r}^{i+r} \sum_{j'=j-r}^{j+r} a[i',j']b[i-i',j-j']$$

具体图像如 [图 9.16] 所示。

用代码表示如下：

```vb
function convolve2d(sequence2d a, filter2d b, int i, int j)
    s = 0
    r = b.radius
    for i_1 = i-r to i+r do
        for j_1 = j-r to j+r do
            s = s+a[i_1][j_1]*b[i-i_1][j-j_1]
    return s
```

它的几何意义和一维是一样的：每个输出的值是输入值周围一圈的带权平均。这里的 _滤波器_ 则是类似于遮罩一样、罩住需要取带权平均的区域。

所以，类似的，我们也能推广出二维连续函数的卷积公式：

$$(f\star g)(x,y) = \int\int f(x',y')g(x-x',y-y')dx'dy'$$
$$(a\star g)(x,y) = \sum_{i}\sum_{j} a[i,j]g(x-i,y-j)$$

上面的情况都一样，都是某个点的值经过周围值平均后的结果。对于双连续函数的卷积，则是按照周围一圈区域的积分来确定平均的权值。

同样的，我们已经可以轻易推出更高维的情况了。

## 9.3 卷积滤波器

了解了卷积，我们来看看在图形学中常用的一些滤波器。

下面要介绍的滤波器都有一个固定的半径，它们的半径有一个默认值，便于我们使用。例如，盒式滤波的默认半径是 $\frac{1}{2}$ ，立方体滤波的默认半径是 $2$ 。最后，我们规定了所有的滤波器都要满足积分为 $1$ ，即 $\int_{x=0}^{\infty}f(x)dx = 1$ ，这样我们就能不改变信号的平均大小，然后对信号做采样和重建。

我们在 [9.4.3 节] 即将说到，一些应用需要不同尺寸的滤波器，这可以通过缩放滤波器得到。我们可以通过定义一个缩放系数 $s$ 来缩放滤波函数 $f(x)$ ：

$$f_s(x) = \frac{f(x/s)}{s}$$

这样，这个滤波函数会在水平方向上被拉伸 $s$ 倍，然后在垂直方向上被挤压成原来的 $\frac{1}{s}$ 。这样做的理由是需要保持积分不变，也就是面积不变。经过缩放之后，原来的半径 $r$ 变成了 $sr$ 。

### 9.3.1 一些卷积滤波器

#### 盒式滤波

盒式滤波是分段的常数函数。离散形式是：

$$
a_{box,r}[i] = \begin{equation*}
     \begin{cases}
         \frac{1}{2r+1}  \ \ \ \ \ \ \  |i| \leq r \\
         0 \ \ \ \ \ \ \ \ \ \ \ \ \ \rm otherwise. \\
     \end{cases}
 \end{equation*}
$$

为了对称性，这个方程将端点包含在内。

该滤波器的连续形式是：

$$
f_{box,r}(x) = \begin{equation*}
     \begin{cases}
         \frac{1}{2r}  \ \ \ \ \ \ \  -r\leq x < r \\
         0 \ \ \ \ \ \ \ \ \ \ \ \ \ \rm otherwise. \\
     \end{cases}
 \end{equation*}
$$

那么为什么这个方程的区间不是对称的呢？因为在连续的情形，我们想要对函数进行 **重建** ，那么就需要连续的区间，这时边界值需要好好考虑。最后，对于默认半径 $r=\frac{1}{2}$ ，我们用 $f_{box}$ 表示。

#### 帐篷滤波/线性滤波

同理，帐篷滤波是一种连续的、部分线性的函数：

$$
f_{tent}(x) = \begin{equation*}
     \begin{cases}
         1-|x|  \ \ \ \ \ \ |x| < 1 \\
         0 \ \ \ \ \ \ \ \ \ \ \ \ \ \rm otherwise. \\
     \end{cases}
 \end{equation*}
$$

默认半径是 $r=1$ 。像这种默认函数（ $C^0$ 是该函数连续的意思），我们不需要在端点定义跳变，那就不需要将离散和连续分开定义。

#### 高斯滤波

高斯函数，也被称为正态分布函数，是非常重要的一种函数。之后我们会讲到更多这方面的东西。该函数如下：

$$f_{g},\sigma(x) = \frac{1}{\sigma \sqrt{2\pi}}e^{-x^2/2\sigma ^2}$$

参数 $\sigma$ 叫做 **_标准差_** 。高斯滤波由于它的平滑性，在采样滤波中很有用。之后我们会详细讲述。

但注意，高斯滤波没有默认半径，因为我们可以通过控制标准差 $\sigma$ 来控制滤波距离。同样的，高斯滤波没有 _支持半径_ ，因为越往两边，函数值越小，但不会是 $0$ ，只是趋近于 $0$ 。当我们有需要的时候，我们可以将半径 $r$ 以外的部分设置为 $0$ （一般可以设置为 $1$ 或 $3$ ），这样我们就能得到 _裁剪高斯滤波_ 。这意味着不同的应用可以使用不同的半径，也可以将这个半径进行缩放成 $sr$ ，这时标准差也会缩放到 $s\sigma$ 。如果我们需要半径，那么将半径 $r$ 和标准差 $\sigma$ 共同作为参数挺不错。

#### 三次 B 样条滤波

很多滤波器被定义为一些 _多项式_ 。而具有四段（默认半径为 $r=6$ ）的三次滤波常用来进行 **重建** 。有这样一种滤波，叫 **B 样条滤波** ，见 [图 9.22] ，它以 $(0,\frac{2}{3})$ 点为最大值，样子类似正态分布。叫这个名字是因为它是一些 _样条曲线_ 的 **混合** （Blend）。

$$
f_{B}(x) = \begin{equation*}
     \begin{cases}
         -3(1-|x|)^3+3(1-|x|)^2 +3(1-|x|)+1, \ \ \ \ \ \ -1 \leq |x| \leq 1 \\
         (2-|x|)^3, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1 \leq |x| \leq 2\\
         0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \rm otherwise.\\
     \end{cases}
 \end{equation*}
$$

在分段立方体中，B 样条非常的特殊，因为它的一阶导和二阶导 **连续** （可以用 $C^2$ 表示一二阶导连续）。我们可以通过一种更简洁的方式定义上面那个方程组，那就是： $f_B = f_{box} \star f_{box} \star f_{box} \star f_{box}$ 。这就是我们花大篇幅讲卷积的意义，它是这个滤波的出处。

#### 三次 Catmull-Rom 滤波

这个滤波也是样条滤波，它在 $x=-2,-1,1,2$ 的时候函数值为 $0$ 。这意味着它可以作为重建滤波器插值样本。

$$
f_{C}(x) = \frac{1}{2}\begin{equation*}
     \begin{cases}
         -3(1-|x|)^3+4(1-|x|)^2 +(1-|x|), \ \ \ \ \ \ -1 \leq |x| \leq 1 \\
         (2-|x|)^3-(2-|x|)^2, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1 \leq |x| \leq 2\\
         0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \rm otherwise.\\
     \end{cases}
 \end{equation*}
$$

#### 三次 Mitchell-Netravali 滤波

三次 Mitchell-Netravali 滤波器用于解决重采样图像问题，在上述两种三次滤波器中折中改进，这种滤波器是前面两种滤波器的加权组合。数学表达式：

$$f_M(x) = \frac{1}{3}f_B(x)+\frac{2}{3}f_C(x)$$

$$
f_{C}(x) = \frac{1}{2}\begin{equation*}
     \begin{cases}
         -21(1-|x|)^3+27(1-|x|)^2 +9(1-|x|)+1, \ \ \ \ \ \ -1 \leq |x| \leq 1 \\
         7(2-|x|)^3-6(2-|x|)^2, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1 \leq |x| \leq 2\\
         0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \rm otherwise.\\
     \end{cases}
 \end{equation*}
$$

### 9.3.2 滤波器的性质

滤波器有一些常用的术语，用来描述或比较。

_冲激响应_ 描述了一个滤波函数对一个只包含单个脉冲的信号的相应（回想一下，对单个脉冲进行卷积，得到的是本身）。

如果一个连续滤波函数被用在一个离散序列上进行 **重建** 操作，重建出来的函数能经过所有的 _采样点_ ，我们就称之为 **_插值_** 。插值滤波就是那些 $f(0)=1$ 且在任意不为零的 $i$ , $f(i)=0$ 的函数。

如果一个滤波器存在负值，那么在滤波时，会产生 _振铃效应_ / _过冲_ ：它会让原函数变化的区域产生额外的信号抖动。比如， _Catmull-Rom 滤波_ 在图像两侧都有负值区域，所以当它被用于一个阶跃函数时，会在阶跃函数的 0 点产生 _下冲_ ，在 1 点产生 _过冲_ 。

如果一个滤波器用于常数函数，输出的仍然是常数函数，那么我们说它是 _无纹波_ 的。这个概念的定义和全域积分为 $1$ 是一样的：

$${\rm \sum_{i}f(x+i)=1 \ for \ all \ }x$$

之前讲的所有滤波函数，在他们的 _默认半径下_ 都是无纹波的，除了 **高斯滤波** 。但是他们在非整数的应用场景下并不需要无纹波。如果我们很需要无纹波这一特性，可以这样做：计算结果前全部同除以权重和。

$$(\overline{a\star f})(x) = \frac{\sum_{i}a[i]f(x-i)}{\sum_{i}a[i]}$$

这个表达式也可以写成 $a$ 和 $\overline{f}$ 的卷积。

连续的滤波函数有一个 _连续程度_ ，通过高阶导数来描述。一个盒式滤波函数，由于有 **间断点** ，所以它不是连续的。一个帐篷滤波函数，是连续的，但它在某些地方斜率突然改变，也就是一阶导不连续，我们称为 $C^0$ 。同理，二阶导也连续的函数，如 **B 样条函数** ，是 $C^2$ 。连续性的好和坏对于 **重建** 很重要，因为重建函数的连续性是和滤波函数的连续性息息相关的。

#### 可分离滤波器

对于图像这类的 **二维** 数据，我们也需要一个滤波器。但我们至今只说过一维滤波器。理论上来说，任意的二维函数都可以作为二维滤波器，有些时候这样定义反而比较简单，但是，大多数情况下，我们构造二维滤波器的方式是通过 **一维滤波的组合** 实现的。

最好用的方法是使用 **可分离滤波器** 。对于一个可分离滤波器 $f_2(x,y)$ ，我们可以简单的将某个一维滤波器的 $x,y$ 取值相乘：

$$f_2(x,y) = f_1(x)f_1(y)$$

离散情况也一样：

$$b_2[i,j] = b_1[i]b_1[j]$$

$f_2$ 的任意垂直或水平图形都是 $f_1$ 拉伸后的图像。如果 $f_1$ 标准化过，那么 $f_2$ 的积分其实就是 $f_1$ 积分的平方，所以也是 **标准化** 的。

#### 例子：可分离帐篷滤波

我们选的是帐篷函数当作 $f_1$ 进行组合，那么得到的 _双线性函数_ 是：

$$
f_{\rm 2,tent}(x,y) = \frac{1}{2}\begin{equation*}
     \begin{cases}
         (1-|x|)(1-|y|), \ \ \ \ \ |x| \leq 1 \ and \ |y| \leq 1 \\
         0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \rm otherwise.\\
     \end{cases}
 \end{equation*}
$$

_轴方向_ 的坐标形成的是帐篷函数，但 _对角线方向_ 是 **二次函数** 。比如说，我们在 $x=y$ 这条对角线上，函数的正值区域的曲线是 $y=(1-x)^2$ 。

#### 例子：二维高斯滤波

同样的，选取高斯函数作为 $f_1$ ，有：

$$
f_{2,g}(x,y) = \frac{1}{2\pi}(e^{-x^2/2}e^{-y^2/2}) \\
\ \ \ \ \ \ \ =\frac{1}{2\pi}(e^{-(x^2+y^2)/2}) \\
=\frac{1}{2\pi}(e^{-r^2/2})
$$

其实你会发现，将一维高斯滤波绕着 $y$ 轴旋转，产生的图形就是二维高斯滤波。所以二维高斯滤波是既旋转对称，也是可分离的。

---

对于其他的二维滤波，可分离的滤波有一个明显的优势：容易实现，效率较高。下面说说为什么效率高：

我们先把可分离滤波 $a_2$ 的表达方式写成离散卷积的方式:

$$(a\star b_2)[i,j] = \sum_{i'}\sum_{j'}a[i',j']b_1[i-i']b_1[j-j']$$

我们发现 $b_1[i-i']$ 的值不取决于 $j'$ ，可以提出来：

$$ = \sum*{i'}b_1[i-i']\sum*{j'}a[i',j']b_1[j-j']$$

将后面的求和缩写为 $S[i']$ ：

$$S[i'] = \sum_{j'}a[i',j']b_1[j-j']$$
$$(a\star b_2)[i,j] = \sum_{i'}b_1[i-i']S[i']$$

为啥要这样化呢？ 这样化出来，我们能够将 $S[i']$ 的每个对应值都存储起来，然后用于计算外层的求和。这有助于提高效率。

举个例子：如果我们要计算在 $[2,2],[3,2]$ 两个点的 $a\star b_2$ 值， $b_1$ 的半径是 $2$ 。我们看上面推出来的公式就会发现，我们需要 $S[0],S[1],...,S[4]$ 来计算 $[2,2]$ 处的值，而同时需要 $S[1],S[2],...,S[5]$ 来计算 $[3,2]$ 处的值。那么我们就可以把这些和全都存起来，这样省去了一大部分计算的时间。

对于大型的滤波器，这样能省非常多的性能， **相当于脱掉了一层循环** 。

算法伪代码如下：

```vb
function filterImage(image I, filter b)
    r = b.radius
    n_x = I.width
    n_y = I.height
    allocate storage array S[0 ... nx−1]
    allocate image I_out[r ... n_x−r−1,r ... ny−r−1]
    initialize S and I_out to all zero
    for j=r to ny−r−1 do
        for i_1=0 to nx−1 do
            S[i_1]=0
            for j_1=j−r to j+r do
                S[i_1] = S[i_1] + I[i_1, j_1]*b[j − j_1]
        for i=r to nx−r−1 do
            for i_1 = i−r to i+r do
                I_out[i, j] = I_out[i, j] + S[i_1]*b[i − i_1]
    return Iout
```

为了简洁，算法省略了边界问题。实际上边界问题有多种解决方法，见 [9.4.3 节] 。

## 9.4 图像的信号处理

我们讨论了采样、滤波、和重建，但都是空谈，而且大多数是针对一维信号。这节我们终于可以开始将图像这样的二维数据处理了。

### 9.4.1 使用 **离散滤波器** 对图像进行滤波

最简单的卷积应用可能就是使用离散卷积处理图像了。而且大多数广泛使用的滤波器都是简单的卷积滤波器。我们可以通过 _低通滤波器_ 实现图像的模糊操作，比如盒式滤波， $\cdots$ ，高斯滤波。高斯滤波能提供非常平滑的模糊，用途广泛。

模糊的反义词是 **锐化** 。那么我们怎么做呢？我们可以做原先模糊的“反操作”。鉴于模糊是将周围的值加到中间，锐化滤波就可以将中间的值减去周围的值。我们将相减的系数设为 $\alpha$ 。为了不影响总体的亮度，我们需要：

$$
I_{sharp} = (1+\alpha)I-\alpha(I\star f_{g,\sigma}) \\
= I \star((1+\alpha)d-\alpha f_{g,\sigma}) \\
= I \star f_{sharp}(\sigma,\alpha).
$$

其中 $f_{g,\sigma}$ 是高斯滤波，宽度为 $\sigma$ 。我们使用离散脉冲 $d$ 充当所谓“单位矩阵”的作用，我们可以将卷积通过分配律化简成一个。

另外一个使用两个滤波器组合的应用是给图像落下阴影。在落下阴影的过程中，我们需要拷贝原图像的信息，然后做一个模糊的外围环绕阴影。对于“外围”的实现，我们可以做一个 _偏离的脉冲函数_ ：

$$
d_{m,n}(i,j) = \begin{equation*}
     \begin{cases}
         1, \ \ \ \ \ i=m \ {\rm and} \ j = n \\
         0, \ \ \ \ \  \rm otherwise.\\
     \end{cases}
 \end{equation*}
$$

然后，将两者组合（我们使用高斯滤波）：

$$
I_{\rm shadow} = (I\star d_{m,n})\star f_{g,\sigma} \\
 = I\star (d_{m,n}\star f_{g,\sigma}) \\
 \ \ \ \ \ \ = I\star f_{\rm shadow}(m,n,\sigma).
$$

这样我们就能使用一个函数（接受三个变量）处理三个滤波做的事情。

### 9.4.2 图像采样中的抗锯齿

在图像合成中，我们经常需要对具有连续数学性质的图像进行采样，然后输出各个点的颜色，最经典的例子就是光线追踪。 [第 4 章] 讲述了光线追踪的例子以及对光线追踪实例进行抗锯齿的具体步骤。用我们这节课的术语来说，我们有一个二维 **信号** （也就是图像），然后通过 **采样** 生成一个二维网格。如果我们就这样下去，不采用特殊操作，那么就会遇到各种各样的 **混叠** ，在图像的比较尖锐的边缘就会出现 **锯齿** 。而在重复出现的纹路上，会出现 **摩尔纹** 。见 [图 9.34] 。

为什么会出现这样的问题？原因是在这里有太多的 **小尺寸细节** 。如果不进行平滑，那么采样的频率就会跟不上细节的频率，造成混叠。所以为了防止这种视觉问题，我们需要在采样前进行 **平滑处理** 。见上图 [图 9.34] ，使用简单的盒式滤波仍然会产生一些摩尔纹，但高斯滤波非常平滑，可以有效防止摩尔纹的产生，但要付出更加模糊的代价。上述方法有效说明了，人们一直在做 **锐度** 和 **混叠** 之间的斗争。

### 9.4.3 重建和重采样

在对图像做滤波时，我们需要仔细留意 **重采样** 操作，也就是改变采样率 ，或者说，改变图像尺寸。

假设我们已经用相机拍了一张 $3000 \times 2000$ 的照片，但我们要在 $1280 \times 1024$ 的显示器上显示，因为我们不想照片被拉伸，所以实际上显示出来的尺寸应该是 $1280 \times 852$ 像素。那么怎么做呢？

一种办法是将这种缩小尺寸的过程看作是扔掉一些不需要的像素。我们发现缩小比例是两到三倍，所以一个像素旁边的一个或两个像素应该被丢弃。这样是可行的，但是你会发现图像质量很差。 [图 9.34] 其实用的就是丢弃像素的方法。虽然效果不会，但丢弃像素运行的非常快，适合生成缩略图。

其实，我们可以将缩放图像的过程看成 **重采样** 的过程。我们将这个图像的“函数”进行连续化，然后再以我们想要的采样率进行重采样。见 [图 9.36] 。为了防止混叠，我们会在各个步骤时使用合适的滤波器。

[图 9.37] 展示了一个例子：原始的图像是 $12\times 9$ 像素，新图像是 $8\times 6$ 的，也就是像素数量（图像面积）变成了原来的 $2/3$ 。

为了能在后续阶段正确采样出样本，我们需要能够计算样本之间的像素值应该取多少。 **丢弃像素法** 给了我们一个很好的思路：也就是寻找离得最近的一个原图像的像素，新的采样点的像素值就是它了。其实，这样操作和 _使用一个半径为 1 的盒式滤波器_ 是一样的效果。

如果我们这一节说的是依据性能选择滤波器，那么这个方法肯定能稳坐宝座了。可惜不是。实际上，在整个图像中使用盒式滤波存在一些困难。但对于更高质量的重采样，重建/采样的过程框架提供了宝贵的灵活性。

我们先在一维讨论算法问题，然后将其推广，这样比较简单。我们在 [9.2.5 节] 说过 _重建函数_ ，这里我们直接利用它：

```vb
function resample(sequence a, float x0, float dx, int n, filter f)
    create sequence b of length n
    for i=0 to n−1 do
        b[i] = reconstruct(a, f, x0 + i*dx)
    return b
```

这里的变量 $x_0$ 提供了基于旧序列的新序列起始地址。也就是，如果输出序列的第一个样本落在旧序列的 $3,4$ 之间，那么 $x_0$ 就是 $3.5$ 。

这个过程相当于通过连续的滤波器重建了一个连续的图像，然后用点来对这个连续图像进行采样。其实连续的图像并不存在，只是存在于我们定的规则之中，但实际上来说，这个函数计算了 $a\star f$ 上一系列点的值。

好像不太对...我们忘记了在采样之前进行模糊化处理！ 正确的过程应该是：我们将重建函数与滤波器 $g$ 进行卷积，然后与点采样函数 $a$ 再进行一次卷积，也就是 $g\star (f\star a)$ 。不过由于结合律，实际上和 $(g\star f)\star a$ 是一样的。
