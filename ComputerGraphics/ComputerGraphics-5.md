<head>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [["$$", "$$"], ["\\[", "\\]"]],
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
</head>

# 第十一章 纹理映射

**现实世界不仅有物体模型，还有物体表面的特征。木材有生长纹理；皮肤有皱纹；布料有编织结构；油漆会有刷子或滚筒的痕迹。就算光滑的塑料也会有凸起，光滑的金属也有加工时留下的痕迹。原先毫无特点的材料也很快就会被凹痕、污渍、划痕、指纹和污垢所覆盖。**

**在计算机图形学中，我们将这些现象统称为“随位置变化的表面属性”，也就是说，表面的属性因位置而异，但并不会真正改变表面的几何形状。为了实现这些效果，所有类型的建模和渲染系统都提供了一些纹理映射的方法：使用一个称为纹理贴图（纹理图像、表面纹理）的图像，来存储在表面上描述的细节，然后用数学方法将图像“映射”到表面上。**

> **这里的映射就是 [2.1 节] 提到过的映射。**

**事实证明，如果我们有一种将图像映射到曲面上的机制，就可以使用许多不太明显的方法来渲染纹理，这些方法超出了引入曲面细节的基本目的。纹理可以用于生成阴影和反射，提供照明，甚至用来定义曲面的形状（没错，法线贴图也是纹理贴图）。在复杂的交互式程序（说人话：游戏）中，纹理甚至用来存储各种与图片无关的数据。**

**本章将会讨论如何使用纹理来表示曲面细节、阴影和反射。虽然基本思想很简单，但是当你看到几个使用纹理的复杂例子之后你就不会这么想了。首先，纹理很容易失真，我们怎么设计才能将纹理正确映射到曲面上呢？此外，纹理映射是一个重采样过程，就像重新缩放图像一样。正如我们在 [第9章] 中看到的，重新采样很容易引入混叠走样。纹理映射和动画的结合使用会让画面产生难看的瑕疵，而纹理映射系统的大部分复杂性也正源于克服这些瑕疵的反走样功能。**

## 11.1 查找纹理值

首先，让我们考虑一个简单的纹理贴图应用程序。假设有一个木地板场景，我们希望通过显示带有木纹的地板的图像来控制地板的漫反射颜色。而不管我们使用的是光线追踪还是传统光栅方法，计算光线表面交点，或是通过光栅化器生成片段颜色的代码，都需要着色点处纹理的颜色值，才能通过 [第10章] 中兰伯特着色模型中正确生成漫反射颜色。

为了获取颜色值，着色器会进行 *纹理查找* ：它会在纹理图像的坐标系中找出与着色点相对应的位置，并读取图像中该点的颜色，从而生成 *纹理样本* ，然后将该颜色用于着色。由于每个看到地板的像素都要进行一遍纹理查找，得到不同的颜色值，因此图像中会显示不同颜色的图案。代码可能长得和下面的伪代码差不多：

```java
Color texture_lookup(Texture t, float u, float v) {
  int i = round(u * t.width() - 0.5)
  int j = round(v * t.height() - 0.5)
  return t.get_pixel(i,j)
}
Color shade_surface_point(Surface s, Point p, Texture t) {
  Vector normal = s.get_normal(p)
  (u,v) = s.get_texcoord(p)
  Color diffuse_color = texture_lookup(u,v)
  // 使用漫反射和法向量计算颜色
  // return 着色结果
}
```
在这段代码中，着色器会查询曲面在纹理中的位置，并且，我们想要使用每个使用纹理着色的曲面都能返回值。这就引出了纹理映射的第一个关键：我们需要一个**从表面映射到纹理的函数**，这样就可以很容易地为每个像素计算该函数货，获得颜色值。  [图11-1] 就是一个 *纹理坐标函数* ，它将纹理坐标映射到表面的每一个点上。

![图11-1](images/11/11-1.png "")

数学上看，就是从表面 $S$ 到纹理域 $T$ 发生了映射：

$$\phi : S \to T$$
$$:(x,y,z) \mapsto (u,v)$$

集合 $T$ ，通常称为 **纹理空间** ，一般来说是一个矩形图像；通常矩形用的是单位正方形： $(u,v) \in [0,1]^2$ （在本书中，我们将使用 $u$ 和 $v$ 作为两个纹理坐标的名字）。在很多情况下，它类似于第7章中讨论的视口投影（在本章中称为 $π$ ）。视口投影的作用是将场景中物体表面上的点映射到图像中的点；两者其实都是3D到2D的映射，渲染的时候也都需要它们：一个用处是获得纹理值，另一个的用处是将着色后的颜色值放在图像正确的位置上。虽然但是，它们也有一些区别： $π$ 的变换方式基本上都是透视或正交投影，而 $φ$ 可以有多种形式；而且，图像只有一个视口投影，而场景中的每个物体的纹理坐标函数可能各不相同。

从表面到纹理的映射看上去好像不太对，但我们是把纹理贴在物体的表面，这样的函数正是我们需要的。

而对于上述的木地板情景，如果地板恰好处于 $z$ 轴的固定高度，并与x和y轴对齐，我们可以使用下面的映射：

$$u=ax; \quad  v=by$$

我们选出合适的 $a,b$ ，将物体坐标 $(x,y,z)$ 映射到纹理坐标 $(s,t)$ 上，然后使用纹理上与该坐标最近位置的 $(u,v)$ 的像素值（ *texel* ）。 [图11-2] 是使用这种方法渲染出来的场景。

![图11-2](images/11/11-2.png "")
![图11-3](images/11/11-3.png "")

不过，这种方法有很多限制：如果房间是以与x轴和y轴中间的某一个夹角建模，或者如果我们想要弯曲的椅背上的木质纹理，那么怎么办呢？这就需要一些更好的方法来计算曲面上点的纹理坐标。

上面讲的简单形式的纹理映射法产生的另一个问题是，我们通过一种从狭窄的的角度，将高对比度的纹理渲染到低分辨率的图像中，最后得到了奇怪的图像。 [图11.3] 显示了一个使用高对比度格子纹理渲染的大平面，视角类似于朝向地平线的样子。你可以看到，它产生了混叠（前面的锯齿和后面密密麻麻的点），这就很像 [第九章] 我们不使用滤波器对图像进行重采样的图案。这里的图像这么小你都能看到混叠，说明它其实非常明显。实际情况可能会好一点，但在动画的生成中，这些图案会四处移动，就算混叠不严重，也会很容易看到画面的问题。

至此，我们现在已经看到了基本纹理映射中的两个大问题：

- 定义纹理坐标函数的困难
- 如何查找纹理值，但不引入太多的混叠

这两个问题对于所有类型的纹理映射应用都很重要，并在 [11.2节] 和 [11.3] 节中进行了讨论。你了解了它们以及它们的解决方案，你就算是参悟了纹理贴图了。剩下的就是如何在不同的应用中将纹理映射模块进行合理的安排，参见 [11.4节] 。

## 11.2 纹理坐标函数

纹理映射的结果如何，主要取决于纹理坐标函数设计的好不好。怎么设计呢？你可以想象一下将一幅矩形的图像慢慢贴合到你绘制的三维物体上；或者，你将三维物体的表面压平，不要让它起皱、撕裂或折叠，最终将它平放在图像上。这个步骤有些时候很容易：也许3D表面已经是一个扁平的矩形。在其他情况下，这其实是非常棘手的：3D形状可能非常复杂，就像角色的身体表面，你很难将图片完美贴合。

学术界早就在研究如何定义纹理坐标函数的问题了。最早遇到这样问题的可能是制作地图的那帮人：地球是圆的，但你需要它展开成一张长方形的地图。从地球仪到平面地图的映射会不可避免地导致区域、角度和/或距离的失真，这会让地图不精确。几个世纪以来，人们提出了许多地图投影，所有投影都在平衡几个不同的问题：在最大限度地减少各种失真的同时，能覆盖纹理映射中尽可能大的一个连续块。



