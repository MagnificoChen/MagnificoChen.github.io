<head>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [["$$", "$$"], ["\\[", "\\]"]],
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
</head>

# 第十一章 纹理映射

**现实世界不仅有物体模型，还有物体表面的特征。木材有生长纹理；皮肤有皱纹；布料有编织结构；油漆会有刷子或滚筒的痕迹。就算光滑的塑料也会有凸起，光滑的金属也有加工时留下的痕迹。原先毫无特点的材料也很快就会被凹痕、污渍、划痕、指纹和污垢所覆盖。**

**在计算机图形学中，我们将这些现象统称为“随位置变化的表面属性”，也就是说，表面的属性因位置而异，但并不会真正改变表面的几何形状。为了实现这些效果，所有类型的建模和渲染系统都提供了一些纹理映射的方法：使用一个称为纹理贴图（纹理图像、表面纹理）的图像，来存储在表面上描述的细节，然后用数学方法将图像“映射”到表面上。**

> **这里的映射就是 [2.1 节] 提到过的映射。**

**事实证明，如果我们有一种将图像映射到曲面上的机制，就可以使用许多不太明显的方法来渲染纹理，这些方法超出了引入曲面细节的基本目的。纹理可以用于生成阴影和反射，提供照明，甚至用来定义曲面的形状（没错，法线贴图也是纹理贴图）。在复杂的交互式程序（说人话：游戏）中，纹理甚至用来存储各种数据，不一定非要是图片（举个例子，我们可以把骨骼动画烘焙到一张纹理中，从而让 GPU 去执行蒙皮操作（GPU Skining），提高性能）。**

**本章将会讨论如何使用纹理来表示曲面细节、阴影和反射。虽然基本思想很简单，但是当你看到几个使用纹理的复杂例子之后你就不会这么想了。首先，纹理很容易失真，我们怎么设计才能将纹理正确映射到曲面上呢？此外，纹理映射是一个重采样过程，就像重新缩放图像一样。正如我们在 [第 9 章] 中看到的，重新采样很容易引入混叠走样。纹理映射和动画的结合使用会让画面产生难看的瑕疵，而纹理映射系统的大部分复杂性也正源于克服这些瑕疵的反走样功能。**

## 11.1 查找纹理值

首先，让我们考虑一个简单的纹理贴图应用程序。假设有一个木地板场景，我们希望通过显示带有木纹的地板的图像来控制地板的漫反射颜色。而不管我们使用的是光线追踪还是传统光栅方法，计算光线表面交点，或是通过光栅化器生成片段颜色的代码，都需要着色点处纹理的颜色值，才能通过 [第 10 章] 中兰伯特着色模型中正确生成漫反射颜色。

为了获取颜色值，着色器会进行 _纹理查找_ ：它会在纹理图像的坐标系中找出与着色点相对应的位置，并读取图像中该点的颜色，从而生成 _纹理样本_ ，然后将该颜色用于着色。由于每个看到地板的像素都要进行一遍纹理查找，得到不同的颜色值，因此图像中会显示不同颜色的图案。代码可能长得和下面的伪代码差不多：

```java
Color texture_lookup(Texture t, float u, float v) {
  int i = round(u * t.width() - 0.5)
  int j = round(v * t.height() - 0.5)
  return t.get_pixel(i,j)
}
Color shade_surface_point(Surface s, Point p, Texture t) {
  Vector normal = s.get_normal(p)
  (u,v) = s.get_texcoord(p)
  Color diffuse_color = texture_lookup(u,v)
  // 使用漫反射和法向量计算颜色
  // return 着色结果
}
```

在这段代码中，着色器会查询曲面在纹理中的位置，并且，我们想要使用每个使用纹理着色的曲面都能返回值。这就引出了纹理映射的第一个关键：我们需要一个**从表面映射到纹理的函数**，这样就可以很容易地为每个像素计算该函数货，获得颜色值。 [图 11-1] 就是一个 _纹理坐标函数_ ，它将纹理坐标映射到表面的每一个点上。

![图11-1](images/11/11-1.png)

数学上看，就是从表面 $S$ 到纹理域 $T$ 发生了映射：

$$\phi : S \to T$$
$$:(x,y,z) \mapsto (u,v)$$

集合 $T$ ，通常称为 **纹理空间** ，一般来说是一个矩形图像；通常矩形用的是单位正方形： $(u,v) \in [0,1]^2$ （在本书中，我们将使用 $u$ 和 $v$ 作为两个纹理坐标的名字）。在很多情况下，它类似于第 7 章中讨论的视图投影（在本章中称为 $π$ ）。视图投影的作用是将场景中物体表面上的点映射到图像中的点；两者其实都是 3D 到 2D 的映射，渲染的时候也都需要它们：一个用处是获得纹理值，另一个的用处是将着色后的颜色值放在图像正确的位置上。虽然但是，它们也有一些区别： $π$ 的变换方式基本上都是透视或正交投影，而 $φ$ 可以有多种形式；而且，图像只有一个视图投影，而场景中的每个物体的纹理坐标函数可能各不相同。

从表面到纹理的映射看上去好像不太对，但我们是把纹理贴在物体的表面，这样的函数正是我们需要的。

而对于上述的木地板情景，如果地板恰好处于 $z$ 轴的固定高度，并与 x 和 y 轴对齐，我们可以使用下面的映射：

$$u=ax; \quad  v=by$$

我们选出合适的 $a,b$ ，将物体坐标 $(x,y,z)$ 映射到纹理坐标 $(s,t)$ 上，然后使用纹理上与该坐标最近位置的 $(u,v)$ 的像素值（ _texel_ ）。 [图 11-2] 是使用这种方法渲染出来的场景。

![图11-2](images/11/11-2.png)
![图11-3](images/11/11-3.png)

不过，这种方法有很多限制：如果房间是以与 x 轴和 y 轴中间的某一个夹角建模，或者如果我们想要弯曲的椅背上的木质纹理，那么怎么办呢？这就需要一些更好的方法来计算曲面上点的纹理坐标。

上面讲的简单形式的纹理映射法产生的另一个问题是，我们通过一种从狭窄的的角度，将高对比度的纹理渲染到低分辨率的图像中，最后得到了奇怪的图像。 [图 11.3] 显示了一个使用高对比度格子纹理渲染的大平面，视角类似于朝向地平线的样子。你可以看到，它产生了混叠（前面的锯齿和后面密密麻麻的点），这就很像 [第九章] 我们不使用滤波器对图像进行重采样的图案。这里的图像这么小你都能看到混叠，说明它其实非常明显。实际情况可能会好一点，但在动画的生成中，这些图案会四处移动，就算混叠不严重，也会很容易看到画面的问题。

至此，我们现在已经看到了基本纹理映射中的两个大问题：

- 定义纹理坐标函数的困难
- 如何查找纹理值，但不引入太多的混叠

这两个问题对于所有类型的纹理映射应用都很重要，并在 [11.2 节] 和 [11.3] 节中进行了讨论。你了解了它们以及它们的解决方案，你就算是参悟了纹理贴图了。剩下的就是如何在不同的应用中将纹理映射模块进行合理的安排，参见 [11.4 节] 。

## 11.2 纹理坐标函数

纹理映射的结果如何，主要取决于纹理坐标函数设计的好不好。怎么设计呢？你可以想象一下将一幅矩形的图像慢慢贴合到你绘制的三维物体上；或者，你将三维物体的表面压平，不要让它起皱、撕裂或折叠，最终将它平放在图像上。这个步骤有些时候很容易：也许 3D 表面已经是一个扁平的矩形。在其他情况下，这其实是非常棘手的：3D 形状可能非常复杂，就像角色的身体表面，你很难将图片完美贴合。

学术界早就在研究如何定义纹理坐标函数的问题了。最早遇到这样问题的可能是制作地图的那帮人：地球是圆的，但你需要它展开成一张长方形的地图。从地球仪到平面地图的映射会不可避免地导致区域、角度和/或距离的失真，这会让地图不精确。几个世纪以来，人们提出了许多地图投影，所有投影都在平衡几个不同的问题：在最大限度地减少各种失真的同时，能覆盖纹理映射中尽可能大的一个连续块。

在一些应用程序中(我们将在本章后面看到)，我们有理由使用某些特定种类的映射，不用自己单独写。但在大多数情况下，设计纹理坐标映射是一项高端任务，需要在一系列冲突的收益面前找到平衡点，熟练的建模师也需要付出相当大的努力。

你可以用任何想得到的方法来定义 $φ$ 。但有几个利益冲突的地方需要考虑:

- **双射。** 在大多数情况下，你希望 $φ$ 是 _双射_ 的(参见 [2.1.1 节] )，这样表面上的每个点都能映射到纹理空间中的各个点。如果几个点映射到同一个纹理空间中的点，纹理中一个点的值改变将影响表面上所有映射的点的值。如果你想让纹理在表面上重复(比如有重复图案的壁纸或地毯)，那么多对一映射是有意义的，但如果是个意外，那就不太好了。
- **大小失真。** 纹理的缩放应该在整个表面上基本不变。也就是说，所有表面上距离相同的紧密点也应该都被映射到纹理中距离相同的点。因此就函数 $φ$ 而言， $φ$ 的导数的变化率（二阶导）不能太大。
- **形状失真。** 纹理看上去不应该是是扭曲的。也就是说，在表面绘制的一个小圆形，应该映射到纹理空间中的一个合理的圆形，而不是一个被压扁或拉长的样子。因此对函数 $φ$ 而言， $φ$ 的导数在不同方向上（方向导数）不应相差太大。
- **连续性。** 生成的纹理贴图不应该有太多缝：表面上的相邻点也应该映射到纹理中的相邻点。也就是说对函数 $φ$ 来说，应该是连续的，再不济也需要不连续尽可能的少。在大多数情况下，一些不连续是不可避免的，那么我们可以尽量把它们放在不显眼的位置。

通过 _参数方程_ ( [2.5.8 节] )定义的曲面有一个开箱即用的纹理坐标函数可作为选择：也就是简单地将曲面参数方程取逆，然后将两个参数 $u,v$ 用作纹理坐标。这些纹理坐标可能有，但也也可能没有我们想要的属性（取决于表面形状等因素），但它们确实提供的是一个映射，可以作为纹理映射。

但是对于 _隐式曲面_ ，或者只是由三角形网格定义的曲面，我们需要一些其他的方法来定义纹理坐标，不能依赖于现有的参数化的方法。广义上讲，定义纹理坐标的两种方法是从表面上的点坐标、或从网格表面，通过几何的计算，在它们的顶点存储纹理坐标的值，然后对整个表面进行插值。下面让我们挨个看看这些方法。

### 11.2.1 几何确定的纹理坐标

几何确定的纹理坐标用于形状简单的场景或某些特殊情况。它是一种快速的办法。或者我们可以先算出它，然后手工调整纹理坐标映射。我们将通过讲解如何把 [图 11.4] 的测试图像映射到表面，来阐述各种各样的纹理坐标函数。纹理图像中的数字可以让你方便地从渲染出的图像中看到近似的 $(u, v)$ 坐标，网格可以让您看到映射的扭曲程度。

![图11-4](images/11/11-4.png)
![图11-5](images/11/11-5.png)

#### 平面投影

从 3D 到 2D 最简单的映射可能就是平行投影了：它用的映射和正交投影使用的映射相同( [图 11-5] )。我们在 [7.1 节] 已经研究出来的用于 _视图变换_ 的机制，可以直接用在纹理坐标的变换上：就像正交投影可以通过矩阵相乘，然后可以丢掉 $z$ 分量一样，通过平面投影生成的纹理坐标也可以通过简单的矩阵相乘来完成：

$$
\phi (x,y,z) = (u,v) \quad {\rm where}  \left [ \begin{matrix}
    u \\
    v \\
    * \\
    1 \\
    \end{matrix} \right ] = M_t \left [ \begin{matrix}
    x \\
    y \\
    z \\
    1 \\
    \end{matrix} \right ],
$$

其中，纹理矩阵 $M_t$ 表示仿射变换， $*$ 表示我们不关心第三个坐标的结果，也就是可丢弃的 $z$ 。

这对于几乎平坦的表面有很好的效果，因为表面法线没有太多变化，通过对法线取平均就可以找到一个不错的投影方向了。但是对于所有的闭合物体，这样的平行投影 **不是单射**：不管是前面还是后面的物体坐标，都会被映射到同一个纹理值上。（ [图 11-6] ）

![图11-6](images/11/11-6.png)
![图11-7](images/11/11-7.png)

通过简单地用透视投影代替正交投影，我们同样能得到投影纹理坐标( [图 11-7] )：

$$
\phi (x,y,z) = (\tilde{u}/w,\tilde{v}/w) \quad {\rm where}  \left [ \begin{matrix}
    u \\
    v \\
    * \\
    1 \\
    \end{matrix} \right ] = P_t \left [ \begin{matrix}
    x \\
    y \\
    z \\
    1 \\
    \end{matrix} \right ],
$$

现在 $4×4$ 矩阵 $P_t$ 表示一个投影变换（不一定是仿射变换）：也就是说，最后一行可能不是 $[0,0,0,1]$ 。

基于投影的纹理坐标在 _阴影映射_ 技术中很重要，详见 [11.4.4 节] 。

#### 球坐标映射

对于球面，我们一般通过参数化球面的经纬度来构建球坐标。

形状大致为球形的表面的参数化可以使用这种纹理坐标函数：使用径向投影将表面上的点映射到球体上的点（也就是说，从球体中心通过表面上的点取一条直线，并找到与球体的交点），这个交点的球坐标就是纹理映射的起始坐标。

说人话！另一种说法是，你用球坐标 $(ρ,θ,φ)$ 表示曲面上的点，然后丢掉 $ρ$ 坐标（因为没啥用，我们映射纹理与这个球上有没有凸出来的点没有关系），将 $θ$ 和 $φ$ 分别映射到范围 $[0,1]$ 内，就是一个纹理映射了。这个公式依赖于 **球坐标** ，参见 [2.5.8 节] 。

$$\phi (x,y,z) = ([\pi+{\rm atan2}(y,x)]/2\pi ,[\pi - acos(z/\parallel x \parallel)]/ \pi)$$

> **atan2** 函数之前提到过，参见 https://baike.baidu.com/item/atan2/10931300

如果一个物体从中心点看，可以看到整个表面，那么球坐标除了球的极点以外的所有地方都是 **双射** 。和球坐标一样，它也有两极附近失真的问题。 [图 11.8] 显示了一个使用球面坐标的物体，这样的纹理映射比较合适。

> 本章中的所有纹理坐标函数用于标准立方体 $[−1,1]^3$ 中，以原点为中心。

![图11-8](images/11/11-8.png)
![图11-9](images/11/11-9.png)

#### 柱坐标映射

对于长得更像柱状，而不是球形的物体，从一根竖着的轴 向外投射到圆柱体上 的方法 比 由中间一个点投射到球体上的映射效果更好。与球面投影类似，这相当于转换为柱坐标，然后丢掉半径：

$$\phi (x,y,z) = \left(\frac{1}{2\pi} [\pi+{\rm atan2}(y,x)]/2\pi, \frac{1}{2}[1+z] \right)$$

#### 立方体贴图

使用球坐标来参数化一个球形或类似球形的物体，通常会导致在这两个球极点附近有很明显的走样，也就说明了纹理中有两个特殊的点出了问题。有一个常用的解决办法是将映射规范化，但它会将纹理变得不连续。这个方案的具体做法是：先将图案先投射到一个立方体上，而不是球体上，然后为立方体的六个面使用六个单独的正方形纹理。这六个正方形纹理就叫 **立方体贴图** 。

计算立方体贴图的纹理坐标也比球面坐标开销更少，因为投影到平面上只需要进行一个除法 —— 它的本质和视图成像的透视投影一样：

$$(x,y,z) \mapsto \left(\frac{x}{z} , \frac{y}{z} \right).$$

立方体贴图存在一个问题，那就是如何在六个面上定义 u 和 v 方向，而这需要一个约定俗成的规矩。选择不同的规定会影响纹理的内容，所以引入一个通用的规矩很重要。由于立方体贴图通常是用在从立方体内部看向六个面，纹理是在立方体的内部，所以我们通常约定，把 $u$ 和 $v$ 调整为从里面看 $u$ 相对于 $v$ 是时针方向。 **OpenGL** 采用下面的约定：

$$\phi_{-x}(x,y,z) = \frac{1}{2} [1+(+z,-y)/|x|]$$
$$\phi_{+x}(x,y,z) = \frac{1}{2} [1+(-z,-y)/|x|]$$
$$\phi_{-y}(x,y,z) = \frac{1}{2} [1+(+x,-z)/|y|]$$
$$\phi_{+y}(x,y,z) = \frac{1}{2} [1+(+x,+z)/|y|]$$
$$\phi_{-z}(x,y,z) = \frac{1}{2} [1+(-x,-y)/|z|]$$
$$\phi_{+z}(x,y,z) = \frac{1}{2} [1+(+x,-y)/|z|]$$

其中，下标表示每个投影对应于立方体的哪个面。例如， $φ_{−x}$ 表示在映射到 $x = +1$ 这个面的点。你可以观察绝对值最大的坐标，来判断一个点投影到了哪个面:例如，如果 $|x| > |y|$ 和 $|x| > |z|$ 也就是 $x$ 的绝对值最大，那么这个点就投影到了 $+x$ 面或 $-x$ 面，按 $x$ 的符号而定。

![图11-10](images/11/11-10.png)

一个用于立方体贴图的纹理包含了六个正方形 (见 [图 11.10] )，它们通常是存储在一张图里的，也就是存储了立方体的展开图。

### 11.2.2 插值纹理坐标

对于三角形网格表面，我们可能需要更精细地控制纹理坐标函数。您可以显式地存储每个顶点的纹理坐标，然后用 **重心坐标** （[8.1.2 节]）对它插值。插值方法与网格上定义的其他平滑变化的量完全相同：比如颜色，法线，就算是 3D 位置本身也是通过这种方法插值的。

> 重心坐标很简单，但很重要，如果你忘了就回去看看！

我们来看一个例子，只有一个三角形。 [图 11-11] 显示了一个三角形纹理，它映射了一部分先前的测试图案。通过观察三角形上的图案，很容易就能发现这三个点的纹理坐标是 $(0.2,0.2)$ 、 $(0.8,0.2)$ 和 $(0.2,0.8)$ ，它们在纹理中也是一个三角形。
和上一节的映射一样，我们通过指定纹理映射函数来指定纹理在表面上的位置。这样，再赋值三个顶点，顶点和纹理空间的位置就对应起来了。只要顶点成功定位了，三角形之间的点就可以通过线性（重心）插值解决。

![图11-11](images/11/11-11.png)
![图11-12](images/11/11-12.png)

[图 11-12] 中，我们介绍了一种在整个网格上让纹理坐标可视的方法：也就是在纹理图像上直接画三角形，然后确定三角形各个顶点的纹理位置。通过这样的可视化，我们看到哪部分纹理用在哪个三角形上。这种方法在 debug 和划分纹理区域的时候非常有用。

通过顶点定义的纹理坐标映射的画面质量取决于顶点的选择 —— 也就是说，取决于怎么选取合适的网格。不管分配了什么坐标，只要网格中的三角形有公共顶点( [12.1 节] )，纹理坐标映射就是连续的。因为相邻的三角形在它们共享顶点上的纹理坐标一样。但是上面描述的其他性质就没那么好了。 _单射性_ 意味着，三角形在纹理空间中一定不会重叠 —— 如果重叠了，就说明纹理中的某个点会在曲面上好几个地方出现，那肯定不对。

![图11-13](images/11/11-13.png)

当纹理空间中三角形的面积与其在三维空间中的面积成比例时，就不容易出现 _大小失真_ 。比如，如果用连续的纹理坐标函数映射一个人脸，鼻子部分的纹理空间通常就只能在纹理图像中的一小块区域，如 [图 11-13] 。虽然鼻子上的三角形比脸颊上的小，但尺寸比例在纹理空间上的显示更加离谱。最终结果就会造成鼻子上的纹理被放大，因为小面积的纹理覆盖了较大的面积。同样地，我们比较一下前额和太阳穴，三角形在三维空间中大小相似，但太阳穴周围的三角形在纹理空间中更大，会导致纹理在太阳穴看起来更小。

同样，当三角形的形状在三维和纹理空间中比较近似时，大小失真就不明显了。其实这个人脸的例子的大小失真还算是比较轻微的，但是，还有一个例子，[图 11-17] 中的球体在极点附近的大小失真就很明显。

### 11.2.3 材质平铺、拼接模式和纹理转换

我们应该允许纹理坐标超出纹理图像的边界。有这样一个细节让我们考虑这个问题：比如纹理坐标计算中的舍入错误，可能会导致一个落在纹理边界上的顶点的超出一点点，但纹理映射机制不应该轻易报错。而大多数情况，纹理映射能够超出图像边界的功能有其他用途。

如果一个纹理只应该覆盖表面的一部分，但是纹理坐标已经被设置成了对整个表面进行映射，那么我们有一种选择是：准备一个尺寸不大的、大部分空白的纹理图像。但是这样的话你要得到非空白的纹理，那一小块地方必须做的非常精细。还有一种方法，就是缩放所有纹理坐标，这样的话它就能覆盖更大的范围，比如 $[-4.5,5,5] \times [-4.5,5,5]$ 。这样就可以把单位正方形定位在曲面中心的十分之一大小的地方了。

对于上面这样的情况，如果查找落到了单位正方形的外面，应该返回恒定的背景颜色。一种方法是设置一个背景色，接收到单位正方形外的纹理查询就可以直接返回。如果纹理图像已经有恒定的背景颜色了(例如，白色背景上的徽标)，另一种方式是拓展背景颜色到平面上，可以允许单位正方形以外的查找，返回纹理图像边缘上最近点的颜色。我们可以从第一个像素到最后一个像素逐渐逼近 $u$ 和 $v$ 坐标（也就是 **拉伸** ），来实现这个效果。

不过有时候一个重复的图案正是我们需要的，比如棋盘、瓷砖地板或砖墙。如果这种纹理在矩形网格上重复出现一模一样的，那么创建这么大的图像就太浪费了。相反，我们可以使用 _环绕索引_ 来处理纹理图像之外的纹理查找 —— 当查找的点超出纹理图像的右边后，它就会返回到左边缘。我们通过对坐标进行整数取余操作就可以非常简单的处理这个问题。代码如下：

```java
Color texture_lookup_wrap(Texture t, float u, float v) {
  int i = round(u * t.width() - 0.5)
  int j = round(v * t.height() - 0.5)
  return t.get_pixel(i % t.width(), j % t.height())
}

Color texture_lookup_wrap(Texture t, float u, float v) {
  int i = round(u * t.width() - 0.5)
  int j = round(v * t.height() - 0.5)
  return t.get_pixel(max(0, min(i, t.width()-1)),
                    (max(0, min(j, t.height()-1))))
}
```

![图11-14](images/11/11-14.png)

怎么选择这两种越界查找的处理方式呢？我们可以通过选择 _拼接模式_ 来完成。包装模式包含了平铺、拉伸， 或者也可以是这两种方式的组合或变体。使用拼接模式，我们可以将纹理想象成一个函数，它可以在无限二维平面中的任何一点返回颜色 ( [图 11.14] ) 。当我们使用图像指定了一个纹理时，拼接模式就可以告诉纹理映射函数怎么使用有限的图像数据来寻值。在 [11.5 节] 中，我们将看到纹理可以通过程序自然地扩展到无限大的平面上，因为它们不受有限图像数据的限制。由于两者在逻辑上都是无限的，这两种类型的纹理可以互换。

当调整纹理的缩放和位置时，我们不应该修改生成纹理坐标的方法，也不应该修改存储在网格顶点中的纹理坐标，相反地，我们可以在对纹理进行采样前应用矩阵变换：

$$\phi({\rm \textbf{x}}) = {\rm\textbf{M}}_T \ \phi_{\rm model} (\rm\textbf{x})$$

这里 $\phi_{\rm model}$ 是模型提供的纹理坐标函数， ${\rm \textbf{M}}_T$ 是一个 3x3 的矩阵,表示一个使用齐次坐标进行二维纹理坐标的仿射变换或投影变换。这样的变换有有时是被限制的，只能进行缩放或平移。大部分使用纹理映射的渲染器都支持这样的功能。

### 11.2.4 正确的透视插值

我们其实没法对三角形进行纹理坐标插值来获得正确的透视视觉效果，但是我们可以在光栅化阶段解决这个问题。事情不简单的原因是我们只在屏幕空间对纹理进行了插值，这导致图片的视觉效果有问题，就像 [图 11.15] 展示的网格纹理一样。

![图11-15](images/11/11-15.png)

由于透视中的物体随着与观看者距离的增加而变小，所以在三维中均匀间隔的线条应该在二维图像空间中被压缩。为了实现这一点，需要对纹理坐标进行更仔细的插值。

我们可以按 [8.1.2 节] 修改光栅化的方法,通过对 $(u,v)$ 坐标进行插值来实现三角形上的纹理映射，但是这会导致 [图 11.15] 右图所示的问题。如果屏幕空间的重心坐标在下面的光栅化代码中被这样使用，类似的的问题也会在三角形上出现：

```java
for all x do
  for all x do
    compute(α, β, γ) for (x, y)
    if α ∈ (0, 1) and β ∈ (0, 1) and γ ∈ (0, 1) then
      t = α*t_0 + β*t_1 + γ*t_2
      drawpixel (x, y) with color texture(t) for a solid texture
      or with texture(β, γ) for a 2D texture.
```

这段代码会渲染出有问题的图像。为了解决问题，让我们思考一下从世界空间 $\rm\textbf{q}$ 到齐次点 $\rm\textbf{r}$ 再到齐次点 $\rm\textbf{s}$ 的过程:

$$\left [ \begin{matrix} x_q \\ y_q \\ z_q \\ 1 \\\end{matrix} \right ] \stackrel{\rm transform}{\longrightarrow} \left [ \begin{matrix} x_r \\ y_r \\ z_r \\ 1 \\\end{matrix} \right ]\stackrel{\rm homogenize}{\longrightarrow} \left [ \begin{matrix} x_r/h_r \\ y_r/h_r \\ z_r/h_r \\ 1 \\\end{matrix} \right ] \equiv \left [ \begin{matrix} x_s \\ y_s \\ z_s \\ 1 \\\end{matrix} \right ]$$

处理纹理坐标插值问题最简单的方法是，当我们有两个点 $\rm\textbf{q}$ 和 $\rm\textbf{Q}$ ，都和纹理坐标 $(u,v)$ 相关联的时候，我们需要在图像中沿着 $\rm\textbf{s}$ 和 $\rm\textbf{S}$ 之间的直线生成纹理坐标。如果世界坐标中有一个在 $\rm\textbf{q}$ 和 $\rm\textbf{Q}$ 之间的点 $\rm\textbf{q}'$ ，它被投影到 $\rm\textbf{s}$ 和 $\rm\textbf{S}$ 中的一点 $\rm\textbf{s}'$ ，那么这两个点应该有相同的纹理坐标。

上面那个朴素的屏幕空间的算法表明：对于点 $\rm\textbf{s}' = \alpha(\textbf{S} - \textbf{s})$ ，我们
